<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>QT网络通信</title>
    <url>/2021/05/17/QT%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="1、TCP通信流程"><a href="#1、TCP通信流程" class="headerlink" title="1、TCP通信流程"></a>1、TCP通信流程</h3><p><strong>服务器：</strong>服务器首先建立<code>QTcpSever</code>的监听套接字，然后启动<code>listen</code>进行监听，当监听到客户端请求何其建立连接时，会触发<code>newconnection</code>这个信号，表示客户端和服务器建立连接，此时再利用服务器的<code>nextPendingConnection()</code>获取通信套接字<code>QTcpSocket</code>,可以<code>peerAddress（）</code>和<code>peerPort()</code>获取客户端的IP和端口号。然后利用<code>write()</code>函数发送数据，并且绑定<code>readRead</code>信号，当客户端发送数据时，将会触发该信号进行读取。</p>
<p><strong>客户端：</strong>客户端首先创建<code>QTcpSocket</code>通信套接字，在使用<code>connectTohost</code>连接到服务器，连接成功时将会接通<code>connected</code>这个信号，断开连接时将会接通<code>disconnected</code>这个信号，然后利用<code>write()</code>函数发送数据，并且绑定<code>readRead</code>信号，当服务器发送数据时，将会触发该信号进行读取。</p>
<p><img src="https://zhuom-go.github.io/img/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/tcp%E9%80%9A%E8%AE%AF%E6%B5%81%E7%A8%8B.jpg" alt="img"></p>
<h3 id="2、UDP通信流程"><a href="#2、UDP通信流程" class="headerlink" title="2、UDP通信流程"></a>2、UDP通信流程</h3><p><strong>服务器：</strong>服务器直接创建<code>QUdpSocket</code>套接字，然后利用<code>bind()</code>绑定端口号，就可以进行读写操作了，当客户端发送数据时还是触发<code>readyRead()</code>这个信号，读写函数使用<code>readDatagram</code>和<code>writeDatagram</code></p>
<p><strong>客户端：</strong>客户端首先创建<code>QUdpSocket</code>通信套接字，然后既可进行读写操作。</p>
<p>**组播:**当多个客户端想同时向服务器发送数据时，服务器可以进行组播，使用<code>bind(QHostAddress::AnyIPV4,8888)</code>绑定<code>IPV4</code>的端口号，在加入组播地址既可，（地址需为D类地址）<code>joinMulticastGroup(QHostAddress(&quot;224.0.0.2&quot;))</code>；此时将可以实现多个客户端向其发送数据</p>
<p><img src="https://zhuom-go.github.io/img/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/udp%E9%80%9A%E8%AE%AF%E6%B5%81%E7%A8%8B.jpg" alt="img"></p>
<h3 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h3><p>1、<code>UDP</code>与<code>TCP</code>相比少了监听的步骤，所以客户端不必连接<br>2、<code>TCP</code>是服务器直接监听<code>ip</code>和端口号，所以所有的客户端只要连接到服务器，然后读写就可以正常进行；而<code>UDP</code>的是单独的通讯，理论上都可以作为服务器，所以服务器在进行发送时，需要知道对方的端口号和<code>ip</code>地址。<br>3、**<code>TCP</code>通讯会有黏包的问题，**可以使用延时来解决；</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
  </entry>
  <entry>
    <title>Qt绘图事件</title>
    <url>/2021/05/14/QT%E7%BB%98%E5%9B%BE%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="1、QPainter"><a href="#1、QPainter" class="headerlink" title="1、QPainter"></a>1、QPainter</h3><p>在主窗口绘图时，需要绘制在绘图事件<code>paintEvent</code>里面，使用方法为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写paintEvent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paintEvent</span><span class="params">(QpaintEvent *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;<span class="comment">//指定绘图的对象，可以为别的，比如自己创建的QPixmap或者QImag</span></span><br><span class="line">  <span class="comment">/* 也可以这样</span></span><br><span class="line"><span class="comment">  QPainter p;</span></span><br><span class="line"><span class="comment">  p.begin(this);</span></span><br><span class="line"><span class="comment">  .</span></span><br><span class="line"><span class="comment">  .</span></span><br><span class="line"><span class="comment">  .</span></span><br><span class="line"><span class="comment">  p.end();*/</span></span><br><span class="line">  p.drawPixmap(..); <span class="comment">//绘制背景图片,里面可以填充二进制图片显示QBitmap</span></span><br><span class="line">  p.drawLine(...);<span class="comment">//绘制直线</span></span><br><span class="line">  <span class="comment">//对于画家还可以setPen和setBrush，分别为画的对象改变线条样式和填充样式</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//update()可以手动调用paintEvent();</span></span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、QPixmap、QImage和QPicture的区别"><a href="#2、QPixmap、QImage和QPicture的区别" class="headerlink" title="2、QPixmap、QImage和QPicture的区别"></a>2、QPixmap、QImage和QPicture的区别</h3><p><code>QPixmap</code>主要是针对了窗口进行了优化，和平台有关，但是不能更改图片</p>
<p><code>QImage</code>和平台无关，可以对图片进行修改，并可在<strong>线程</strong>中使用,<code>QImage</code>可以设置背景色为透明，<code>QImage image(50,50,Qt::Format_ARGB32)</code>,然后再把图片画进去</p>
<p><code>QPicture</code>主要用于以二进制的方式存储图片</p>
<p><strong><code>QPixmap</code>与<code>QImage</code>相互转换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//QPixmap转QImage</span></span><br><span class="line">QImage tempImage=pixmap.toImage();</span><br><span class="line"><span class="comment">//QImage转QPixmap</span></span><br><span class="line">QPixmap tempPixmap=QPixmap::fromImage(image);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把主窗口设置成透明</span></span><br><span class="line">setAttribute(Qt::WA_TranslucentBackground);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
        <category>绘图</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt样式</title>
    <url>/2021/04/29/Qt%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="1、Font字体样式"><a href="#1、Font字体样式" class="headerlink" title="1、Font字体样式"></a>1、Font字体样式</h4><p>字体大小：<code>font-size：</code>，<code>x-large</code>为特大，<code>xx-small</code>为特小,一般可直接使用数字，单位是<code>px</code>和<code>pd</code><br>样式：<code>font-style：</code>，<code>oblique</code>为偏斜体,<code>italic</code>为斜体,<code>normal</code>为正常<br>粗细：<code>font-weight：</code>，<code>bold</code>为粗体，<code>lighter</code>为细体,<code>normal</code>为正常<br>大小写：<code>text-transform:</code>，<code>capitalize</code>为首字母大写，<code>uppercase</code>为大写，<code>lowercase</code>为小写，<code>none</code>无<br>修饰：<code>text-decoration:</code>，<code>underline</code>为下划线，<code>overline</code>为上划线，<code>line-through</code>为删除线，<code>blink</code>为闪烁<br>字体：<code>font-family:</code>，<code>Courier New</code>, <code>Courier</code>, <code>monospace</code>, <code>Times New Roman</code>, <code>Times</code>, <code>serif</code>, <code>Arial</code>, <code>Helvetica</code>, <code>sans-serif</code>, <code>Verdana</code><br>行高：<code>line-height:</code>，<code>normal</code>为正常，可以用数字,单位为<code>px,pd,em</code></p>
<h4 id="2、background背景样式"><a href="#2、background背景样式" class="headerlink" title="2、background背景样式"></a>2、background背景样式</h4><p>背景颜色：<code>background-color:</code>，直接填颜色<br>背景图片：<code>backgound-image:url()</code>，填图片路径，但是<strong>通常使用</strong><code>border-image:url()</code>，这样的图片显示可以自适应  </p>
<h4 id="3、伪状态显示"><a href="#3、伪状态显示" class="headerlink" title="3、伪状态显示"></a>3、伪状态显示</h4><p> 部件的外观可以按照用户界面元素状态的不同来分别定义，这在样式表中被称为“伪状态”。例如，如果我们想在一个<code>pushbutton</code>在被按下的时候具有不一样的外观，我们可以指定一个叫做 <code>:pressed</code> 的伪状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QPushButton &#123;</span><br><span class="line">   border: <span class="number">2</span>px outset green; <span class="comment">//普通状态</span></span><br><span class="line">   background: gray;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> QPushButton:pressed &#123;</span><br><span class="line">   border-style: inset;  <span class="comment">//按下时的状态</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>下面是可用的伪状态列表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪状态  描述</span></span><br><span class="line">:checked  <span class="comment">//button部件被选中</span></span><br><span class="line">:disabled  <span class="comment">//部件被禁用</span></span><br><span class="line">:enabled  <span class="comment">//部件被启用</span></span><br><span class="line">:focus  <span class="comment">//部件获得焦点</span></span><br><span class="line">:hover  <span class="comment">//鼠标位于部件上</span></span><br><span class="line">:indeterminate  <span class="comment">//checkbox或radiobutton被部分选中</span></span><br><span class="line">:off  <span class="comment">//部件可以切换，且处于off状态</span></span><br><span class="line">:on  <span class="comment">//部件可以切换，且处于on状态</span></span><br><span class="line">:pressed  <span class="comment">//部件被鼠标按下</span></span><br><span class="line">:unchecked  <span class="comment">//button部件未被选中</span></span><br></pre></td></tr></table></figure>

<h4 id="4、使用子部件定义微观样式"><a href="#4、使用子部件定义微观样式" class="headerlink" title="4、使用子部件定义微观样式"></a>4、使用子部件定义微观样式</h4><p> 许多部件都包含有子元素，这些元素可以称为“子部件”。<code>Spinbox</code>的上下箭头就是子部件最好的例子。<br> 子部件可以通过<code>::</code>来指定，例如<code>QDateTimeEdit::up-button</code>。定义子部件的样式与定义部件非常相似，它们遵循前面提到的方箱模型（即它们可以拥有自己的边框、背景等），并且也可以和伪状态联合使用（例如<code>QSpinBox::up-button:hover</code>）。</p>
<p> 下表列出了可用的子部件类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">子部件  描述</span><br><span class="line">::down-arrow  <span class="comment">//combobox或spinbox的下拉箭头</span></span><br><span class="line">::down-button  <span class="comment">//spinbox的向下按钮</span></span><br><span class="line">::drop-down  <span class="comment">//combobox的下拉箭头</span></span><br><span class="line">::indicator  <span class="comment">//checkbox、radio button或可选择groupbox的指示器</span></span><br><span class="line">::item  <span class="comment">//menu、menubar或status bar的子项目</span></span><br><span class="line">::menu-indicator  <span class="comment">//pushbutton的菜单指示器</span></span><br><span class="line">::title  <span class="comment">//groupbox的标题</span></span><br><span class="line">::up-arrow  <span class="comment">//spinbox的向上箭头</span></span><br><span class="line">::up-button  <span class="comment">//spinbox的向上按钮</span></span><br></pre></td></tr></table></figure>

<h4 id="5、位置固定"><a href="#5、位置固定" class="headerlink" title="5、位置固定"></a>5、位置固定</h4><p> 通过指定<code>subcontrol-position</code>和<code>subcontrol-origin</code>属性，子部件可以被放置在部件箱体内的任何位置。并且，子部件的位置还可以使用相对或绝对的方式进一步的调整。具体选择何种调整方式取决于子部件具有固定的大小，还是会随着父部件而变化。</p>
<p> <strong>5.1. 相对定位</strong></p>
<p>  相对定位适合于子部件具有固定大小的情形（通过width和height指定子部件大小）。使用这种方式，子部件可以以相对于<code>subcontrol-position</code>和 <code>subcontrol-origin</code>属性定义的原始位置进行移动调整。使用<code>left</code>属性可以把子部件向右移，<code>top</code>属性可以把子部件向左移。</p>
<p> 例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QPushButton::menu-indicator &#123;</span><br><span class="line">  image: url(menu_indicator.png);</span><br><span class="line">  width: <span class="number">13</span>px;</span><br><span class="line">  height: <span class="number">13</span>px;</span><br><span class="line"></span><br><span class="line">  subcontrol-origin: padding;</span><br><span class="line">  subcontrol-position: bottom right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 当按下按钮时，我们可以把菜单指示器从原来的位置向右下方移动几个像素来模拟按钮按下的状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QPushButton::menu-indicator:pressed &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  top: <span class="number">2</span>px;</span><br><span class="line">  left: <span class="number">2</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>5.2. 绝对定位</strong></p>
<p> 绝对定位适合于子部件的位置随父部件的变化而变的情形。与前面的例子相同，<code>subcontrol-origin</code>定义了父部件箱体的参考矩形。子部件的矩形区域则可以随后通过相对于这个参考矩形四边的偏移量来定义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QPushButton::menu-indicator &#123;</span><br><span class="line">  border: 2px solid red;</span><br><span class="line"></span><br><span class="line">  subcontrol-origin: padding;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 2px;</span><br><span class="line">  right: 2px;</span><br><span class="line">  bottom: 2px;</span><br><span class="line">  left: 40px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 对于宽度或高度固定的子部件，subcontrol-position被用来说明其在subcontrol-origin指定矩形内的对其方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QPushButton::menu-indicator &#123;</span><br><span class="line">  image: url(menu_indicator.png);</span><br><span class="line">  width: 13px;</span><br><span class="line"></span><br><span class="line">  subcontrol-origin: padding;</span><br><span class="line">  subcontrol-position: bottom right;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 2px;</span><br><span class="line">  bottom: 2px;</span><br><span class="line">  right: 2px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title>PLC编程</title>
    <url>/2021/03/22/PLC/</url>
    <content><![CDATA[<h3 id="1、双线圈冲突"><a href="#1、双线圈冲突" class="headerlink" title="1、双线圈冲突"></a>1、双线圈冲突</h3><p>在进行PLC编程时<a id="more"></a>，首先要注意的是<strong>双线圈冲突问题</strong>，典型的就是某一个线圈在同一段使用了两次，例如</p>
<p><img src="https://zhuom-go.github.io/img/PLC/shuangxianquan.jpg" alt="img"></p>
<p>此时<code>Q0.0</code>在这一段里需要执行两次，如果直接用线圈驱动，此时会被第二次的情况覆盖掉，所以此时需要用一个继电器去替代它。</p>
<p><img src="https://zhuom-go.github.io/img/PLC/jjff.jpg" alt="image-20210322232500994"></p>
<p><strong>此外还要特别注意线圈是否在别的地方使用，防止线圈使用冲突</strong></p>
<h3 id="2、定时器、接通延时的内部信号冲突"><a href="#2、定时器、接通延时的内部信号冲突" class="headerlink" title="2、定时器、接通延时的内部信号冲突"></a>2、定时器、接通延时的内部信号冲突</h3><p>对于上面这些定时器，不要直接用<code>T1.Q</code>的形式去直接输出，否则可能会由于内部的时间冲突导致混乱，可以用一个中间继电器转换，或者可以的话直接在后面输出。</p>
<p><img src="https://zhuom-go.github.io/img/PLC/dingshiqi.jpg" alt="image-20210322232500994"></p>
<h3 id="3、判断电路"><a href="#3、判断电路" class="headerlink" title="3、判断电路"></a>3、判断电路</h3><p><img src="https://zhuom-go.github.io/img/PLC/PLC_if.jpg" alt="img"></p>
<p>通过判断某个输出的状态进行一些动作，如果进行单一动作，还可以用以下的异或电路实现</p>
<p><img src="https://zhuom-go.github.io/img/PLC/yhdl.jpg" alt="img"></p>
<h3 id="4、西门子内存数据结构"><a href="#4、西门子内存数据结构" class="headerlink" title="4、西门子内存数据结构"></a>4、西门子内存数据结构</h3><p><img src="https://zhuom-go.github.io/img/PLC/neicun.jpg" alt="img"></p>
<p>1、西门子的<strong>字节存放是由左往右排的</strong>，和普通的相反；</p>
<p>2、<strong>西门子的位在某个字节中又是从右往左排的</strong>；</p>
<p>3、<strong>在一个双字里面，高位是IW0，低位是IW2，而不是IW1；</strong></p>
<h3 id="5、西门子的字符格式"><a href="#5、西门子的字符格式" class="headerlink" title="5、西门子的字符格式"></a>5、西门子的字符格式</h3><p><img src="https://zhuom-go.github.io/img/PLC/%E5%AD%97%E7%AC%A6%E6%A0%BC%E5%BC%8F.jpg" alt="img"></p>
<h3 id="6、子程序使用时的注意事项"><a href="#6、子程序使用时的注意事项" class="headerlink" title="6、子程序使用时的注意事项"></a>6、子程序使用时的注意事项</h3><p>1、在使用子程序时，当不进入子程序后，<strong>子程序里面的状态会保存原样</strong>，不会像主程序那样扫描后复位，所以在使用时，需要注意正常断开时，内部的输出是不是断开和定时器等是否断开，因为他们不会随着子程序的断开而断开。</p>
<p>2、中断时<strong>一个事件只能对应一个程序块</strong>，一个程序块可以对应多个中断事件</p>
<p>3、断开硬件中断时，是直接断开中断事件的，具体中断事件与那个块连接无所谓，都会断开。例如事件1连接到块1，实际使用时是断开事件1与块2，这样事件1与块1也会断开。</p>
<h3 id="7、通讯的注意事项"><a href="#7、通讯的注意事项" class="headerlink" title="7、通讯的注意事项"></a>7、通讯的注意事项</h3><p>1、一般手册给出的地址是16进制的，而西门子是十进制的，所以在进行地址换算时，需要把它转换成十进制，并由于十进制的保持型寄存器是从40001开始，所以转换完后还要加上40001.例如手册的通讯地址为<code>3000H</code>，则西门子的设定地址为：<code>12288(3000H)+400001=412289</code></p>
<p>2、如果是使用485两线制的<code>modbus</code>，需要在初始化时，把初始化指令的<code>MODE</code>设为4.</p>
<p>3、在进行PLC的<code>modbus</code>通信时，从站一般分配<code>P#M100.0 WORD 100</code>，表示从M100.0开始建立100个字的<code>ModBus</code>缓冲区，主站的读取地址为<code>400001</code>开始</p>
<p>4、对于不同的<code>modbus</code>通信地址如下图所示，前面的地址为位的状态，因此主站的<code>DATA_PTR</code>应该也设置为位，例如地址<code>DATA_ADDR</code>设为1，则表示<code>Q0.0</code>，此时通信的存储位置<code>DATA_PTR</code>应设置为<code>M3.0</code>。</p>
<p><img src="https://zhuom-go.github.io/img/PLC/PLC%E4%BB%8E%E7%AB%99%E5%9C%B0%E5%9D%80.jpg" alt="0"></p>
<p>5、主站读取从站的报文格式</p>
<p>写的功能码是06H，读的功能码是03H</p>
<p><img src="https://zhuom-go.github.io/img/PLC/%E5%86%99%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg" alt="0"></p>
<p><img src="https://zhuom-go.github.io/img/PLC/%E8%AF%BB%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg" alt="0"></p>
<p><img src="https://zhuom-go.github.io/img/PLC/%E5%8A%9F%E8%83%BD%E7%A0%81.jpg" alt="0"></p>
<p>6、CRC验证码转换方式</p>
<p><img src="https://zhuom-go.github.io/img/PLC/CRC%E6%A3%80%E9%AA%8C%E7%A0%81%E8%BD%AC%E6%8D%A2.jpg" alt="0"></p>
<p>7、PLC之间的报文发送之间发什么，从站就接受什么，不需要设置报文格式</p>
<p>8、TCP通信设置</p>
<p><img src="https://zhuom-go.github.io/img/PLC/TCP%E9%80%9A%E4%BF%A1%E5%8F%82%E6%95%B0.jpg" alt="0"></p>
<p>9、<code>USS</code>通信时，控制字<code>PZD</code>的长度一般设置为2,参数区<code>PKW</code>的长度为4</p>
<p><img src="https://zhuom-go.github.io/img/PLC/USS%E9%80%9A%E4%BF%A1%E8%AE%BE%E7%BD%AE.jpg" alt="0"></p>
]]></content>
      <categories>
        <category>PLC</category>
        <category>注意事项</category>
      </categories>
      <tags>
        <tag>PLC</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++</title>
    <url>/2021/03/04/Effective%20Modern%20C++/</url>
    <content><![CDATA[<h3 id="1、型别推导"><a href="#1、型别推导" class="headerlink" title="1、型别推导"></a>1、型别推导</h3><h4 id="条款1-理解模型推导"><a href="#条款1-理解模型推导" class="headerlink" title="条款1.理解模型推导"></a>条款1.理解模型推导</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(expr);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于上述代码模式的说明</p>
</blockquote>
<p><strong>1、ParamType是指针或引用时（非万能引用）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">27</span>;                  <span class="comment">//x是int类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx=x;            <span class="comment">//cx是const int类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx=x            <span class="comment">//rx是const int的引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ptr=<span class="string">&quot;ssss&quot;</span>;</span><br><span class="line">  </span><br><span class="line">f(x);  <span class="comment">//x是int类型，所以推断出来T为int </span></span><br><span class="line">f(cx);  <span class="comment">//cx是const int类型，所以T是const int</span></span><br><span class="line">f(rx);  <span class="comment">//rx是const int&amp;类型,但是在进行类型推断时会忽略形参的引用类型，所以实际T推断推来还是const int</span></span><br><span class="line">f(ptr); <span class="comment">//则会被推断为const char(&amp;)[5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当把换成</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line"><span class="comment">//会推断出和以前上面一样的结果，x直接为int 所以T也为int,后面两个由于已经带了const，所以会被忽略</span></span><br></pre></td></tr></table></figure>

<p><strong>2、ParamType是万能模板时</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">27</span>;                  <span class="comment">//x是int类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx=x;            <span class="comment">//cx是const int类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx=x            <span class="comment">//rx是const int的引用</span></span><br><span class="line">  </span><br><span class="line">f(x);  <span class="comment">//x是左值，所以T是int &amp;类型，对于param最终还是int &amp;</span></span><br><span class="line">f(cx);  <span class="comment">//同上</span></span><br><span class="line">f(rx);  <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">27</span>);<span class="comment">//则为右值</span></span><br></pre></td></tr></table></figure>

<p><strong>3、ParamType即非指针也非引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*按值传递*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x=<span class="number">27</span>;                  <span class="comment">//x是int类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx=x;            <span class="comment">//cx是const int类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx=x            <span class="comment">//rx是const int的引用</span></span><br><span class="line">  </span><br><span class="line">f(x);  <span class="comment">//x是按值传递的，所以T推断出来的还是int</span></span><br><span class="line">f(cx);  <span class="comment">//由于此时是按值传递的，是新建了一个新的对象，默认与原对象无关，所以会忽略const，此时还是int类型</span></span><br><span class="line">f(rx);  <span class="comment">//同上，忽略const和左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要注意的是如果传进去的</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*<span class="keyword">const</span> ptr=<span class="string">&quot;sss&quot;</span>;</span><br><span class="line"><span class="comment">//则T会被推导为const char *类型，自身的常量性被忽略，与上述规则一样</span></span><br><span class="line"><span class="comment">//所以当类型为const char* ptr时，其推断T也为const char *，只忽略值本身的const</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结</p>
</blockquote>
<p><strong>1、在模板类型中，具有引用型的实参应用将会被忽略</strong></p>
<p>2、对于万能引用的实参，左值会特殊推导</p>
<p>3、按值传递时，值本身的<code>const</code>会被忽略</p>
<p>4、在模板推导时，数组或者函数会退化成指针</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>Effective Modern C++</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生小知识</title>
    <url>/2021/03/02/%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="1、二维坐标变换"><a href="#1、二维坐标变换" class="headerlink" title="1、二维坐标变换"></a>1、二维坐标变换</h3><p>假设坐标系<code>XOY</code>经过旋转后的坐标系为<code>X&#39;OY&#39;</code>,旋转角为<code>θ</code>,如图所示，则<a id="more"></a></p>
<p><img src="https://zhuom-go.github.io/img/%E6%97%8B%E8%BD%AC%E6%97%B6%E7%9A%84%E5%9B%BE%E7%89%87/XY%E6%97%8B%E8%BD%AC.png" alt="img"></p>
<p>$$x’=x<em>cos(θ)+y</em>sin(θ)$$<br>$$y’=y<em>cos(θ)-x</em>sin(θ)$$</p>
<h3 id="2、三维坐标变换"><a href="#2、三维坐标变换" class="headerlink" title="2、三维坐标变换"></a>2、三维坐标变换</h3><h4 id="2-1、绕X轴旋转"><a href="#2-1、绕X轴旋转" class="headerlink" title="2.1、绕X轴旋转"></a>2.1、绕X轴旋转</h4><p>在三维场景中，当一个点P(x,y,z)绕x轴旋转θ角得到点P’(x’,y’,z’)。由于是绕x轴进行的旋转，因此x坐标保持不变，y和z组成的yoz（o是坐标原点）平面上进行的是一个二维的旋转，于是有：</p>
<p><strong>右手坐标系：</strong></p>
<p><img src="https://zhuom-go.github.io/img/%E6%97%8B%E8%BD%AC%E6%97%B6%E7%9A%84%E5%9B%BE%E7%89%87/X%E5%8F%B3.png" alt="img"></p>
<p><strong>左手坐标系：</strong></p>
<p><img src="https://zhuom-go.github.io/img/%E6%97%8B%E8%BD%AC%E6%97%B6%E7%9A%84%E5%9B%BE%E7%89%87/X%E5%B7%A6.png" alt="img"></p>
<h4 id="2-2、绕Y轴旋转"><a href="#2-2、绕Y轴旋转" class="headerlink" title="2.2、绕Y轴旋转"></a>2.2、绕Y轴旋转</h4><p>在三维场景中，当一个点P(x,y,z)绕y轴旋转θ角得到点P’(x’,y’,z’)。由于是绕x轴进行的旋转，因此y坐标保持不变，x和z组成的xoz（o是坐标原点）平面上进行的是一个二维的旋转，于是有：</p>
<p><strong>右手坐标系：</strong></p>
<p><img src="https://zhuom-go.github.io/img/%E6%97%8B%E8%BD%AC%E6%97%B6%E7%9A%84%E5%9B%BE%E7%89%87/Y%E5%8F%B3.png" alt="img"></p>
<p><strong>左手坐标系：</strong></p>
<p><img src="https://zhuom-go.github.io/img/%E6%97%8B%E8%BD%AC%E6%97%B6%E7%9A%84%E5%9B%BE%E7%89%87/Y%E5%B7%A6.png" alt="img"></p>
<h4 id="2-3、绕Z轴旋转"><a href="#2-3、绕Z轴旋转" class="headerlink" title="2.3、绕Z轴旋转"></a>2.3、绕Z轴旋转</h4><p>在三维场景中，当一个点P(x,y,z)绕z轴旋转θ角得到点P’(x’,y’,z’)。由于是绕z轴进行的旋转，因此z坐标保持不变，x和y组成的xoy（o是坐标原点）平面上进行的是一个二维的旋转，于是有：</p>
<p><strong>右手坐标系：</strong></p>
<p><img src="https://zhuom-go.github.io/img/%E6%97%8B%E8%BD%AC%E6%97%B6%E7%9A%84%E5%9B%BE%E7%89%87/Z%E5%8F%B3.png" alt="img"></p>
<p><strong>左手坐标系：</strong></p>
<p><img src="https://zhuom-go.github.io/img/%E6%97%8B%E8%BD%AC%E6%97%B6%E7%9A%84%E5%9B%BE%E7%89%87/Z%E5%B7%A6.png" alt="img"></p>
]]></content>
      <categories>
        <category>数学小知识</category>
        <category>坐标轴旋转变化</category>
      </categories>
      <tags>
        <tag>旋转变化</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt常用控件</title>
    <url>/2020/11/27/Qt%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="1、SpinBox"><a href="#1、SpinBox" class="headerlink" title="1、SpinBox"></a>1、SpinBox</h3><a id="more"></a>

<blockquote>
<p><strong>继承于QAbstractSpinBox,主要属性</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>prefix</code></td>
<td>数字显示的前缀，例如<code>$$</code></td>
</tr>
<tr>
<td><code>suffix</code></td>
<td>数字显示的后缀，例如<code>kg</code></td>
</tr>
<tr>
<td><code>minimum</code></td>
<td>数值显示的最小值</td>
</tr>
<tr>
<td><code>maximun</code></td>
<td>数值显示的最大值</td>
</tr>
<tr>
<td><code>singlestep</code></td>
<td>单击调整按钮时，改变的步长</td>
</tr>
<tr>
<td><code>value</code></td>
<td>当前的值</td>
</tr>
<tr>
<td><code>displayIntegerBase</code></td>
<td><code>QSpinBox</code>独有，设置显示的进制</td>
</tr>
<tr>
<td><code>decimals</code></td>
<td><code>QDoubleSpinBox</code>独有，设置显示的小数位</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>前缀和后缀设置后并不会改变</p>
<h3 id="2、其它输入和显示组件"><a href="#2、其它输入和显示组件" class="headerlink" title="2、其它输入和显示组件"></a>2、其它输入和显示组件</h3><h4 id="2-1、QSlider"><a href="#2-1、QSlider" class="headerlink" title="2.1、QSlider"></a>2.1、QSlider</h4><blockquote>
<p><strong><code>QSlider、QScrollBar和Qdial</code>都继承于<code>QAbstractSlider，主要特性有：</code></strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>minimun\maximun</code></td>
<td>设置输入范围的最大值和最小值</td>
</tr>
<tr>
<td><code>singleStep</code></td>
<td>单步长，当拖动标尺上的滑块时，变化的最小值</td>
</tr>
<tr>
<td><code>pageStep</code></td>
<td>在<code>Slider</code>上输入焦点，按下<code>PageUp</code>或者<code>PageDn</code>时变化的数值</td>
</tr>
<tr>
<td><code>value</code></td>
<td>组件当前的值</td>
</tr>
<tr>
<td><code>sliderPosition</code></td>
<td>滑块的位置，若``tracking<code>为</code>true<code>，该值和</code>value`相等</td>
</tr>
<tr>
<td><code>tracking</code></td>
<td>设置<code>sliderPosition</code>和value是否相等</td>
</tr>
<tr>
<td><code>orientation</code></td>
<td>设置<code>Slider</code>的方向，<code>Qt::Horizontal</code>为水平方向，<code>Qt::Vertical</code>为垂直方向</td>
</tr>
<tr>
<td><code>invertedAppearance</code></td>
<td>显示是否反方向，false时，往左滑动增大</td>
</tr>
<tr>
<td><code>invertedControls</code></td>
<td>控制键是否反方向，true时，<code>PgUp</code>反而变小</td>
</tr>
<tr>
<td><code>tickPosition</code></td>
<td>标尺刻度显示位置，<br /><code>QSlider::NoTick</code>     不显示刻度 <br /><code>QSlider::TicksBothSides</code>  在两侧显示刻度 <br /><code>QSlider::TicksAbove</code>     上面显示刻度 <br /><code>QSlider::TicksBelow</code>     下面显示刻度 <br /><code>QSlider::TicksLeft</code>      左边显示刻度 <br /><code>QSlider::TicksRight</code>     右边显示刻度</td>
</tr>
<tr>
<td><code>tickInterval</code></td>
<td>标尺的间隔值</td>
</tr>
</tbody></table>
<h4 id="2-2、QScrollBar"><a href="#2-2、QScrollBar" class="headerlink" title="2.2、QScrollBar"></a>2.2、QScrollBar</h4><p>继承于<code>QAbstractSlider</code>，无特殊情况</p>
<h4 id="2-3、QDial"><a href="#2-3、QDial" class="headerlink" title="2.3、QDial"></a>2.3、QDial</h4><p>该器件是仪表盘组件，除以上外还有特有属性：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>notchesVisibel</code></td>
<td>表盘小刻度是否可见</td>
</tr>
<tr>
<td><code>notchTarget</code></td>
<td>表盘刻度的像素值</td>
</tr>
</tbody></table>
<h4 id="2-4、QprogressBar"><a href="#2-4、QprogressBar" class="headerlink" title="2.4、QprogressBar"></a>2.4、QprogressBar</h4><p>继承于<code>QWidget,</code>,常用属性有</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>minimun\maximun</code></td>
<td>设置输入范围的最大值和最小值</td>
</tr>
<tr>
<td><code>value</code></td>
<td>组件当前的值</td>
</tr>
<tr>
<td><code>textVisible</code></td>
<td>是否显示文字，一般显示百分比</td>
</tr>
<tr>
<td><code>orientation</code></td>
<td>设置水平或垂直</td>
</tr>
<tr>
<td><code>format</code></td>
<td>设值文字的显示格式，<code>%p%  显示百分比      %v显示当前值   %m显示总步数</code></td>
</tr>
</tbody></table>
<h4 id="2-5、QLCDNumber"><a href="#2-5、QLCDNumber" class="headerlink" title="2.5、QLCDNumber"></a>2.5、QLCDNumber</h4><p>LCD显示组件，可以设置显示的常用函数</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>digitCount</code></td>
<td>显示的位数，<strong>如果开了小数显示，注意小数点也算一位</strong></td>
</tr>
<tr>
<td><code>smallDecimalPoint</code></td>
<td>是否有小数点，如果有小数点，就可以显示小数</td>
</tr>
<tr>
<td><code>mode:setDecmode(),setBinmode(),setOctMode,setHexMode()</code></td>
<td>设置进制</td>
</tr>
<tr>
<td><code>value</code></td>
<td>显示的值，如果<code>smallDecimalPoint</code>为真才可设置小数</td>
</tr>
<tr>
<td><code>intValue</code></td>
<td>返回显示的整数部分</td>
</tr>
<tr>
<td><code>display</code></td>
<td>设置显示的值</td>
</tr>
</tbody></table>
<h3 id="3、时间日期显示组件"><a href="#3、时间日期显示组件" class="headerlink" title="3、时间日期显示组件"></a>3、时间日期显示组件</h3><h4 id="QTimeEdit、QDateEdit、QDateTimeEdit和QCalendarWidget"><a href="#QTimeEdit、QDateEdit、QDateTimeEdit和QCalendarWidget" class="headerlink" title="QTimeEdit、QDateEdit、QDateTimeEdit和QCalendarWidget"></a>QTimeEdit、QDateEdit、QDateTimeEdit和QCalendarWidget</h4><p>显示时间的组件，显示日期的组件和显示时间和日期的组件</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>datetime</code></td>
<td>日期时间</td>
</tr>
<tr>
<td><code>date</code></td>
<td>日期</td>
</tr>
<tr>
<td><code>time</code></td>
<td>时间</td>
</tr>
<tr>
<td><code>maximunDateTime</code>和<code>minimumDateTime</code></td>
<td>最大、最小日期时间</td>
</tr>
<tr>
<td><code>maximunDate</code>和``minimumDate`</td>
<td>最大、最小日期</td>
</tr>
<tr>
<td><code>maximunTime</code>和<code>minimumTime</code></td>
<td>最大、最小时间</td>
</tr>
<tr>
<td><code>currentSection</code></td>
<td>当前输入光标所在的段，他把dateTime分成几个段，如QDateTimeEdit::YearSection，表示年段</td>
</tr>
<tr>
<td><code>currentSectionIndex</code></td>
<td>用序号表示段</td>
</tr>
<tr>
<td><code>calendarPopup</code></td>
<td>是否弹出日历选择框，是的时候将会产生类似于<code>QComboxBox</code>的下拉框，选择日期</td>
</tr>
<tr>
<td><code>displayFormat</code></td>
<td>显示的格式</td>
</tr>
<tr>
<td><code>QdateTime::currentDateTime</code></td>
<td>获得当前时间</td>
</tr>
<tr>
<td><code>QdateTime::fromString</code></td>
<td>把时间转换成字符</td>
</tr>
</tbody></table>
<h3 id="4、QComboBox"><a href="#4、QComboBox" class="headerlink" title="4、QComboBox"></a>4、QComboBox</h3><p>其除了可以插入每个项外，每个项还可以关联看不见的数据，常用函数如下所示</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>addItem</code></td>
<td>添加项目，其可以<code>addItem(&quot;zhuo&quot;,20)</code>，其中“zhuo”是看得到的项目，20是绑定<code>zhuo</code>的值，类似于<code>pair</code></td>
</tr>
<tr>
<td><code>currentIndex</code></td>
<td>当前项的序号</td>
</tr>
<tr>
<td><code>currentText</code></td>
<td>当前项的文字</td>
</tr>
<tr>
<td><code>currentData</code></td>
<td>当前项的绑定数据</td>
</tr>
<tr>
<td><code>itemText</code></td>
<td>返回项的名字</td>
</tr>
<tr>
<td><code>itemData</code></td>
<td>返回项的绑定数据</td>
</tr>
<tr>
<td><code>int count</code></td>
<td>返回项的个数</td>
</tr>
<tr>
<td>QCompleter(list,this)</td>
<td>当把<code>QCombox</code>设置<code>QLindeEdit</code>形式时，可以利用该函数提醒，<code>list</code>为提醒的内容，<code>setCaseSensitivity</code>可以设置大小写不敏感</td>
</tr>
</tbody></table>
<h3 id="5、QPlainTextEdit"><a href="#5、QPlainTextEdit" class="headerlink" title="5、QPlainTextEdit"></a>5、QPlainTextEdit</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString str=ui-&gt;plainTextEdit-&gt;tostring();  <span class="comment">//可以获得全部的文本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPlainTextEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextBlock&gt;</span></span></span><br><span class="line"><span class="comment">//获得每一行的文本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTextDocument *document=ui-&gt;plainTextEdit-&gt;document();   <span class="comment">//获得文件</span></span><br><span class="line">    <span class="keyword">int</span> line=document-&gt;blockCount();  <span class="comment">//确定行数</span></span><br><span class="line">    ui-&gt;textEdit-&gt;clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;line;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       QTextBlock linestr= document-&gt;findBlockByNumber(i);     <span class="comment">//查找每一行，并把行转换为String</span></span><br><span class="line">       ui-&gt;textEdit-&gt;append(linestr.text());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、QlistWidget"><a href="#6、QlistWidget" class="headerlink" title="6、QlistWidget"></a>6、QlistWidget</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_2_clicked</span><span class="params">()</span>  <span class="comment">//插入项，并可以设置项的属性</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows=ui-&gt;listWidget-&gt;count();</span><br><span class="line">    QListWidgetItem *item=<span class="keyword">new</span> QListWidgetItem(QString(<span class="string">&quot;第%1行&quot;</span>).arg(rows));</span><br><span class="line">    item-&gt;setFlags(Qt::ItemIsSelectable |Qt::ItemIsDragEnabled |Qt::ItemIsDropEnabled |Qt::ItemIsEditable);</span><br><span class="line">    ui-&gt;listWidget-&gt;addItem(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_3_clicked</span><span class="params">()</span>  <span class="comment">//遍历项</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows=ui-&gt;listWidget-&gt;count();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)</span><br><span class="line">        qDebug()&lt;&lt;ui-&gt;listWidget-&gt;item(i)-&gt;text();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_4_clicked</span><span class="params">()</span>  <span class="comment">//删除项时，takeItem只是移出，delete后才是删除</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows=ui-&gt;listWidget-&gt;count();</span><br><span class="line">    QListWidgetItem *i=ui-&gt;listWidget-&gt;takeItem(rows<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">delete</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、QToolButton"><a href="#7、QToolButton" class="headerlink" title="7、QToolButton"></a>7、QToolButton</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QMenu *menu=<span class="keyword">new</span> QMenu();           <span class="comment">//创建菜单</span></span><br><span class="line">menu-&gt;addAction(ui-&gt;actCopy);      <span class="comment">//加入action</span></span><br><span class="line">menu-&gt;addAction(ui-&gt;actCut);</span><br><span class="line">menu-&gt;addAction(ui-&gt;actNew);</span><br><span class="line"><span class="comment">//设置ToolButton的模式，InstantPopup的话点击按钮弹出下拉框，不会执行默认的action,MenuButtonPopup点击按钮则会执行</span></span><br><span class="line">ui-&gt;toolButton-&gt;setPopupMode(QToolButton::InstantPopup);  </span><br><span class="line"><span class="comment">//设置按钮的样式</span></span><br><span class="line">ui-&gt;toolButton-&gt;setToolButtonStyle(Qt::ToolButtonStyle::ToolButtonTextBesideIcon);</span><br><span class="line"><span class="comment">//设置默认的action</span></span><br><span class="line">ui-&gt;toolButton-&gt;setDefaultAction(ui-&gt;actBold);</span><br><span class="line"><span class="comment">//加入菜单</span></span><br><span class="line">ui-&gt;toolButton-&gt;setMenu(menu);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8、QTreeWidget"><a href="#8、QTreeWidget" class="headerlink" title="8、QTreeWidget"></a>8、QTreeWidget</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    Init_UI();</span><br><span class="line">    connect(ui-&gt;treeWidget,&amp;QTreeWidget::itemClicked,<span class="keyword">this</span>,[=](QTreeWidgetItem *item)&#123;</span><br><span class="line">       <span class="comment">//qDebug()&lt;&lt;item-&gt;data(0,Qt::UserRole).toString();  查询data的值</span></span><br><span class="line">       <span class="comment">// int itemType=item-&gt;type(); 这个可以用来判断你点击的是哪个item，type的值就是你一开始new的时候写进去的值</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//删除item时，要先获得parent，然后调用remove，但是只是移除而已，需要手动删除</span></span><br><span class="line">        <span class="keyword">auto</span> parent=item-&gt;parent();</span><br><span class="line">        parent-&gt;removeChild(item);</span><br><span class="line">        <span class="keyword">delete</span> item;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::Init_UI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ui-&gt;treeWidget-&gt;headerItem()-&gt;setText(0,&quot;1&quot;);         该方法也可以加入列名称</span></span><br><span class="line">    <span class="comment">/*ui-&gt;treeWidget-&gt;headerItem()-&gt;setText(1,&quot;2&quot;);</span></span><br><span class="line"><span class="comment">    ui-&gt;treeWidget-&gt;headerItem()-&gt;setText(2,&quot;3&quot;);*/</span></span><br><span class="line">    QStringList strlist;</span><br><span class="line">    strlist&lt;&lt;<span class="string">&quot; 1 &quot;</span>&lt;&lt;<span class="string">&quot; 2 &quot;</span>&lt;&lt;<span class="string">&quot; 3 &quot;</span>;</span><br><span class="line">    ui-&gt;treeWidget-&gt;setHeaderLabels(strlist);    <span class="comment">//加入列的名称</span></span><br><span class="line">  </span><br><span class="line">    QTreeWidgetItem *item21=<span class="keyword">new</span> QTreeWidgetItem(<span class="number">1</span>);<span class="comment">//建议这样new，后面要判断时可以用type来判断点击是哪一个</span></span><br><span class="line">    item21-&gt;setText(<span class="number">0</span>,<span class="string">&quot;1&quot;</span>);<span class="comment">//设置名称</span></span><br><span class="line">    item21-&gt;setCheckState(<span class="number">0</span>,Qt::CheckState::Unchecked);<span class="comment">//设置复选框为未选中状态</span></span><br><span class="line">    item21-&gt;setFlags(Qt::ItemFlag::ItemIsEnabled | Qt::ItemFlag::ItemIsUserCheckable | Qt::ItemFlag::ItemIsSelectable);</span><br><span class="line">    ui-&gt;treeWidget-&gt;addTopLevelItem(item21);  <span class="comment">//加入到顶层item</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QTreeWidgetItem *item2=<span class="keyword">new</span> QTreeWidgetItem(<span class="number">11</span>);</span><br><span class="line">    item2-&gt;setText(<span class="number">0</span>,<span class="string">&quot;1_1&quot;</span>);</span><br><span class="line">    item2-&gt;setCheckState(<span class="number">0</span>,Qt::CheckState::Unchecked);</span><br><span class="line">    item2-&gt;setFlags(Qt::ItemFlag::ItemIsEnabled | Qt::ItemFlag::ItemIsUserCheckable | Qt::ItemFlag::ItemIsSelectable);</span><br><span class="line">    ui-&gt;treeWidget-&gt;itemAt(<span class="number">0</span>,<span class="number">0</span>)-&gt;addChild(item2);   <span class="comment">//加入到顶层item的子目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QTreeWidgetItem *item3=<span class="keyword">new</span> QTreeWidgetItem(<span class="number">111</span>);</span><br><span class="line">    item3-&gt;setText(<span class="number">0</span>,<span class="string">&quot;1_1_1&quot;</span>);</span><br><span class="line">    item3-&gt;setCheckState(<span class="number">0</span>,Qt::CheckState::Unchecked);</span><br><span class="line">    item3-&gt;setFlags(Qt::ItemFlag::ItemIsEnabled | Qt::ItemFlag::ItemIsUserCheckable | Qt::ItemFlag::ItemIsSelectable);</span><br><span class="line">    item3-&gt;setData(<span class="number">0</span>,Qt::UserRole,<span class="string">&quot;5666&quot;</span>);  <span class="comment">//对该节点另外绑定一个值，当值看不见，需要时可以用data来查询</span></span><br><span class="line">    ui-&gt;treeWidget-&gt;itemAt(<span class="number">0</span>,<span class="number">0</span>)-&gt;child(<span class="number">0</span>)-&gt;addChild(item3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    QTreeWidgetItem *item4=<span class="keyword">new</span> QTreeWidgetItem(<span class="number">112</span>);</span><br><span class="line">    item4-&gt;setText(<span class="number">0</span>,<span class="string">&quot;1_1_2&quot;</span>);</span><br><span class="line">    item4-&gt;setCheckState(<span class="number">0</span>,Qt::CheckState::Unchecked);</span><br><span class="line">    item4-&gt;setFlags(Qt::ItemFlag::ItemIsEnabled | Qt::ItemFlag::ItemIsUserCheckable | Qt::ItemFlag::ItemIsSelectable);</span><br><span class="line">    ui-&gt;treeWidget-&gt;itemAt(<span class="number">0</span>,<span class="number">0</span>)-&gt;child(<span class="number">0</span>)-&gt;addChild(item4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ui-&gt;treeWidget-&gt;topLevelItemCount();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        change_item(ui-&gt;treeWidget-&gt;topLevelItem(i));  <span class="comment">//遍历每一列</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::change_item</span><span class="params">(QTreeWidgetItem *item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iCount=item-&gt;childCount();</span><br><span class="line">    item-&gt;setText(<span class="number">0</span>,item-&gt;text(<span class="number">0</span>)+<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(iCount&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;iCount;i++)</span><br><span class="line">            change_item(item-&gt;child(i));  <span class="comment">//递归遍历每一颗树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9、QTableWidget"><a href="#9、QTableWidget" class="headerlink" title="9、QTableWidget"></a>9、QTableWidget</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTableWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QTableWidgetItem *head;</span><br><span class="line">    QStringList <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;&lt;&quot;姓 名&quot;&lt;&lt;&quot;年龄&quot;&lt;&lt;&quot;是否党员&quot;;</span><br><span class="line">    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(<span class="built_in">list</span>);</span><br><span class="line">    ui-&gt;tableWidget-&gt;setColumnCount(<span class="built_in">list</span>.count());  <span class="comment">//设置列的数量，必须设置，否则不显示表头</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ui-&gt;tableWidget-&gt;columnCount();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        head=<span class="keyword">new</span> QTableWidgetItem(<span class="built_in">list</span>.at(i));</span><br><span class="line">        QFont font;</span><br><span class="line">        font.setBold(<span class="literal">true</span>);</span><br><span class="line">        font.setPointSize(<span class="number">12</span>);</span><br><span class="line">        head-&gt;setFont(font);</span><br><span class="line">        head-&gt;setTextColor(QColor(i*<span class="number">30</span>,i*<span class="number">5</span>,i*<span class="number">70</span>));</span><br><span class="line">        ui-&gt;tableWidget-&gt;setHorizontalHeaderItem(i,head);  <span class="comment">//设置行的样式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;tableWidget-&gt;setRowCount(ui-&gt;spinBox-&gt;text().toInt());  <span class="comment">//设置行的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_3_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;tableWidget-&gt;clearContents();<span class="comment">//清除工作的内容，不清除表头</span></span><br><span class="line">    ui-&gt;tableWidget-&gt;setRowCount(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QTableWidgetItem *item=<span class="keyword">new</span> QTableWidgetItem(QString(<span class="string">&quot;李%1&quot;</span>).arg(i+<span class="number">1</span>),ID);</span><br><span class="line">        item-&gt;setData(Qt::UserRole,QVariant(<span class="number">2017</span>+i));</span><br><span class="line">        ui-&gt;tableWidget-&gt;setItem(i,<span class="number">0</span>,item);</span><br><span class="line">        item=<span class="keyword">new</span> QTableWidgetItem(QString(<span class="string">&quot;%1&quot;</span>).arg(i+<span class="number">20</span>),AGE);</span><br><span class="line">        ui-&gt;tableWidget-&gt;setItem(i,<span class="number">1</span>,item);</span><br><span class="line">        item=<span class="keyword">new</span> QTableWidgetItem(<span class="string">&quot;党员&quot;</span>,TK);</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>)</span><br><span class="line">            item-&gt;setCheckState(Qt::Checked);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            item-&gt;setCheckState(Qt::Unchecked);</span><br><span class="line">        ui-&gt;tableWidget-&gt;setItem(i,<span class="number">2</span>,item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_4_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row=ui-&gt;tableWidget-&gt;currentRow()+<span class="number">1</span>;</span><br><span class="line">    ui-&gt;tableWidget-&gt;insertRow(row);</span><br><span class="line">    QTableWidgetItem *item=<span class="keyword">new</span> QTableWidgetItem(QString(<span class="string">&quot;李%1&quot;</span>).arg(row+<span class="number">1</span>));</span><br><span class="line">    ui-&gt;tableWidget-&gt;setItem(row,<span class="number">0</span>,item);</span><br><span class="line">    item=<span class="keyword">new</span> QTableWidgetItem(QString(<span class="string">&quot;%1&quot;</span>).arg(row+<span class="number">20</span>));</span><br><span class="line">    ui-&gt;tableWidget-&gt;setItem(row,<span class="number">1</span>,item);</span><br><span class="line">    item=<span class="keyword">new</span> QTableWidgetItem(<span class="string">&quot;党员&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(row%<span class="number">2</span>)</span><br><span class="line">        item-&gt;setCheckState(Qt::Checked);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        item-&gt;setCheckState(Qt::Unchecked);</span><br><span class="line">    ui-&gt;tableWidget-&gt;setItem(row,<span class="number">2</span>,item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_6_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row=ui-&gt;tableWidget-&gt;rowCount();</span><br><span class="line">    ui-&gt;tableWidget-&gt;insertRow(row);</span><br><span class="line">    QTableWidgetItem *item=<span class="keyword">new</span> QTableWidgetItem(QString(<span class="string">&quot;李%1&quot;</span>).arg(row+<span class="number">1</span>),ID);<span class="comment">//设置每个数据的类型，方便后面的查找</span></span><br><span class="line">    item-&gt;setData(Qt::UserRole,QVariant(<span class="number">110022</span>));  <span class="comment">//数据绑定另一个数值，可以直接查看</span></span><br><span class="line">    ui-&gt;tableWidget-&gt;setItem(row,<span class="number">0</span>,item);</span><br><span class="line">    item=<span class="keyword">new</span> QTableWidgetItem(QString(<span class="string">&quot;%1&quot;</span>).arg(row+<span class="number">20</span>),AGE);</span><br><span class="line">    ui-&gt;tableWidget-&gt;setItem(row,<span class="number">1</span>,item);</span><br><span class="line">    item=<span class="keyword">new</span> QTableWidgetItem(<span class="string">&quot;党员&quot;</span>,TK);</span><br><span class="line">    <span class="keyword">if</span>(row%<span class="number">2</span>)</span><br><span class="line">        item-&gt;setCheckState(Qt::Checked);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        item-&gt;setCheckState(Qt::Unchecked);</span><br><span class="line">    ui-&gt;tableWidget-&gt;setItem(row,<span class="number">2</span>,item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_5_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row=ui-&gt;tableWidget-&gt;currentRow();</span><br><span class="line">    ui-&gt;tableWidget-&gt;removeRow(row);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_8_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;tableWidget-&gt;resizeRowsToContents();<span class="comment">//行自动适应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_9_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;tableWidget-&gt;resizeColumnsToContents();<span class="comment">//列自动适应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_pushButton_7_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;plainTextEdit-&gt;clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ui-&gt;tableWidget-&gt;rowCount();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QString str=QString(<span class="string">&quot;%1&quot;</span>).arg(i)+<span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ui-&gt;tableWidget-&gt;columnCount();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            QTableWidgetItem *item=ui-&gt;tableWidget-&gt;item(i,j);</span><br><span class="line">            <span class="keyword">if</span>(item-&gt;type()==ID)</span><br><span class="line">                str+=(item-&gt;text()+<span class="string">&quot;  &quot;</span>)+item-&gt;data(Qt::UserRole).toString();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (item-&gt;type()==TK) &#123;</span><br><span class="line">                <span class="keyword">if</span>(item-&gt;checkState()==Qt::Checked)</span><br><span class="line">                str+=<span class="string">&quot;是&quot;</span>+(item-&gt;text()+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    str+=<span class="string">&quot;不是&quot;</span>+(item-&gt;text()+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                str+=(item-&gt;text()+<span class="string">&quot;  &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        str+=<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        ui-&gt;plainTextEdit-&gt;appendPlainText(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_checkBox_stateChanged</span><span class="params">(<span class="keyword">int</span> arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg1==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::DoubleClicked |QAbstractItemView::SelectedClicked);<span class="comment">//设置表格可编辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ui-&gt;tableWidget-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_checkBox_2_stateChanged</span><span class="params">(<span class="keyword">int</span> arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg1==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;tableWidget-&gt;setAlternatingRowColors(<span class="literal">true</span>);<span class="comment">//设置行间隔颜色表示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ui-&gt;tableWidget-&gt;setAlternatingRowColors(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_checkBox_6_stateChanged</span><span class="params">(<span class="keyword">int</span> arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg1==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setVisible(<span class="literal">true</span>); <span class="comment">//设置列表头可见</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       ui-&gt;tableWidget-&gt;horizontalHeader()-&gt;setVisible(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_checkBox_5_stateChanged</span><span class="params">(<span class="keyword">int</span> arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg1==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setVisible(<span class="literal">true</span>);<span class="comment">//设置行表头可见</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       ui-&gt;tableWidget-&gt;verticalHeader()-&gt;setVisible(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_radioButton_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;tableWidget-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);  <span class="comment">//设置选中时是行选中，还是单元格选中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_radioButton_2_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;tableWidget-&gt;setSelectionBehavior(QAbstractItemView::SelectItems);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10、QMainWindows"><a href="#10、QMainWindows" class="headerlink" title="10、QMainWindows"></a>10、QMainWindows</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//菜单栏</span></span><br><span class="line">QMenuBar *mBar=menuBar();<span class="comment">//获取菜单栏</span></span><br><span class="line">QMenu *pMenu=mbar-&gt;addMenu(<span class="string">&quot;文件&quot;</span>);  <span class="comment">//添加菜单</span></span><br><span class="line">QAction *pAction= pMenu-&gt;addAction(<span class="string">&quot;新建&quot;</span>)；<span class="comment">//在菜单里面添加项</span></span><br><span class="line">connect(pcAtion,&amp;QAction::triggered,[=]()&#123;&#125;);  <span class="comment">//可以绑定点击某个项时的操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//工具栏</span></span><br><span class="line">QToolBar *pTBar=addToolBar(<span class="string">&quot;&quot;</span>); <span class="comment">//获取工具栏</span></span><br><span class="line">pTBar-&gt;addAction(pAction)；<span class="comment">//在工具栏里面添加项</span></span><br><span class="line">pTBar-&gt;addAction(btn)；<span class="comment">//在工具栏里面添加按钮</span></span><br><span class="line">pTBar-&gt;addPermanentWidget(btn)；<span class="comment">//在工具栏里面从右往左添加按钮</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//状态栏</span></span><br><span class="line">QStatusBar *pSBar=statusBar(<span class="string">&quot;&quot;</span>); <span class="comment">//获取状态栏，其用法和工具栏差不多</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//QDialog</span></span><br><span class="line"><span class="comment">//在使用new创建对象后，如果不想把对象设为类的成员，想直接在函数里面new出来，可以使用setAttribute进行设置什么时候delete对象</span></span><br><span class="line">QDialog *dialog=<span class="keyword">new</span> QDialog();</span><br><span class="line">dialog-&gt;setAttribute(Qt::XX);</span><br><span class="line">dialog-&gt;exec();<span class="comment">//这样本来dialog是要到程序结束才会被delete，设置后可以按照需求delete</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
        <category>控件</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>类成员指针</title>
    <url>/2020/11/25/%E7%B1%BB%E6%88%90%E5%91%98%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>类成员指针时指可以指向类的非静态成员的指针，一般情况下，一个指针指向一个对象，但是成员指针指示的是类的成员，而非类的对象。指向类的静态成员的指针和普通指针没有什么区别。<a id="more"></a></p>
<h3 id="1、类数据成员指针的简单使用"><a href="#1、类数据成员指针的简单使用" class="headerlink" title="1、类数据成员指针的简单使用"></a>1、类数据成员指针的简单使用</h3><p>1、与普通指针不同的是，类数据成员指针必须在*前添加<code>classname::</code>以表示当前定义的指针可以指向<code>classname</code>的成员。</p>
<p>2、我们也可以定义指向类的成员函数的指针，和指向数据成员的指针一样，我们使用<code>classname::*</code>的形式声明一个指向成员函数的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Base() &#123; s = <span class="string">&quot;  &quot;</span>; &#125;</span><br><span class="line">	Base(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str) &#123; s = str; &#125;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base_A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">using</span> Base_fun = <span class="keyword">void</span>(Base_A::*)();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		(<span class="keyword">this</span>-&gt;*func[i])();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> Base_fun func[];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sum&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;back&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;up&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base_A::Base_fun Base_A::func[] = &#123; &amp;Base_A::sum,&amp;Base_A::back, &amp;Base_A::up &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="title">string</span><span class="params">(Base::*pstr)</span> </span>= &amp;Base::s;</span><br><span class="line">	<span class="keyword">auto</span> pstr1 = &amp;Base::s;</span><br><span class="line">	<span class="keyword">void</span> (Base::* pFunc)(<span class="keyword">int</span>) = &amp;Base::print;</span><br><span class="line">	<span class="keyword">using</span> pFUN = <span class="keyword">void</span> (Base::*)(<span class="keyword">int</span>);</span><br><span class="line">	pFUN pfunc1 = &amp;Base::print;</span><br><span class="line"></span><br><span class="line">	<span class="function">Base <span class="title">s</span><span class="params">(<span class="string">&quot;sss&quot;</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.*pstr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	(s.*pfunc1)(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">/*上面是数据成员指针的常规用法，列如类成员指针和类函数指针，</span></span><br><span class="line"><span class="comment">    下面是类成员函数的一个小例子，可以把函数存入类成员函数指针中*/</span></span><br><span class="line">    </span><br><span class="line">	Base_A a;</span><br><span class="line">	a.print(<span class="number">0</span>);</span><br><span class="line">	a.print(<span class="number">1</span>);</span><br><span class="line">	a.print(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、指向类成员函数的函数指针"><a href="#2、指向类成员函数的函数指针" class="headerlink" title="2、指向类成员函数的函数指针"></a>2、指向类成员函数的函数指针</h3><p><strong>定义：</strong>类成员函数指针（member function pointer），是 C++ 语言的一类指针数据类型，用于存储一个指定类具有给定的形参列表与返回值类型的成员函数的访问信息。</p>
<p>基本上要注意的有两点：</p>
<ul>
<li>1、函数指针赋值要使用 &amp;</li>
<li>2、使用 .* (实例对象)或者 -&gt;*（实例对象指针）调用类成员函数指针所指向的函数</li>
</ul>
<p>下面看两个例子：</p>
<h4 id="2-1、-类成员函数指针指向类中的非静态成员函数"><a href="#2-1、-类成员函数指针指向类中的非静态成员函数" class="headerlink" title="2.1、 类成员函数指针指向类中的非静态成员函数"></a>2.1、 类成员函数指针指向类中的非静态成员函数</h4><p>对于 <strong>nonstatic member function （非静态成员函数）</strong>取地址，获得该函数在内存中的实际地址</p>
<p>对于 <strong>virtual function（虚函数）</strong>, 其地址在编译时期是未知的，所以对于 virtual member function（虚成员函数）取其地址，所能获得的只是一个索引值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指向类成员函数的函数指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        A(<span class="keyword">int</span> aa = <span class="number">0</span>):a(aa)&#123;&#125;</span><br><span class="line">        ~A()&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> aa = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            a = aa;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A: &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A1: &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        B():A(), b(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">        B(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb):A(aa), b(bb)&#123;&#125;</span><br><span class="line">        ~B()&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            A::print();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B: &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            A::printa();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B: &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">void</span> (A::*ptr)(<span class="keyword">int</span>) = &amp;A::setA;</span><br><span class="line">    A* pa = &amp;a;</span><br><span class="line">    <span class="comment">//对于非虚函数，返回其在内存的真实地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A::set(): %p\n&quot;</span>, &amp;A::setA);</span><br><span class="line">    <span class="comment">//对于虚函数， 返回其在虚函数表的偏移位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B::print(): %p\n&quot;</span>, &amp;A::print);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B::print(): %p\n&quot;</span>, &amp;A::printa);</span><br><span class="line"> </span><br><span class="line">    a.print();</span><br><span class="line">    a.setA(<span class="number">10</span>);</span><br><span class="line">    a.print();</span><br><span class="line">    a.setA(<span class="number">100</span>);</span><br><span class="line">    a.print();</span><br><span class="line">    <span class="comment">//对于指向类成员函数的函数指针，引用时必须传入一个类对象的this指针，所以必须由类实体调用</span></span><br><span class="line">    (pa-&gt;*ptr)(<span class="number">1000</span>);</span><br><span class="line">    a.print();</span><br><span class="line">    (a.*ptr)(<span class="number">10000</span>);</span><br><span class="line">    a.print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A::set(): 0x8048a38</span><br><span class="line">B::print(): 0x1</span><br><span class="line">B::print(): 0x5</span><br><span class="line">A: 0</span><br><span class="line">A: 10</span><br><span class="line">A: 100</span><br><span class="line">A: 1000</span><br><span class="line">A: 10000</span><br></pre></td></tr></table></figure>

<h4 id="2-2、-类成员函数指针指向类中的静态成员函数"><a href="#2-2、-类成员函数指针指向类中的静态成员函数" class="headerlink" title="2.2、 类成员函数指针指向类中的静态成员函数"></a>2.2、 类成员函数指针指向类中的静态成员函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">//p1是一个指向非static成员函数的函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (A::*p1)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="comment">//p2是一个指向static成员函数的函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (*p2)(<span class="keyword">void</span>); </span><br><span class="line">    A()&#123;</span><br><span class="line">        <span class="comment">/*对</span></span><br><span class="line"><span class="comment">         **指向非static成员函数的指针和指向static成员函数的指针的变量的赋值方式是一样的，都是&amp;ClassName::memberVariable形式</span></span><br><span class="line"><span class="comment">         **区别在于：</span></span><br><span class="line"><span class="comment">         **对p1只能用非static成员函数赋值</span></span><br><span class="line"><span class="comment">         **对p2只能用static成员函数赋值</span></span><br><span class="line"><span class="comment">         **</span></span><br><span class="line"><span class="comment">         **再有，赋值时如果直接&amp;memberVariable，则在VS中报&quot;编译器错误 C2276&quot;</span></span><br><span class="line"><span class="comment">         **参见：http://msdn.microsoft.com/zh-cn/library/850cstw1.aspx</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        p1 =&amp;A::funa; <span class="comment">//函数指针赋值一定要使用 &amp;</span></span><br><span class="line">        p2 =&amp;A::funb;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//p1 =&amp;A::funb;//error</span></span><br><span class="line">        <span class="comment">//p2 =&amp;A::funa;//error</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//p1=&amp;funa;//error,编译器错误 C2276</span></span><br><span class="line">        <span class="comment">//p2=&amp;funb;//error,编译器错误 C2276</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funa</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funb</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="comment">//p是指向A中非static成员函数的函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (A::*p)(<span class="keyword">void</span>);</span><br><span class="line">    </span><br><span class="line">    (a.*a.p1)(); <span class="comment">//打印 A</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用.*(实例对象)或者-&gt;*（实例对象指针）调用类成员函数指针所指向的函数</span></span><br><span class="line">    p = a.p1;</span><br><span class="line">    (a.*p)();<span class="comment">//打印 A</span></span><br><span class="line">    </span><br><span class="line">    A *a1 = &amp;a;</span><br><span class="line">    (a1-&gt;*p)(); <span class="comment">//打印 A</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*尽管a.p2本身是个非static变量,但是a.p2是指向static函数的函数指针，</span></span><br><span class="line"><span class="comment">     **所以下面这就话是错的!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    p = a.p2;//error</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">/* void (*pp)(void);</span></span><br><span class="line"><span class="comment">    pp = &amp;A::funb;</span></span><br><span class="line"><span class="comment">    pp(); //打印 B*/</span></span><br><span class="line">    a1-&gt;p2();<span class="comment">//打印 B</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>1、类成员函数指针与普通函数指针不是一码事。前者要用 .* 与 -&gt;* 运算符来使用，而后者可以用 * 运算符（称为”解引用”dereference，或称”间址”indirection）。</p>
<p>2、普通函数指针实际上保存的是函数体的开始地址，因此也称”代码指针”，以区别于 C/C++ 最常用的数据指针。</p>
<p>3、而类成员函数指针就不仅仅是类成员函数的内存起始地址，还需要能解决因为 C++ 的多重继承、虚继承而带来的类实例地址的调整问题，所以类成员函数指针在调用的时候一定要传入类实例对象。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>函数指针</tag>
      </tags>
  </entry>
  <entry>
    <title>using的使用</title>
    <url>/2020/11/24/using%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>下面来整理using的三种用法。</p>
<h3 id="1、命名空间的使用"><a href="#1、命名空间的使用" class="headerlink" title="1、命名空间的使用"></a>1、命名空间的使用</h3><p>一般为了代码的冲突，都会用命名空间。例如，对于Android代码会使用Android作为命名空间。</p>
<p><code>namespace android;</code><a id="more"></a></p>
<p>在code中使用的时候可以用**<code>android::</code>**加具体的类方法。也可以直接使用<code>using namespace android;</code></p>
<p>具体的命名空间使用方法不做过多说明。</p>
<h3 id="2、在子类中引用基类的成员"><a href="#2、在子类中引用基类的成员" class="headerlink" title="2、在子类中引用基类的成员"></a>2、在子类中引用基类的成员</h3><p>来看下source code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T5Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T5Base() :value(<span class="number">55</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~T5Base() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T5Base test1...&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T5Derived</span> :</span> <span class="keyword">private</span> T5Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//using T5Base::test1;</span></span><br><span class="line">    <span class="comment">//using T5Base::value;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>基类中成员变量<code>value</code>是<code>protected</code>，在<code>private</code>继承之后，对于外界这个值为<code>private</code>，也就是说<code>T5Derived</code>的对象无法使用这个<code>value</code>。</p>
<p>如果想要通过对象使用，需要在<code>public</code>下通过<code>using T5Base::value</code>来引用，这样<code>T5Derived</code>的对象就可以直接使用。</p>
<p>同样的，对于基类中的成员函数<code>test1()</code>，在<code>private</code>继承后变为<code>private</code>，<code>T5Derived</code>的对象同样无法访问，通过<code>using T5Base::test1</code> 就可以使用了。</p>
<p><strong>注意:</strong><br>1、<code>using</code>只是引用，不参与形参的指定<br>2、在上面使用<code>using</code>的引用中，子类必须本身就可以调用父类的内容，也就是说使用<code>using</code>申明的必须是父类的**<code>private,public</code>**的成员，如果父类的成员是用<code>private</code>定义，则没办法用<code>using</code>使用。</p>
<h3 id="3、别名指定"><a href="#3、别名指定" class="headerlink" title="3、别名指定"></a>3、别名指定</h3><p>这点就是最开始看到的source code。在C++11中提出了通过using指定别名。</p>
<p>例如上面source code 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> value_type = _Ty</span><br></pre></td></tr></table></figure>

<p>以后使用value_type value; 就代表_Ty value；</p>
<p>这个让我们想起了typedef，using 跟typedef有什么区别呢？哪个更好用些呢？</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt; UPtrMapSS;</span><br></pre></td></tr></table></figure>

<p>而C++11中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UPtrMapSS = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>或许从这个例子中，我们是看不出来明显的好处的（而于我来说，以一个第三者的角度，这个例子也难以说服我一定要用C++11的using）。<br> 再来看下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>若不是特别熟悉函数指针与typedef的童鞋，我相信第一眼还是很难指出FP其实是一个别名，代表着的是一个函数指针，而指向的这个函数返回类型是void，接受参数是int, const std::string&amp;。那么，让我们换做C++11的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> FP = <span class="keyword">void</span> (*) (<span class="keyword">int</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure>

<p>我想，即使第一次读到这样代码，并且知道C++11 using的童鞋也能很容易知道FP是一个别名，using的写法把别名的名字强制分离到了左边，而把别名指向的放在了右边，比较清晰。<br> 而针对这样的例子，我想我可以再补充一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">std::string</span> <span class="params">(Foo::* fooMemFnPtr)</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="keyword">using</span> fooMemFnPtr = <span class="built_in">std</span>::<span class="built_in">string</span> (Foo::*) (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure>

<p>从可读性来看，using也是要好于typedef的。</p>
<p> 那么，若是从可读性的理由支持using，力度也是稍微不足的。来看第二个理由，那就是举出了一个typedef做不到，而using可以做到的例子：alias templates, 模板别名。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = MyVector&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">Vec&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure>

<p>这一切都会非常的自然。<br> 那么，若你使用typedef来做这一切：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> MyVector&lt;T, MyAlloc&lt;T&gt;&gt; Vec;</span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">Vec&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure>

<p>当你使用编译器编译的时候，将会得到类似：<code>error: a typedef cannot be a template</code>的错误信息。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>using</tag>
      </tags>
  </entry>
  <entry>
    <title>标准库的特殊设施</title>
    <url>/2020/11/21/%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E7%89%B9%E6%AE%8A%E8%AE%BE%E6%96%BD/</url>
    <content><![CDATA[<h3 id="1、tuple"><a href="#1、tuple" class="headerlink" title="1、tuple"></a>1、tuple</h3><p>和tuple相关的一共有4个函数，分别介绍</p>
<h4 id="1-1、make-tuple"><a href="#1-1、make-tuple" class="headerlink" title="1.1、make_tuple"></a>1.1、make_tuple</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> tup1 = <span class="built_in">std</span>::make_tuple(<span class="string">&quot;Hello World!&quot;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3.14</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码创建了一个<code>tuple &lt;const char*, char, double, int&gt;</code>类型的元组。</p>
<p>可以看出，在tuple之中可以是完全不同的数据类型。</p>
<a id="more"></a>

<h4 id="1-2、-tie-用于拆开tuple"><a href="#1-2、-tie-用于拆开tuple" class="headerlink" title="1.2、 tie: 用于拆开tuple"></a>1.2、 tie: 用于拆开tuple</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> tup1 = <span class="built_in">std</span>::make_tuple(<span class="number">3.14</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">double</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">std</span>::tie(a, b, c) = tup1;</span><br></pre></td></tr></table></figure>

<p>这样做的结果是<code>a = 3.14, b = 1, c = &#39;a&#39;</code></p>
<p>如果不想要某一位的值，可以直接将其用<code>ignore</code>代替。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::tie(ignore, b, c) = tup1;</span><br></pre></td></tr></table></figure>



<h4 id="1-3、forward-as-tuple-用于接受右值引用数据生成tuple"><a href="#1-3、forward-as-tuple-用于接受右值引用数据生成tuple" class="headerlink" title="1.3、forward_as_tuple: 用于接受右值引用数据生成tuple"></a>1.3、forward_as_tuple: 用于接受右值引用数据生成tuple</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> tup2 = <span class="built_in">std</span>::forward_as_tuple(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码创建了一个<code>tuple&lt;int &amp;&amp;, char (&amp;)[6]&gt;</code>类型的元组。</p>
<p>可以看出，tuple中的参数全部为右值引用。而前面讨论的tie函数就只能接受左值。</p>
<h4 id="1-4、-tuple-cat-用于连接tuple"><a href="#1-4、-tuple-cat-用于连接tuple" class="headerlink" title="1.4、 tuple_cat: 用于连接tuple"></a>1.4、 tuple_cat: 用于连接tuple</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;float, string&gt; tup1(3.14, &quot;pi&quot;);</span><br><span class="line">std::tuple&lt;int, char&gt; tup2(10, &#x27;a&#x27;);</span><br><span class="line"><span class="keyword">auto</span> tup3 = tuple_cat(tup1, tup2);</span><br></pre></td></tr></table></figure>

<p>将tup1和tup2连起来就成了tup3，里面包含了四个值。为<code>tuple&lt;float,string,int,char&gt;</code></p>
<h4 id="1-5、对于获取tuple中元素"><a href="#1-5、对于获取tuple中元素" class="headerlink" title="1.5、对于获取tuple中元素"></a>1.5、对于获取tuple中元素</h4><h5 id="1-5-1、get-lt-i-gt-获取第-i-个元素的值"><a href="#1-5-1、get-lt-i-gt-获取第-i-个元素的值" class="headerlink" title="1.5.1、get&lt;i&gt;: 获取第 i 个元素的值"></a><code>1.5.1、get&lt;i&gt;</code>: 获取第 i 个元素的值</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;float, string&gt; tup1(3.14, &quot;pi&quot;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(tup1);</span><br></pre></td></tr></table></figure>

<p>这样就输出了tup1中的第一个元素3.14.</p>
<h5 id="1-5-2、tuple-element-获取tuple中特定元素数据类型"><a href="#1-5-2、tuple-element-获取tuple中特定元素数据类型" class="headerlink" title="1.5.2、tuple_element: 获取tuple中特定元素数据类型"></a>1.5.2、tuple_element: 获取tuple中特定元素数据类型</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple_element&lt;<span class="number">0</span>, <span class="keyword">decltype</span>(tup1)&gt;::type</span><br></pre></td></tr></table></figure>

<p>这样就获取到了tup1中第一个元素的数据类型。</p>
<p>注意：获取到的就是数据类型，如<code>int</code>，<code>char</code>。而不是写有“int”或者“char”的字符串。</p>
<h5 id="1-5-3、size-获取tuple中元素个数"><a href="#1-5-3、size-获取tuple中元素个数" class="headerlink" title="1.5.3、size: 获取tuple中元素个数"></a>1.5.3、size: 获取tuple中元素个数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;float, string&gt; tup1(3.14, &quot;pi&quot;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tuple_size&lt;<span class="keyword">decltype</span>(tup1)&gt;::value;</span><br></pre></td></tr></table></figure>

<p>输出结果为2，表示该tuple中有两个元素。 </p>
<p>可以看出，tuple是一个非常强大的数据结构，比以前常用的如pair，vector等都要强大很多。</p>
<h3 id="2、bitset"><a href="#2、bitset" class="headerlink" title="2、bitset"></a>2、bitset</h3><p>C++的 bitset 在 <code>&lt;bitset&gt;</code> 头文件中，它是一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。</p>
<p>一般来说bitset会让你的算法复杂度 /32</p>
<p>下面是具体用法</p>
<h4 id="2-1、构造函数"><a href="#2-1、构造函数" class="headerlink" title="2.1、构造函数"></a>2.1、构造函数</h4><p>bitset常用构造函数有四种，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;4&gt; bitset1;　　<span class="comment">//无参构造，长度为４，默认每一位为０</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;8&gt; <span class="title">bitset2</span><span class="params">(<span class="number">12</span>)</span></span>;　　<span class="comment">//长度为８，将12转换成二进制保存到后面，前面用０补充</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;100101&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;10&gt; <span class="title">bitset3</span><span class="params">(s)</span></span>;　　<span class="comment">//长度为10，前面用０补充</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s2[] = <span class="string">&quot;10101&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;13&gt; <span class="title">bitset4</span><span class="params">(s2)</span></span>;　　<span class="comment">//长度为13，前面用０补充</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bitset1 &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//0000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bitset2 &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//00001100</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bitset3 &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//0000100101</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bitset4 &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//0000000010101</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2、特别注意"><a href="#2-2、特别注意" class="headerlink" title="2.2、特别注意"></a>2.2、特别注意</h4><blockquote>
<p>1.biset里十进制数进来以后直接用cout输出是正常的二进制。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;8&gt; <span class="title">bitset2</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bitset2 &lt;&lt; <span class="built_in">endl</span>;　　</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">00001100</span></span><br></pre></td></tr></table></figure>

<p>但是实际上里面的二进制是倒序的。<br> 如果循环从0位输出到最后一位，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i) &#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;b[i];</span><br><span class="line">&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出的是倒序的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">00110000</span></span><br></pre></td></tr></table></figure>

<p>如何实现2进制向10进制的转换，而且二进制的表示形式是一种逆序的形式，即低位在前。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bin2dec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; bin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="built_in">string</span>(bin.rbegin(), bin.rend()))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> bs.to_ulong();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用字符串构造时，字符串只能包含 ‘0’ 或 ‘1’ ，否则会抛出异常。</p>
</blockquote>
<p> 构造时，需在&lt;&gt;中表明bitset 的大小(即size)。<br> 在进行有参构造时，若参数的二进制表示比bitset的size小，则在前面用０补充(如上面的栗子)；若比bitsize大，<strong>参数为整数时取后面部分，参数为字符串时取前面部分</strong>(如下面栗子)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;2&gt; <span class="title">bitset1</span><span class="params">(<span class="number">12</span>)</span></span>;　　<span class="comment">//12的二进制为1100（长度为４），但bitset1的size=2，只取后面部分，即00</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;100101&quot;</span>;　　</span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;4&gt; <span class="title">bitset2</span><span class="params">(s)</span></span>;　　<span class="comment">//s的size=6，而bitset的size=4，只取前面部分，即1001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s2[] = <span class="string">&quot;11101&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;4&gt; <span class="title">bitset3</span><span class="params">(s2)</span></span>;　　<span class="comment">//与bitset2同理，只取前面部分，即1110</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bitset1 &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//00</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bitset2 &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//1001</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bitset3 &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//1110</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3、可用的操作符"><a href="#2-3、可用的操作符" class="headerlink" title="2.3、可用的操作符"></a>2.3、可用的操作符</h4><p>bitset对于二进制有位操作符，具体如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;4&gt; <span class="title">foo</span> <span class="params">(<span class="built_in">string</span>(<span class="string">&quot;1001&quot;</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;4&gt; <span class="title">bar</span> <span class="params">(<span class="built_in">string</span>(<span class="string">&quot;0011&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo^=bar) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// 1010 (foo对bar按位异或后赋值给foo)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo&amp;=bar) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// 0010 (按位与后赋值给foo)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo|=bar) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// 0011 (按位或后赋值给foo)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo&lt;&lt;=<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 1100 (左移２位，低位补０，有自身赋值)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo&gt;&gt;=<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0110 (右移１位，高位补０，有自身赋值)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (~bar) &lt;&lt; <span class="built_in">endl</span>;           <span class="comment">// 1100 (按位取反)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (bar&lt;&lt;<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">// 0110 (左移，不赋值)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (bar&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">// 0001 (右移，不赋值)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo==bar) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// false (0110==0011为false)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo!=bar) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// true  (0110!=0011为true)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo&amp;bar) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0010 (按位与，不赋值)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo|bar) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0111 (按位或，不赋值)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo^bar) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 0101 (按位异或，不赋值)</span></span><br></pre></td></tr></table></figure>

<p><strong>此外，可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０</strong>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;4&gt; <span class="title">foo</span> <span class="params">(<span class="string">&quot;1011&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; foo[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; foo[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; foo[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>当然，通过这种方式对某一位元素赋值也是可以的，栗子就不放了。</p>
<h4 id="2-4、可用函数"><a href="#2-4、可用函数" class="headerlink" title="2.4、可用函数"></a>2.4、可用函数</h4><p>bitset还支持一些有意思的函数，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;8&gt; <span class="title">foo</span> <span class="params">(<span class="string">&quot;10011011&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; foo.count() &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//5　　（count函数用来求bitset中1的位数，foo中共有５个１</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; foo.size() &lt;&lt; <span class="built_in">endl</span>;　　 <span class="comment">//8　　（size函数用来求bitset的大小，一共有８位</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; foo.test(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//true　　（test函数用来查下标处的元素是０还是１，并返回false或true，此处foo[0]为１，返回true</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; foo.test(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//false　　（同理，foo[2]为０，返回false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; foo.any() &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//true　　（any函数检查bitset中是否有１</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; foo.none() &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//false　　（none函数检查bitset中是否没有１</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; foo.all() &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//false　　（all函数检查bitset中是全部为１</span></span><br></pre></td></tr></table></figure>

<p>补充说明一下：test函数会对下标越界作出检查，而通过 [ ] 访问元素却不会经过下标检查，所以，在两种方式通用的情况下，选择test函数更安全一些<br> 另外，含有一些函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;8&gt; <span class="title">foo</span> <span class="params">(<span class="string">&quot;10011011&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; foo.flip(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//10011111　　（flip函数传参数时，用于将参数位取反，本行代码将foo下标２处&quot;反转&quot;，即０变１，１变０</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; foo.flip() &lt;&lt; <span class="built_in">endl</span>;　　 <span class="comment">//01100000　　（flip函数不指定参数时，将bitset每一位全部取反</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; foo.<span class="built_in">set</span>() &lt;&lt; <span class="built_in">endl</span>;　　　　<span class="comment">//11111111　　（set函数不指定参数时，将bitset的每一位全部置为１</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; foo.<span class="built_in">set</span>(<span class="number">3</span>,<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//11110111　　（set函数指定两位参数时，将第一参数位的元素置为第二参数的值，本行对foo的操作相当于foo[3]=0</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; foo.<span class="built_in">set</span>(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;　　  <span class="comment">//11111111　　（set函数只有一个参数时，将参数下标处置为１</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; foo.reset(<span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//11101111　　（reset函数传一个参数时将参数下标处置为０</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; foo.reset() &lt;&lt; <span class="built_in">endl</span>;　　 <span class="comment">//00000000　　（reset函数不传参数时将bitset的每一位全部置为０</span></span><br></pre></td></tr></table></figure>

<p>同样，它们也都会检查下标是否越界，如果越界就会抛出异常<br> 最后，还有一些类型转换的函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;8&gt; <span class="title">foo</span> <span class="params">(<span class="string">&quot;10011011&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s = foo.to_string();　　<span class="comment">//将bitset转换成string类型</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> a = foo.to_ulong();　　<span class="comment">//将bitset转换成unsigned long类型</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> b = foo.to_ullong();　　<span class="comment">//将bitset转换成unsigned long long类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//10011011</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//155</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;　　<span class="comment">//155</span></span><br></pre></td></tr></table></figure>



<h3 id="3、正则表达式"><a href="#3、正则表达式" class="headerlink" title="3、正则表达式"></a>3、正则表达式</h3><p>表达式可以是以下项之一：</p>
<ul>
<li><p>一般的字符，可匹配目标序列中相同的字符。<br> 例如：<code>a</code> 只能匹配 <code>a</code>; <code>abc</code>只能匹配<code>abc</code>。</p>
</li>
<li><p>通配符 <code>.</code>，可匹配目标序列中除了换行符外的任何字符。<br> 例如：<code>a.c</code> 可以匹配<code>abc</code>、<code>a c</code>、<code>a.c</code>、<code>a1c</code>等等。</p>
</li>
<li><p><code>[expr]</code> 形式的括号表达式，可以匹配目标序列中包含在表达式<code>expr</code>定义集内的字符或者排序规则表达式；采用<code>[^expr]</code>，可匹配目标序列中未包含在表达式expr定义集内的字符或排序规则表达式。<br> 表达式<code>expr</code>可以包含下列的任意组合：</p>
<ul>
<li>单个字符。例如：<code>[A]</code> 匹配 <code>A</code></li>
<li><code>ch1-ch2</code>形式的字符域。例如 <code>[A-F]</code> 匹配大写字母A到F中的任何一个字母，比如：匹配 <code>A</code>.</li>
<li><code>[:name:]</code>形式的字符类。例如：<code>[[:alpha:]]</code> 匹配一个字母（不区分大小写）。</li>
</ul>
<table>
<thead>
<tr>
<th>字符类名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>alnum</td>
<td>字母（不区分大小写）和数字</td>
</tr>
<tr>
<td>alpha</td>
<td>字母（不区分大小写）</td>
</tr>
<tr>
<td>blank</td>
<td>空格或制表符</td>
</tr>
<tr>
<td>cntrl</td>
<td>文件格式转义字符</td>
</tr>
<tr>
<td>digit</td>
<td>数字</td>
</tr>
<tr>
<td>graph</td>
<td>字母（不区分大小写）、数字和英文标点</td>
</tr>
<tr>
<td>lower</td>
<td>小写字母</td>
</tr>
<tr>
<td>upper</td>
<td>大写字母</td>
</tr>
<tr>
<td>print</td>
<td>字母（不区分大小写）、数字、英文标点和空格</td>
</tr>
<tr>
<td>punct</td>
<td>英文标点</td>
</tr>
<tr>
<td>sapce</td>
<td>空格</td>
</tr>
<tr>
<td>xdigit</td>
<td>表示十六进制的字符（数字,a,b,c,d,e,f,A,B,C,D,E,F）</td>
</tr>
<tr>
<td>d</td>
<td>与digit相同</td>
</tr>
<tr>
<td>s</td>
<td>与space相同</td>
</tr>
<tr>
<td>w</td>
<td>与alnum相同</td>
</tr>
</tbody></table>
</li>
<li><p>定位点。定位点<code>^</code>匹配目标序列的开头，<code>$</code>可匹配目标序列的末尾。<br> 定位点可匹配目标字符串中的位置，而不匹配字符。</p>
</li>
<li><p>转义序列</p>
<ul>
<li>文件格式转义。<br> <code>\\</code>、<code>\f</code>、<code>\n</code>、<code>\r</code>、<code>\t</code>和<code>\v</code>,他们分别匹配目标序列中的反斜杠、换页符、回车符、水平制表符合垂直制表符。</li>
<li>DSW字符转义</li>
</ul>
<table>
<thead>
<tr>
<th>转义序列</th>
<th>等效命名类</th>
<th>默认命名类</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d</code></td>
<td><code>[[:d:]]</code></td>
<td><code>[[:digit:]]</code></td>
</tr>
<tr>
<td><code>\D</code></td>
<td><code>[^[:D:]]</code></td>
<td><code>[^[:digit:]]</code></td>
</tr>
<tr>
<td><code>\s</code></td>
<td><code>[[:s:]]</code></td>
<td><code>[[:space:]]</code></td>
</tr>
<tr>
<td><code>\S</code></td>
<td><code>[^[:S:]]</code></td>
<td><code>[^[:space:]]</code></td>
</tr>
<tr>
<td><code>\w</code></td>
<td><code>[[:w:]]</code></td>
<td><code>[a-zA-Z0-9]</code></td>
</tr>
<tr>
<td><code>\W</code></td>
<td><code>[^[:W:]]</code></td>
<td><code>[^a-zA-Z0-9]</code></td>
</tr>
</tbody></table>
<ul>
<li>8进制数转义<br> <code>\ooo</code>，”ooo”表示三位的八进制数，例如：<code>\101</code> 匹配字符 <code>A</code>。</li>
<li>16进制数转义<br> <code>\xhh</code>，”hh”表示两位的十六进制数，例如：<code>\x41</code> 匹配字符 <code>A</code>。</li>
<li>Unicode 转义<br> <code>\uhhhh</code>,”hhhh”表示四位的十六进制数，例如：<code>\u0041</code> 匹配字符<code>A</code>。</li>
</ul>
</li>
</ul>
<h4 id="3-1、量词"><a href="#3-1、量词" class="headerlink" title="3.1、量词"></a>3.1、量词</h4><p>一个量词指定了要匹配的表达式出现的次数。例如，<code>x&#123;1,1&#125;</code> 表示必须且只能匹配一个字符<code>x</code>，而<code>x&#123;1,3&#125;</code>表示至少匹配一个<code>x</code>，最多匹配三个<code>x</code>。</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>E?</td>
<td>匹配0次或者1次 <code>E</code>(表达式)，等价于 <code>E&#123;0,1&#125;</code></td>
</tr>
<tr>
<td>E+</td>
<td>至少匹配一次 <code>E</code>,等价于 <code>E&#123;1,&#125;</code></td>
</tr>
<tr>
<td>E*</td>
<td>匹配0次或者多次 <code>E</code>,等价于 <code>E&#123;0,&#125;</code></td>
</tr>
<tr>
<td>E{n}</td>
<td>匹配n次<code>E</code>,等价于<code>E&#123;n,n&#125;</code></td>
</tr>
<tr>
<td>E{n,}</td>
<td>至少匹配n次<code>E</code></td>
</tr>
<tr>
<td>E{,m}</td>
<td>至多匹配m次<code>E</code></td>
</tr>
<tr>
<td>E{n,m}</td>
<td>至少匹配n次，至多匹配m次<code>E</code></td>
</tr>
</tbody></table>
<p>例如：<code>[A-C]+</code>， 可匹配 <code>AAA</code> 、<code>B</code> </p>
<h4 id="3-2、断言"><a href="#3-2、断言" class="headerlink" title="3.2、断言"></a>3.2、断言</h4><table>
<thead>
<tr>
<th>断言</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>一个单词的边界</td>
</tr>
<tr>
<td>\B</td>
<td>一个非单词的边界</td>
</tr>
<tr>
<td>（?=E）</td>
<td>表达式后面紧跟着E才匹配成功，但不会改名目标序列中匹配的位置</td>
</tr>
<tr>
<td>(?!E)</td>
<td>表达式后没有紧跟着E才匹配成功，但不会改名目标序列中匹配的位置</td>
</tr>
<tr>
<td>(?:E)</td>
<td>表达式后面紧跟着E才匹配成功</td>
</tr>
</tbody></table>
<p>例如：<br> <code>\\bmail\\b</code> 匹配的就是一个单词<code>mail</code>。<br> <code>This is a T(?!est)</code>表示如果<code>T</code>后面没有<code>est</code>就匹配，这主要用于替换，后面会有实例。<br> <code>This is a T(?=est)</code>表示如果<code>T</code>后面有<code>est</code>就匹配，这主要用于替换，后面会有实例。 </p>
<h4 id="3-3、实例"><a href="#3-3、实例" class="headerlink" title="3.3、实例"></a>3.3、实例</h4><p>在C++中使用正则表达式需要用到<code>regex</code>库。<br> 默认情况下，正则表达式遵循ECMAScript语法。</p>
<p>常用函数：</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>regex_match</td>
<td>将一个字符序列与正则表达式进行匹配。</td>
</tr>
<tr>
<td>regex_search</td>
<td>查找字符序列中与正则表达式匹配的结果，找到第一个之后就会返回结果并停止查找。</td>
</tr>
<tr>
<td>regex_replace</td>
<td>替换字符到正交表达式匹配到字符序列的位置。</td>
</tr>
</tbody></table>
<h5 id="3-3-1、检验邮箱格式"><a href="#3-3-1、检验邮箱格式" class="headerlink" title="3.3.1、检验邮箱格式"></a>3.3.1、检验邮箱格式</h5><p>邮箱的一般格式：<a href="mailto:&#120;&#x78;&#x78;&#x40;&#x78;&#x78;&#120;&#x2e;&#99;&#111;&#109;">&#120;&#x78;&#x78;&#x40;&#x78;&#x78;&#120;&#x2e;&#99;&#111;&#109;</a><br> 验证 <a href="mailto:&#120;&#120;&#120;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#109;">&#120;&#120;&#120;&#x40;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#109;</a> 格式的邮箱。<br> 正则表达式：<code>[[:graph:]]+@163[.]com</code>，这里将<code>.</code>用方括号括起来是因为<code>.</code>在正在表达式中是一个通配符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> re = <span class="string">&quot;[[:graph:]]+@163[.]com&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">rule</span><span class="params">(re)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;acvds.cpp@163.com&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; regex_match(str, rule) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//true</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-2、IP地址匹配"><a href="#3-3-2、IP地址匹配" class="headerlink" title="3.3.2、IP地址匹配"></a>3.3.2、IP地址匹配</h5><p>原理：<br> IP地址是有四个用小数点隔开的十进制整数（0<del>255）组成的，每个整数的位数不确定，以及整数是不同位数的时候，每个位上数字的取值范围也会存在差异，所以需要一一匹配。<br> 当整数是一位的时候，取值是0</del>9,正则表达式<code>\\d</code>(反斜杠需要转义)；<br> 当整数是两位的时候，取值是0<del>9,正则表达式<code>\\d&#123;1,2&#125;</code>;<br> 当整数是三位的时候，当最高位是1的时候，其它两位的取值是0</del>9，正则表达式<code>1\\d&#123;1,2&#125;</code>;当最高位是2的时候，其它两位的取值是0~5，正则表达式<code>2[0-5]&#123;1,2&#125;</code>;<br> 然后用<code>|</code>（或）连接。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> re = <span class="string">&quot;(\\d|\\d&#123;1,2&#125;|(1\\d&#123;1,2&#125;)|2[0-5]&#123;1,2&#125;)[.](\\d|\\d&#123;1,2&#125;|(1\\d&#123;1,2&#125;)|2[0-5]&#123;1,2&#125;)[.](\\d|\\d&#123;1,2&#125;|(1\\d&#123;1,2&#125;)|2[0-5]&#123;1,2&#125;)[.](\\d|\\d&#123;1,2&#125;|(1\\d&#123;1,2&#125;)|2[0-5]&#123;1,2&#125;)&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">rule</span><span class="params">(re)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;100.100.100.0&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; regex_match(str, rule) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//true</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-3、英译汉"><a href="#3-3-3、英译汉" class="headerlink" title="3.3.3、英译汉"></a>3.3.3、英译汉</h5><p>这里主要涉及到<code>regex_replace</code>函数的使用。<br> 函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">basic_string&lt;_Elem, _Traits1, _Alloc1&gt; regex_replace(</span><br><span class="line"><span class="keyword">const</span> basic_string&lt;_Elem, _Traits1, _Alloc1&gt;&amp; _Str,</span><br><span class="line"><span class="keyword">const</span> basic_regex&lt;_Elem, _RxTraits&gt;&amp; _Re,</span><br><span class="line"><span class="keyword">const</span> _Elem *_Ptr,</span><br><span class="line">regex_constants::match_flag_type _Flgs =regex_constants::match_default);<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>一共四个参数，第一个参数是目标字符串，第二个参数是正则表达式规则，第三个是用于替换的字符串， 第四个是设置正则表达式如何匹配以及格式化用于替换的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> re1 = <span class="string">&quot;i&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> re2 = <span class="string">&quot;love&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> re3 = <span class="string">&quot;you&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">rule1</span><span class="params">(re1)</span></span>;</span><br><span class="line">    <span class="function">regex <span class="title">rule2</span><span class="params">(re2)</span></span>;</span><br><span class="line">    <span class="function">regex <span class="title">rule3</span><span class="params">(re3)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot; i love you.&quot;</span>;</span><br><span class="line">    str = regex_replace(str, rule1, <span class="string">&quot;我&quot;</span>);</span><br><span class="line">    str = regex_replace(str, rule2, <span class="string">&quot;喜欢&quot;</span>);</span><br><span class="line">    str = regex_replace(str, rule3, <span class="string">&quot;你&quot;</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//我喜欢你</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-4、画龙点睛"><a href="#3-3-4、画龙点睛" class="headerlink" title="3.3.4、画龙点睛"></a>3.3.4、画龙点睛</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> re = <span class="string">&quot;E(?!xpression)&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">rule</span><span class="params">(re)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;Regular E&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; regex_replace(str,rule,<span class="string">&quot;Expression&quot;</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//Regular Expression</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-5、捕获"><a href="#3-3-5、捕获" class="headerlink" title="3.3.5、捕获"></a>3.3.5、捕获</h5><p>捕获就是先匹配，然后将匹配结果存储下来。捕获同样是使用上面介绍的那两个函数，仍然区分为整串匹配和子串匹配。</p>
<p><strong>捕获的步骤：</strong></p>
<ol>
<li>模式中一般要有分组（因为捕捉的正是分组匹配的结果）</li>
<li>定义一个STL容器smatch，用来保存捕捉的结果</li>
<li>使用<code>reg_search</code>函数匹配，用<code>smatch</code>的实例存储匹配的结果，即完成捕捉。</li>
<li>使用<code>m.size()</code>，查看捕捉到的个数；使用<code>m.str(i)</code>，查看捕捉到的字符串；【注意：<code>m.str(0)</code>一定是整个正则匹配到的部分，<code>m.str(1)</code>及以后才是分组捕获的结果】</li>
<li><code>m.prefix().str()</code>获取整个匹配之前的字符串；<code>m.suffix().str()</code>获取整个匹配之后的字符串</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="function">regex <span class="title">e</span><span class="params">(<span class="string">&quot;([[:w:]]+)@([[:w:]]+)\.com&quot;</span>)</span></span>;</span><br><span class="line">        smatch m;</span><br><span class="line">        <span class="keyword">bool</span> found = regex_search(str, m, e);</span><br><span class="line">        <span class="keyword">if</span>(found)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m.size() &quot;</span> &lt;&lt; m.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m.size(); ++i)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m.str(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; m.str(i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m.prefix().str(): &quot;</span> &lt;&lt; m.prefix().str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m.suffix().str(): &quot;</span> &lt;&lt; m.suffix().str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Not Found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="https://zhuom-go.github.io/img/Regular_expression/1.png" alt="img"></p>
<p><img src="https://zhuom-go.github.io/img/Regular_expression/2.png" alt="img"></p>
<p><strong>补充：</strong></p>
<ol>
<li>获取第i个匹配<code>m.str(i)</code>，还有其他等价写法：<code>m[i].str()</code>、<code>*(m.begin() + i)</code></li>
<li>模式其实可以不分组…这样就只有<code>m.str(0)</code>捕捉到整个串，没有<code>m.str(1)</code>其他的了。</li>
</ol>
<h5 id="3-3-6、更高级的捕捉"><a href="#3-3-6、更高级的捕捉" class="headerlink" title="3.3.6、更高级的捕捉"></a>3.3.6、更高级的捕捉</h5><p>由于<code>regex_replace</code>方法<strong>只能捕捉到第一个匹配</strong>，想要捕捉到每一个匹配，以及匹配内的分组，需要使用另外一种方法：</p>
<p><strong>步骤：</strong></p>
<ol>
<li>正则内有分组</li>
<li>定义迭代器的同时初始化迭代器，使其指向一个<code>smatch</code>实例的数组。</li>
<li>定义<code>end</code>，标志<code>smatch</code>实例的数组的末尾</li>
<li>使用迭代器遍历数组</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;boo@gmail.com  boqian@hotmail.com bo_qian@163.com&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">e</span><span class="params">(<span class="string">&quot;([[:w:]]+)@([[:w:]]+)\.com&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">sregex_iterator <span class="title">pos</span><span class="params">(str.cbegin(), str.cend(), e)</span></span>;</span><br><span class="line">    sregex_iterator end;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(; pos!=end; ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Matched: &quot;</span> &lt;&lt; pos-&gt;str(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;user name: &quot;</span> &lt;&lt; pos-&gt;str(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;domain: &quot;</span> &lt;&lt; pos-&gt;str(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充：</strong></p>
<ol>
<li><p>同上，模式中也可以没有分组，这样也就没有<code>pos-&gt;str(1)</code>其他的了。</p>
</li>
<li><p>还有一种更高级的捕捉，能够实现一模一样的功能，只是对捕获的结果的组织顺序不相同，它将所有与第一个分组匹配的结果，放在一个容器内。</p>
<p>运行如下代码，感受一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;boo@gmail.com  boqian@hotmail.com bo_qian@163.com&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">e</span><span class="params">(<span class="string">&quot;([[:w:]]+)@([[:w:]]+)\.com&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">sregex_token_iterator <span class="title">pos</span><span class="params">(str.cbegin(), str.cend(), e, <span class="number">1</span>)</span></span>;<span class="comment">// 表示第一个分组，再换成0、2、-1感受一下</span></span><br><span class="line">    sregex_token_iterator end;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(; pos!=end; ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Matched: &quot;</span> &lt;&lt; pos-&gt;str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="3-3-7、捕捉的同时生成新串"><a href="#3-3-7、捕捉的同时生成新串" class="headerlink" title="3.3.7、捕捉的同时生成新串"></a>3.3.7、捕捉的同时生成新串</h5><p><code>regex_replace</code>方法先完成捕捉，得到类似于：</p>
<p>大匹配1：分组1、分组2<br> 大匹配2：分组1、分组2<br> 大匹配3：分组1、分组2<br> …</p>
<p>所以如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;boo@gmail.com  boqian@hotmail.com bo_qian@163.com&quot;</span>;</span><br><span class="line">    <span class="function">regex <span class="title">e</span><span class="params">(<span class="string">&quot;([[:w:]]+)@([[:w:]]+)\.com&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; regex_replace(str, e, <span class="string">&quot;$1 is on $2\n&quot;</span>, regex_constants::format_no_copy); <span class="comment">// 除了捕捉到的组以外，其他的东西均舍弃</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://zhuom-go.github.io/img/Regular_expression/3.png" alt="img"></p>
<p><strong>补充：</strong></p>
<ol>
<li><code>regex_replace</code>除了<code>regex_constants::format_no_copy</code>以外，还有其他flag，如<code>regex_constants::format_first_only</code>表示只取“大匹配1”，而忽略其他。</li>
<li>flag和flag之间通过<code>|</code>相连接。</li>
<li><code>regex_match</code>和<code>regex_search</code>也有自己的flag，如用于忽略英文字母大小写的<code>regex_constants::icase</code></li>
</ol>
<h3 id="3、随机数"><a href="#3、随机数" class="headerlink" title="3、随机数"></a>3、随机数</h3><h4 id="3-1、rand和srand"><a href="#3-1、rand和srand" class="headerlink" title="3.1、rand和srand"></a>3.1、rand和srand</h4><p>  在C++11标准出来之前，C/C++都依赖于<code>stdlib.h</code>头文件的<code>rand</code>或者<code>srand</code>来生成随机数。</p>
<p>  其不是真正的随机数，是一个伪随机数，是根据一个数（我们可以称它为种子）为基准以某个递推公式推算出来的一系列数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的，除非你破坏了系统。</p>
<ul>
<li>rand：内部是线性同余实现的，因为周期较长，所以在一定的范围内可看成随机的。系统默认随机种子是1。rand()返回一随机数值的范围在0至RAND_MAX 间。RAND_MAX的范围最少是在32767之间(int)。用unsigned int  双字节是65535，四字节是4294967295的整数范围。0~RAND_MAX每个数字被选中的机率是相同的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>srand：srand()用来设置rand()产生随机数时的随机数种子。参数seed必须是个整数，如果每次seed都设相同值，rand()所产生的随机数值每次就会一样。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>常见用法如下：<ul>
<li>(rand() % (b - a)) + a ，生成[a, b) 的随机整数</li>
<li>(rand() % (b - a + 1)) + a ，生成[a,b] 的随机整数</li>
<li>rand() / double(RAND_MAX) ，生成0～1之间的浮点数</li>
</ul>
</li>
<li>来个测试代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++ )  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; rand() &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2、新标准随机数"><a href="#3-2、新标准随机数" class="headerlink" title="3.2、新标准随机数"></a>3.2、新标准随机数</h4><p>  有时候程序员需要一些非均匀分布的数，这时候rand就显得不是那么好用，新标准很好解决了这个问题：<code>随机数引擎类</code>和<code>随机数分布类</code>。引擎用来生成随机unsigned整数序列，分布则使用引擎返回服从特定概率分布的随机数。</p>
<p>  标准库定义了多个随机数引擎类，区别在于性能和随机性质量不同。每个编译器都会指定其中一个作为<code>default_random_engine</code>类型。标准库定义的引擎通用操作如下：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Engine e</td>
<td>默认构造函数，使用该引擎默认的种子</td>
</tr>
<tr>
<td>Engine e(s)</td>
<td>使用整型值s作为种子</td>
</tr>
<tr>
<td>e.seed(s)</td>
<td>使用种子s重置引擎的状态</td>
</tr>
<tr>
<td>e.max(), e.min()</td>
<td>该引擎可生成的最大和最小值</td>
</tr>
<tr>
<td>Engine::result_type</td>
<td>该引擎生成的unsigned整型类型</td>
</tr>
<tr>
<td>e.discard(u)</td>
<td>将引擎推进u步，u为unsigned long long类型</td>
</tr>
</tbody></table>
<p>  对于大多数场合，随机数引擎的输出是不能直接使用的，还要配合合适的分布类。均匀分布类为<code>uniform_int_distribution&lt;unsigned&gt;</code>。标准库中的分布类的通用操作如下：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Dist d</td>
<td>默认构造函数</td>
</tr>
<tr>
<td>d(e)</td>
<td>用相同的引擎e连续生成随机数序列</td>
</tr>
<tr>
<td>d.max(), d.min()</td>
<td>返回d(e)能生成的最大和最小值</td>
</tr>
<tr>
<td>d.reset()</td>
<td>重建d的状态，使得随后对d的使用不依赖于d已经生成的值</td>
</tr>
</tbody></table>
<p>  以下为简单测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0~9的均匀分布</span></span><br><span class="line">	<span class="function">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">	<span class="comment">//若想生成0~1的double</span></span><br><span class="line">	<span class="comment">//uniform_int_distribution&lt;double&gt; u(0,1);</span></span><br><span class="line">	default_random_engine e;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; u(e) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="comment">//由于是默认的种子，所以应该都是0 1 7 4 5 2 0 6 6 9</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  为了生成不同的结果，我们可以通过设置种子，为引擎设置种子的方法有两种方式：在创建引擎对象的时候提供种子，或者调用引擎的seed成员。简单测试如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	default_random_engine e1; <span class="comment">//默认种子</span></span><br><span class="line">	<span class="function">default_random_engine <span class="title">e2</span><span class="params">(<span class="number">2147483646</span>)</span></span>; <span class="comment">//给定的种子</span></span><br><span class="line">	default_random_engine e3;</span><br><span class="line">	e3.seed(<span class="number">32767</span>); <span class="comment">//调用成员seed</span></span><br><span class="line">	<span class="function">default_random_engine <span class="title">e4</span><span class="params">(<span class="number">32767</span>)</span></span>; <span class="comment">//和e3一样的种子</span></span><br><span class="line">	<span class="function">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; u(e1) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; u(e2) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; u(e3) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; u(e4) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  除了均匀分布下生成<code>unsigned</code>整数，我们还可以生成不同分布下别的类型的数值。比如<code>u在·生成0~1的double类型值，还有</code>normal_distribution&lt;&gt; n(4,1.5)`生成均值为4，标准差为1.5的正态分布double类型值。</p>
<h3 id="4、IO库再探"><a href="#4、IO库再探" class="headerlink" title="4、IO库再探"></a>4、IO库再探</h3><h5 id="4-1、格式化输入与输出"><a href="#4-1、格式化输入与输出" class="headerlink" title="4.1、格式化输入与输出"></a>4.1、格式化输入与输出</h5><blockquote>
<p><strong>控制布尔值的格式</strong></p>
</blockquote>
<p><code> boolalpha noboolalpha</code><br><img src="https://zhuom-go.github.io/img/Second_IO/1.png" alt="img"></p>
<blockquote>
<p><strong>指定整型值得进制</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/2.png" alt="img"><br> <img src="https://zhuom-go.github.io/img/Second_IO/23.png" alt="img"></p>
<blockquote>
<p><strong>在输出中指出进制</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/3.png" alt="img"></p>
<blockquote>
<p><strong>控制浮点数格式</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/4.png" alt="img"></p>
<blockquote>
<p><strong>指定打印的精度</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/5.png" alt="img"></p>
<p><img src="https://zhuom-go.github.io/img/Second_IO/6.png" alt="img"></p>
<blockquote>
<p><strong>指定浮点数计数法</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/7.png" alt="img"></p>
<blockquote>
<p><strong>打印小数点</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/8.png" alt="img"></p>
<blockquote>
<p><strong>输出补白</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/9.png" alt="img"><br><img src="https://zhuom-go.github.io/img/Second_IO/24.png" alt="img"><br><img src="https://zhuom-go.github.io/img/Second_IO/10.png" alt="img"><br> <img src="https://zhuom-go.github.io/img/Second_IO/25.png" alt="img"></p>
<blockquote>
<p><strong>控制输入格式</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/11.png" alt="img"><br><img src="https://zhuom-go.github.io/img/Second_IO/12.png" alt="img"></p>
<h5 id="4-2、未格式化的输入-输出操作"><a href="#4-2、未格式化的输入-输出操作" class="headerlink" title="4.2、未格式化的输入/输出操作"></a>4.2、未格式化的输入/输出操作</h5><blockquote>
<p><strong>单字节操作</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/13.png" alt="img"></p>
<blockquote>
<p><strong>将字符放回输入流</strong></p>
</blockquote>
<p> <img src="https://zhuom-go.github.io/img/Second_IO/14.png" alt="img"></p>
<blockquote>
<p><strong>从输入操作返回的int值</strong></p>
</blockquote>
<p> <img src="https://zhuom-go.github.io/img/Second_IO/15.png" alt="img"></p>
<blockquote>
<p><strong>多字节操作</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/16.png" alt="img"><br> <img src="https://zhuom-go.github.io/img/Second_IO/17.png" alt="img"></p>
<h5 id="4-3、流随机访问"><a href="#4-3、流随机访问" class="headerlink" title="4.3、流随机访问"></a>4.3、流随机访问</h5><p><img src="https://zhuom-go.github.io/img/Second_IO/26.png" alt="img"><br><img src="https://zhuom-go.github.io/img/Second_IO/18.png" alt="img"></p>
<blockquote>
<p><strong>seek和tell函数</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/19.png" alt="img"></p>
<blockquote>
<p><strong>只有一个标记</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/20.png" alt="img"></p>
<blockquote>
<p><strong>重定位标记</strong></p>
</blockquote>
<p> <img src="https://zhuom-go.github.io/img/Second_IO/21.png" alt="img"></p>
<blockquote>
<p><strong>读写同一个文件</strong></p>
</blockquote>
<p><img src="https://zhuom-go.github.io/img/Second_IO/21_1.png" alt="img"><br> <img src="https://zhuom-go.github.io/img/Second_IO/22.png" alt="img"></p>
<ul>
<li>​                                    </li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>tuple</tag>
      </tags>
  </entry>
  <entry>
    <title>QT事件与槽函数绑定</title>
    <url>/2020/11/20/Qt%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%A7%BD%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h3 id="1、重载信号的槽函数绑定"><a href="#1、重载信号的槽函数绑定" class="headerlink" title="1、重载信号的槽函数绑定"></a>1、重载信号的槽函数绑定</h3><p>槽绑定重载的信号时，如果想用<code>Lambda</code>表达式，直接绑定将无法识别，需要进行强制转换，如下所示。<a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QCPAxis</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">signals:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rangeChanged</span><span class="params">(<span class="keyword">const</span> QCPRange &amp;newRange)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rangeChanged</span><span class="params">(<span class="keyword">const</span> QCPRange &amp;newRange, <span class="keyword">const</span> QCPRange &amp;oldRange)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">connect(w-&gt;xAxis,&amp;QCPAxis::rangeChanged,<span class="keyword">this</span>,[=]( QCPRange)&#123;&#125;);</span><br><span class="line"><span class="comment">//error:无法识别绑定是那个槽</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//进行如下强转</span></span><br><span class="line">connect(w-&gt;xAxis,<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>(QCPAxis::* )(QCPRange)&gt;(&amp;QCPAxis::rangeChanged),<span class="keyword">this</span>,[=]( QCPRange)&#123;&#125;);</span><br><span class="line"><span class="comment">//error:这里将会报错，原因是无法识别，绑定的参数需要严格匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fine</span></span><br><span class="line">connect(w-&gt;xAxis,<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>(QCPAxis::* )(<span class="keyword">const</span> QCPRange&amp;)&gt;(&amp;QCPAxis::rangeChanged),<span class="keyword">this</span>,[=](<span class="keyword">const</span> QCPRange&amp;)&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2、Sender的作用"><a href="#2、Sender的作用" class="headerlink" title="2、Sender的作用"></a>2、Sender的作用</h3><p>在进行实际编程时，对于信号的发送端是什么类型，我们可以通过<code>sender</code>获取,并进行转化回去，这样我们就可以操作发信号的对象了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person *p=<span class="keyword">static_cast</span>&lt;Person *&gt;(sender());</span><br><span class="line"><span class="comment">//Person *p=qobject_cast&lt;Person *&gt;(sender());</span></span><br></pre></td></tr></table></figure>

<h3 id="3、事件绑定"><a href="#3、事件绑定" class="headerlink" title="3、事件绑定"></a>3、事件绑定</h3><p>在使用QT的实际时，是直接新建一个类，在类里面重写事件，再把控件提升为该类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h文件，继承于提升的控件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp 文件重写上述函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Label::mouseMoveEvent</span><span class="params">(QMouseEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想一进入就触发mouseMoveEvent ,则需要在一开始加入下面这句函数</span></span><br><span class="line"><span class="keyword">this</span>-&gt;setMouseTracking(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在事件中还有一个timerEvent的定时器事件</span></span><br><span class="line"><span class="comment">//可以通过startTimer来启动，killTimer来停止，其中killTimer的id是startTimer的返回值</span></span><br></pre></td></tr></table></figure>

<h3 id="4、事件的接受和忽略"><a href="#4、事件的接受和忽略" class="headerlink" title="4、事件的接受和忽略"></a>4、事件的接受和忽略</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当使用上述的事件绑定时，如果重写了一个类的事件，并提升</span></span><br><span class="line"><span class="comment">//*.h文件重写了该函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *e)</span></span>;</span><br><span class="line"><span class="comment">//此时如果想在主窗口中使用 clicked()信号，此时会和该事件重叠，需要对上述事件进行忽略</span></span><br><span class="line"><span class="comment">//*.cpp文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QPushButton::mousePressEvent</span><span class="params">(QMouseEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  处理的事务</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  QPushButton::mousePressEvent(e); <span class="comment">//忽略该事件，事件继续传播下去，如果使用的是e-&gt;ignore()，其忽略完后是传递给主控件QWidget</span></span><br><span class="line">                                   <span class="comment">//e-&gt;accept()，则是直接接受该事件，不向下传播</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于事件的传输方式，其实是把事件统一汇聚在event()函数中，在对event()函数进行选择后分发</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QPushButton::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(e-&gt;type==(**))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> QEvent::***:<span class="comment">//获得什么事件，然后处理，在return true把其阻断继续传播</span></span><br><span class="line">      ....;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">case</span> ....</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> QPushButton::event(e);<span class="comment">//把没有定义的事件继续传播下去，如果没有这一步，其它事件将不会执行 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当使用上面的event方法时，如果是在单个类中则使用方便，当如果想在主函数中使用，则需使用事件过滤器，方便判断事件是由哪个控件发出的</span></span><br><span class="line">ui-&gt;label_2-&gt;installEventFilter(<span class="keyword">this</span>); <span class="comment">//安装事件过滤器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重写事件过滤器</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Widget::eventFilter</span><span class="params">(QObject *obj,QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(boj==ui-&gt;label_2)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span>(e-&gt;type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> QEvent::***:<span class="comment">//获得什么事件，然后处理，在return true把其阻断继续传播</span></span><br><span class="line">      ....;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">case</span> ....</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> QWidget::eventFilter(obj,e);<span class="comment">//把没有定义的事件继续传播下去，如果没有这一步，其它事件将不会执行 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> QWidget::eventFilter(obj,e);<span class="comment">//把没有定义的事件继续传播下去，如果没有这一步，其它事件将不会执行  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、线程中QTimer的使用-把函数在线程中调用"><a href="#5、线程中QTimer的使用-把函数在线程中调用" class="headerlink" title="5、线程中QTimer的使用(把函数在线程中调用)"></a>5、线程中QTimer的使用(把函数在线程中调用)</h3><p>对于要调用的函数先写在一个类中，先把这个类<code>new</code>出来 <code>QTimer *T_count=new Qtimer() </code>，注意不要指定父对象，然后再<code>new</code>一个<code>QThread *th=new QThread(this)</code>，把<code>QTimer</code>移进线程中<code>T_count-&gt;moveToThread(th)</code>，启动线程<code>th-&gt;start()</code>,在需要启动线程的地方使用信号与槽触发函数，所以需要绑定信号，让信号触发<code>QTimer</code>里面的函数，此时<code>Qtimer</code>将会在线程里面运行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mythread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MYTHREAD::MYTHREAD(QObject *parent) : QThread(parent)</span><br><span class="line">&#123;</span><br><span class="line">    T_count=<span class="keyword">new</span> QTimer();</span><br><span class="line">    thread=<span class="keyword">new</span> QThread(<span class="keyword">this</span>);</span><br><span class="line">    num=<span class="number">0</span>;</span><br><span class="line">    m_start=<span class="literal">false</span>;</span><br><span class="line">    T_count-&gt;moveToThread(thread);</span><br><span class="line">    connect(<span class="keyword">this</span>,&amp;MYTHREAD::m_startTimer,T_count,<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> (QTimer::*)(<span class="keyword">int</span>)&gt;(&amp;QTimer::start));</span><br><span class="line">    connect(T_count,&amp;QTimer::timeout,[=]()</span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">        T_count-&gt;start(<span class="number">1000</span>);</span><br><span class="line">        emit sendNum(num);</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           m_start=<span class="literal">true</span>;</span><br><span class="line">           T_count-&gt;stop();</span><br><span class="line">           msleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MYTHREAD::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num=<span class="number">0</span>;</span><br><span class="line">    m_start=<span class="literal">false</span>;</span><br><span class="line">    thread-&gt;start();</span><br><span class="line">    <span class="function">emit <span class="title">m_startTimer</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_start)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    thread-&gt;quit();</span><br><span class="line">    thread-&gt;wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
        <tag>connect</tag>
      </tags>
  </entry>
  <entry>
    <title>模板与泛型编程</title>
    <url>/2020/11/18/%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>面向对象编程和泛型编程都能处理编写程序时不知道类型的情况</p>
<p>区别就是OOP是在运行时处理，而泛型编程是在编译的时候就能知道类型了<a id="more"></a></p>
<h3 id="1、函数模板"><a href="#1、函数模板" class="headerlink" title="1、函数模板"></a>1、函数模板</h3><h4 id="1-1、定义模板"><a href="#1-1、定义模板" class="headerlink" title="1.1、定义模板"></a>1.1、定义模板</h4><p>我们可以为函数定义一个模板，而不是为每一个类型定义一个函数。</p>
<p>比较函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;v1, <span class="keyword">const</span> T&amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i1 = <span class="number">10</span>, i2 = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">double</span> d1 = <span class="number">20.1</span>, d2 = <span class="number">20.01</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> u1 = <span class="number">10</span>, u2 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; compare(i1, i2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; compare(d1, d2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; compare(u1, u2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板定义以关键字<strong>template</strong>开始，</p>
<p>后面跟一个参数列表，这是一个逗号分隔的一个或多个模板参数的列表，用<code>&lt; &gt;</code>包围起来。</p>
<p>当我们调用一个函数模板时，编译器会用函数的实参来为我们推断模板实参</p>
<h4 id="1-2、类型参数"><a href="#1-2、类型参数" class="headerlink" title="1.2、类型参数"></a>1.2、类型参数</h4><p>类型参数前必须使用关键字<code>class</code>或者<code>typename</code></p>
<p>在模板参数列表中，这两个关键字的含义相同，可以互换使用，一个模板参数列表中可以同时使用这两个关键字</p>
<p>类型参数在函数中使用我们就把它当作正常类型使用就可以了，比如作为函数的参数，返回值，以及函数内部定义变量等等</p>
<h4 id="1-3、非类型模板参数"><a href="#1-3、非类型模板参数" class="headerlink" title="1.3、非类型模板参数"></a>1.3、非类型模板参数</h4><p>除了定义类型参数，我们还可以定义非类型参数，非类型参数表示一个值而非一个类型，我们通过一个特定的类型名而非关键字class或typename来指定。</p>
<p>当一个模板被实例化，非类型参数被一个编译器推断的值所取代。</p>
<p>一个非类型参数可以是一个整形，或者是一个指向对象或函数类型的指针或（左值）引用，绑定到非类型整形参数必须是一个常量，绑定到指针或引用的非类型模板</p>
<p>参数的实参必须有静态生存期。</p>
<p>注意：非类型模板参数的模板必须是常量表达式</p>
<p><code>inline </code>和<code>constexpr</code>也可以修饰函数模板，放在返回值前面</p>
<h4 id="1-4、编写类型无关的代码"><a href="#1-4、编写类型无关的代码" class="headerlink" title="1.4、编写类型无关的代码"></a>1.4、编写类型无关的代码</h4><p>编写泛型代码的两个重要的原则</p>
<p>&lt;1.模板中的函数参数是const的引用</p>
<p>&lt;2.函数体条件中判断仅仅使用&lt;比较</p>
<p>这两个可以降低对类型的要求</p>
<p>比如const的引用，就保证了函数可以用于不能拷贝的类型。</p>
<p><code>&lt;</code>比较就可以用于大多数定义了<code>&lt;</code>比较的类型。</p>
<p><strong>结论：模板程序应该尽量减少对实参类型的要求</strong></p>
<h4 id="1-5、模板编译"><a href="#1-5、模板编译" class="headerlink" title="1.5、模板编译"></a>1.5、模板编译</h4><p>模板编译和普通的编译不同，它是在使用实例化时编译器才生成代码，为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，</p>
<p>因此和非模板代码不同，模板的头文件通常既包括声明又包括定义。</p>
<p>模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。</p>
<p>模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。</p>
<h4 id="1-6、大多数编译错误在实例化期间报告"><a href="#1-6、大多数编译错误在实例化期间报告" class="headerlink" title="1.6、大多数编译错误在实例化期间报告"></a>1.6、大多数编译错误在实例化期间报告</h4><p>保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。</p>
<p>例题：编写行为类似find算法的模板，函数需要两个模板类型参数，一个表示函数的迭代器参数，另外一个表示值的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">iterator <span class="title">Find</span><span class="params">(<span class="keyword">const</span> iterator &amp;beg, <span class="keyword">const</span> iterator &amp;end, <span class="keyword">const</span> T&amp;ele)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = beg; it != end; ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*it == ele)</span><br><span class="line">            <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ivec1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> ret = Find(begin(ivec1), end(ivec1), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == end(ivec1))</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not find&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;find &quot;</span> &lt;&lt; *ret &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;il = &#123;<span class="string">&quot;111&quot;</span>,<span class="string">&quot;222&quot;</span>,<span class="string">&quot;333&quot;</span>,<span class="string">&quot;444&quot;</span>,<span class="string">&quot;555&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> ret2 = Find(il.begin(), il.end(), <span class="string">&quot;333&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret2 == il.end())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not find&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;find &quot;</span> &lt;&lt; *ret2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://zhuom-go.github.io/img/Template/1.png" alt="img"></p>
<h3 id="2、类模板"><a href="#2、类模板" class="headerlink" title="2、类模板"></a>2、类模板</h3><p>类模板是生成类的模板-。</p>
<p>它和函数模板的不同是它不能向函数模板一样推断出类型是什么，而是要自己指定类型是什么</p>
<p>比如<code>vector&lt;T&gt;</code>就是一个模板类，T可以是任何类型<code>int ,double ,string</code>或者是自己定义的类类型</p>
<p>举个书上的例子来说一些概念和注意的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BLOB_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BLOB_H_</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;strblob.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//必须声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">blobptr</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">blob</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> blob&lt;T&gt;&amp;, <span class="keyword">const</span> blob&lt;T&gt;&amp;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">blob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">blobptr</span>&lt;</span>T&gt;;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;(<span class="keyword">const</span> blob&lt;T&gt;&amp;, <span class="keyword">const</span> blob&lt;T&amp;&gt;);</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> T value_type;</span><br><span class="line">        <span class="comment">//加上typename 是因为T是一个模板类型，编译器不知道std::vector&lt;T&gt;::size_type 是什么,加上typename就是告诉编译器是一个type</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::size_type size_type;</span><br><span class="line">        blob();</span><br><span class="line">        blob(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; il);</span><br><span class="line"> </span><br><span class="line">        <span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;size(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;empty(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp;t)</span> </span>&#123; <span class="keyword">return</span> data-&gt;push_back(t); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; <span class="keyword">return</span> data-&gt;push_back(<span class="built_in">std</span>::move(t)); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">        T&amp; <span class="keyword">operator</span>[] (size_type i);</span><br><span class="line">        <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](size_type i)<span class="keyword">const</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span><span class="keyword">const</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;blob.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//类模板的成员函数必须具有和模板相同的模板参数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">blob&lt;T&gt;::blob():data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;()) &#123; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">blob&lt;T&gt;::blob(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; il):</span><br><span class="line">    data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(il)) &#123; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> blob&lt;T&gt;::check(size_type i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= data-&gt;size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(s);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> blob&lt;T&gt;::pop_back()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">&quot;pop_back on empty blob&quot;</span>);</span><br><span class="line">    data-&gt;pop_back();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; blob&lt;T&gt;::front()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">&quot;back on empty blob&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> data-&gt;front();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; blob&lt;T&gt;::back()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">&quot;back on empty blob&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> data-&gt;back();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; blob&lt;T&gt;::<span class="keyword">operator</span>[](blob&lt;T&gt;::size_type i)</span><br><span class="line">&#123;</span><br><span class="line">    check(i, <span class="string">&quot;subscript out of range&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&gt;(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> blob&lt;T&gt;&gt;(*<span class="keyword">this</span>)[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> T&amp; blob&lt;T&gt;::<span class="keyword">operator</span>[](blob&lt;T&gt;::size_type i)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    check(i, <span class="string">&quot;subscript out of range&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _STRBLOB_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STRBLOB_H_</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;blob.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//必须要其他的.h文件声明，否则无法使用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">blob</span>;</span>   </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">blobptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        blobptr():curr(<span class="number">0</span>)&#123; &#125;</span><br><span class="line">        blobptr(blob&lt;T&gt; &amp;a, <span class="built_in">std</span>::<span class="keyword">size_t</span> sz = <span class="number">0</span>):</span><br><span class="line">            wptr(a.data), curr(sz) &#123; &#125;</span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()<span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = check(curr, <span class="string">&quot;* error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">        &#125;</span><br><span class="line">        blobptr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">        blobptr&amp; <span class="keyword">operator</span>--();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> curr;</span><br><span class="line">        <span class="built_in">std</span>::weak_ptr&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;wptr;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;strblob.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;</span><br><span class="line">blobptr&lt;T&gt;::check(<span class="built_in">std</span>::<span class="keyword">size_t</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//检查是否存在</span></span><br><span class="line">    <span class="keyword">auto</span> ret = wptr.lock();</span><br><span class="line">    <span class="keyword">if</span>(!ret)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">&quot;unbound blobptr&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> &amp;&amp; i &gt;= ret-&gt;size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(msg);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">blobptr&lt;T&gt;&amp; blobptr&lt;T&gt;::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    blobptr ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">blobptr&lt;T&gt;&amp; blobptr&lt;T&gt;::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">    blobptr ret = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 1.一个类模板的每个实例都形成一个独立的类，但是类和类之间没有关系。 </p>
<p>2.我们既可以在类模板外部为其定义成员函数，也可以在类模板内部定义，内部定义被隐式的声明为内敛函数。</p>
<p>3.类模板的成员函数具有和模板相同的模板参数，因此，定义在模板之外的成员函数就必须以关键字template开始，后接参数列表.</p>
<p>4.默认情况下，对于一个实例化的类模板，其成员只有在使用时才被实例化。</p>
<p>5.当我们使用一个类模板类型必须提供模板参数，但有一个例外，在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。</p>
<blockquote>
<p><strong>模板类和友元</strong></p>
</blockquote>
<p>6.类和友元各自是否是模板是无关的。友元关系被限定在用相同的类型实例化。</p>
<p>7.一个模板类也可以指定另外一个模板类为友元或者另外一个模板类的特定实例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//friend class C&lt;int&gt;;                 //特定类为友元</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span>  <span class="comment">//模板类为友元</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span>  <span class="comment">//error:本模板类参数列表已经包含T了，友元不可再次包含T,需要换参数,否则会报错显示应藏参数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>8.令自己的 实例化类型作为友元(c++11) </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> X&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们实例化的时候，实例化类型是A，A就是模板类的友元，A可以是类类型，或者是内置类型。 </p>
<blockquote>
<p>9.类模板别名(c++11)</p>
</blockquote>
<p>旧标准中，我们只能使用typedef 为特定模板类型定义类型别名。</p>
<p>c++11标准中，我们可以为模板类定义模板类型别名，而且多个参数时可以指定参数是T或者是特定类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> X, <span class="keyword">typename</span> Z&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//template参数列表指定参数的个数，但是我们能指定一个或多个特定类型比如TEP2的int</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> X, <span class="keyword">typename</span> Z&gt; <span class="keyword">using</span> TEP = C&lt;T, X, Z&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> X&gt; <span class="keyword">using</span> TEP2 = C&lt;T, X, <span class="keyword">int</span>&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; c;</span><br><span class="line">    TEP&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; t;</span><br><span class="line">    TEP2&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>10.类模板的static成员</p>
</blockquote>
<p>当类模板包含<code>static</code>成员时（数据或者是函数）,每个类模板的实例都有一个static成员，而且定义类模板的static成员时，前面必须加<code>template &lt;参数列表&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(T &amp;a)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> C&lt;T&gt;::fun(T &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//别忘记了int</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> C&lt;T&gt;::i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C&lt;<span class="keyword">int</span>&gt;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11.使用模板时别偷懒，时刻注意模板声明template和参数列表，使用时记得注意指定类型，不明则使用T</p>
<h3 id="3、模板参数"><a href="#3、模板参数" class="headerlink" title="3、模板参数"></a>3、模板参数</h3><h4 id="3-1、模板参数和作用域"><a href="#3-1、模板参数和作用域" class="headerlink" title="3.1、模板参数和作用域"></a>3.1、模板参数和作用域</h4><p>模板参数符合隐藏规则，而且一个模板参数名在参数列表中只能出现一次。</p>
<p>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</p>
<h4 id="3-2、使用类的类型成员"><a href="#3-2、使用类的类型成员" class="headerlink" title="3.2、使用类的类型成员"></a>3.2、使用类的类型成员</h4><p>我们处理模板的时候，必须让编译器知道名字是否表示一个类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T::size_type *p;    <span class="comment">//error   typename T::size_type *p</span></span><br></pre></td></tr></table></figure>

<p>我们不知道T是一个名字还是模板的参数列表里的类型，c++编译器默认为名字。 </p>
<p>所以如果我们像上面想表示为一个类型的话必须显式的指定，在前面添加关键字typename</p>
<h4 id="3-3、默认模板实参"><a href="#3-3、默认模板实参" class="headerlink" title="3.3、默认模板实参"></a>3.3、默认模板实参</h4><p>在新标准中，我们可以为函数和类模板提供默认实参</p>
<p>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//X默认实参是std::less&lt;T&gt;这个函数对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> X = <span class="built_in">std</span>::less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2, X x = X())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x(v1, v2))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x(v2, v1))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传参数函数对象std::greater</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; compare(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//使用默认参数  std::less</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; compare(<span class="number">0</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhuom-go.github.io/img/Template/2.png" alt="img"></p>
<p>类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt; </span><br><span class="line">class C</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C(T v = <span class="number">0</span>):</span><br><span class="line">            val(v) &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T val;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C&lt;&gt; c;            <span class="comment">//使用默认int</span></span><br><span class="line">    C&lt;<span class="keyword">double</span>&gt; c2;     <span class="comment">//覆盖默认int改用double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>记住<code>typename</code>和<code>class</code>不是完全相同的，在指明是一个类型而不是名字的情况下必须用<code>typename</code></p>
<p>比如<code>typedef typename T::size_type = size_type </code></p>
<h4 id="3-4、成员模板"><a href="#3-4、成员模板" class="headerlink" title="3.4、成员模板"></a>3.4、成员模板</h4><h5 id="3-4-1、普通（非模板）类的成员模板"><a href="#3-4-1、普通（非模板）类的成员模板" class="headerlink" title="3.4.1、普通（非模板）类的成员模板"></a>3.4.1、普通（非模板）类的成员模板</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DebugDelete(<span class="built_in">std</span>::ostream &amp;s = <span class="built_in">std</span>::<span class="built_in">cerr</span>):</span><br><span class="line">            os(s) &#123; &#125;</span><br><span class="line">        <span class="comment">//类成员模板</span></span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os &lt;&lt; <span class="string">&quot;deleting unique_ptr&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::ostream &amp;os;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> *p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">    DebugDelete d;</span><br><span class="line">    d(p);</span><br><span class="line">    <span class="keyword">int</span> *i = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    DebugDelete()(i);    <span class="comment">//调用默认构造函数，生成一个DebugDelete类型的对象，括号必须加上，再根据构造函数是否有形参添加相应的参数。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span> , DebugDelete&gt;p2(<span class="keyword">new</span> <span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-4-2、类模板的成员模板"><a href="#3-4-2、类模板的成员模板" class="headerlink" title="3.4.2、类模板的成员模板"></a>3.4.2、类模板的成员模板</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;C(X b, X e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;ivec;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;       <span class="comment">//类的参数列表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;       <span class="comment">//构造函数的参数列表</span></span><br><span class="line">C&lt;T&gt;::C(X b, X e)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;svc = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    C&lt;<span class="keyword">int</span>&gt;c(svc.begin(), svc.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-4-3、实例化与成员模板"><a href="#3-4-3、实例化与成员模板" class="headerlink" title="3.4.3、实例化与成员模板"></a>3.4.3、实例化与成员模板</h5><p>实例化一个类模板的成员函数模板，类模板必须明确指出类型，函数模板根据参数推断出类型，如上面main函数里面的实例。</p>
<h4 id="3-5、控制实例化"><a href="#3-5、控制实例化" class="headerlink" title="3.5、控制实例化"></a>3.5、控制实例化</h4><p>我们知道一个模板在使用时根据不同的类型就会产生不同实例化。</p>
<p>如果在多个文件中使用模板，产生的多个实例化可能会重复，带来额外的开销影响效率。</p>
<p>我们可以通过显式实例化来解决问题</p>
<p>形式：</p>
<p><code>extern template declaration</code>  //实例化声明</p>
<p><code>template declaration</code>        //实例化定义</p>
<p>我们只需要在一个文件中实例化定义，其他文件实例化声明即可。</p>
<p><strong>注意：对每个实例化声明，在程序中某个位置必须有其显式的实例化定义</strong></p>
<p><strong>实例化定义会实例化所有成员，包括内敛函数成员</strong></p>
<p><strong>所以在一个类模板定义中，所用类型必须能用于模板的所有成员函数</strong></p>
<h4 id="3-6、效率与灵活性"><a href="#3-6、效率与灵活性" class="headerlink" title="3.6、效率与灵活性"></a>3.6、效率与灵活性</h4><p>书上举的是<code>shared_ptr </code>和<code>unique_ptr </code>的例子</p>
<p>这两个智能指针都能绑定删除器</p>
<p><code>shared_ptr</code>删除器：在运行时绑定的删除器</p>
<p>在一个<code>shared_ptr</code>的生存期中，我们可以随时改变其删除器的类型。</p>
<p><code>unique_ptr</code>删除器：在编译时绑定的删除器</p>
<p><code>unique_ptr</code>的删除器是<code>unique_ptr</code>的一部分</p>
<p><code>unique_ptr</code>有两个模板参数，一个表示它所管理的指针，另一个表示删除器的类型，在编译时绑定，所以没有运行开销</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;</span><span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">D</span> =</span> dedault_delete&lt;T&gt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span></span></span><br></pre></td></tr></table></figure>

<p>通过编译时绑定删除器，<code>unique_ptr </code>避免了间接调用删除器的运行时开销。 </p>
<p>通过运行时绑定删除器，<code>shared_ptr </code>使用户重载删除器更加方便。</p>
<p>自己实现<code>shared_ptr </code>和 <code>unique_ptr</code></p>
<p>参考别人的实现  <a href="https://github.com/Mooophy/Cpp-Primer/tree/master/ch16/ex16.28">https://github.com/Mooophy/Cpp-Primer/tree/master/ch16/ex16.28</a></p>
<p><code>shared_ptr</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Myshared_ptr</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Myshared_ptr&lt;T&gt;&amp;lhs, Myshared_ptr&lt;T&gt;&amp;rhs)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DebugDelete(<span class="built_in">std</span>::ostream&amp;s = <span class="built_in">std</span>::<span class="built_in">cerr</span>):</span><br><span class="line">            os(s) &#123; &#125;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os &lt;&lt; <span class="string">&quot;delete~&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::ostream &amp;os;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myshared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//自定义交换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Myshared_ptr&lt;T&gt;&amp;lhs, Myshared_ptr&lt;T&gt;&amp;rhs)</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Myshared_ptr():</span><br><span class="line">            p(<span class="literal">nullptr</span>), num(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">0</span>)) &#123; &#125;</span><br><span class="line">        <span class="comment">//explicit避免隐式转换</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Myshared_ptr</span><span class="params">(T *t, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(T*)&gt;d = DebugDelete())</span>:</span></span><br><span class="line">            p(t), num(new std::size_t(1)), deleter(d) &#123; &#125;</span><br><span class="line">        Myshared_ptr(<span class="keyword">const</span> Myshared_ptr&amp; mp):</span><br><span class="line">            p(mp.p), num(mp.num), deleter(mp.deleter)</span><br><span class="line">            &#123; ++*num; &#125;</span><br><span class="line">        Myshared_ptr(Myshared_ptr &amp;&amp;mp)<span class="keyword">noexcept</span>;</span><br><span class="line">        Myshared_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Myshared_ptr &amp;);</span><br><span class="line">        Myshared_ptr&amp; <span class="keyword">operator</span>=(Myshared_ptr &amp;&amp;)<span class="keyword">noexcept</span>;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> p ? <span class="literal">true</span> : <span class="literal">false</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">        &#123; <span class="keyword">return</span> *p; &#125;</span><br><span class="line">        </span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">        &#123; <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*(); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">use_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> *num; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">unique</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> *num == <span class="number">1</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Myshared_ptr &amp;mp)</span></span></span><br><span class="line"><span class="function">        </span>&#123; ::swap(*<span class="keyword">this</span>, mp); &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span><span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            decrement_n_destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T *t)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(p == t)</span><br><span class="line">            &#123;</span><br><span class="line">                decrement_n_destroy();</span><br><span class="line">                p = t;</span><br><span class="line">                num = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ~Myshared_ptr()</span><br><span class="line">        &#123;</span><br><span class="line">            decrement_n_destroy();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">decrement_n_destroy</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> *num = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//删除器,使用function是为了函数，函数指针，函数对象和lambda都可以作为删除器类型。</span></span><br><span class="line">        <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(T*)&gt;deleter&#123;DebugDelete()&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">swap(Myshared_ptr&lt;T&gt;&amp;lhs, Myshared_ptr&lt;T&gt;&amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(lhs.p, rhs.p);</span><br><span class="line">    swap(lhs.num, rhs.num);</span><br><span class="line">    swap(lhs.deleter, rhs.deleter);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Myshared_ptr&lt;T&gt;::Myshared_ptr(Myshared_ptr&lt;T&gt; &amp;&amp;mp)<span class="keyword">noexcept</span>:</span><br><span class="line">    p(mp.p), num(mp.num), deleter(<span class="built_in">std</span>::move(mp.deleter)) </span><br><span class="line">&#123;</span><br><span class="line">    mp.p = <span class="literal">nullptr</span>;</span><br><span class="line">    mp.num = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Myshared_ptr&lt;T&gt;&amp; </span><br><span class="line">Myshared_ptr&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> Myshared_ptr&lt;T&gt; &amp;mp)</span><br><span class="line">&#123;</span><br><span class="line">    ++*mp.num;</span><br><span class="line">    decrement_n_destroy();</span><br><span class="line">    p = mp.p;</span><br><span class="line">    num = mp.num;</span><br><span class="line">    deleter = mp.deleter;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Myshared_ptr&lt;T&gt;&amp;</span><br><span class="line">Myshared_ptr&lt;T&gt;::<span class="keyword">operator</span>=(Myshared_ptr&lt;T&gt; &amp;&amp;mp)<span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    decrement_n_destroy();</span><br><span class="line">    ::swap(*<span class="keyword">this</span>, mp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">std</span>::ostream&amp;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, Myshared_ptr&lt;T&gt;&amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; p.get();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">Myshared_ptr&lt;T&gt;::decrement_n_destroy()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(--*num == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> num;</span><br><span class="line">            deleter(p);</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="literal">nullptr</span>;</span><br><span class="line">        p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Myshared_ptr&lt;<span class="keyword">int</span>&gt;p1;</span><br><span class="line">    Myshared_ptr&lt;<span class="keyword">int</span>&gt;p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));</span><br><span class="line">    p1 = p2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unique_ptr</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Myunique_ptr</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Myunique_ptr&lt;T,D&gt; &amp;lhs, Myunique_ptr&lt;T,D&gt; &amp;rhs)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">default_delete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        default_delete(<span class="built_in">std</span>::ostream &amp;s = <span class="built_in">std</span>::<span class="built_in">cerr</span>):</span><br><span class="line">            os(s) &#123; &#125;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            os &lt;&lt; <span class="string">&quot;delete ptr&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::ostream &amp;os;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = default_delete&gt;</span><br><span class="line">class Myunique_ptr</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> swap(Myunique_ptr&lt;T,D&gt;&amp;lhs, Myunique_ptr&lt;T,D&gt;&amp;rhs);</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// preventing copy and assignment</span></span><br><span class="line">        Myunique_ptr(<span class="keyword">const</span> Myunique_ptr&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        Myunique_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Myunique_ptr&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        </span><br><span class="line">        Myunique_ptr() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="comment">// explicit 禁止隐式转换</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Myunique_ptr</span><span class="params">(T *t)</span>:</span></span><br><span class="line"><span class="function">            <span class="title">p</span><span class="params">(t)</span> </span>&#123; &#125;</span><br><span class="line">        <span class="comment">// 左值版本</span></span><br><span class="line">        Myunique_ptr(Myunique_ptr&lt;T&gt; &amp;&amp;mp)<span class="keyword">noexcept</span></span><br><span class="line">            :p(mp.p) &#123; mp.p = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">        <span class="comment">// 在对象即将要销毁时可以复制</span></span><br><span class="line">        Myunique_ptr&amp; <span class="keyword">operator</span>=(Myunique_ptr &amp;&amp;mp)<span class="keyword">noexcept</span>;</span><br><span class="line">        Myunique_ptr&amp; <span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span> n)<span class="keyword">noexcept</span>;</span><br><span class="line"> </span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()<span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> *p; &#125;</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;()<span class="keyword">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p ? <span class="literal">true</span> : <span class="literal">false</span>; &#125;</span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Myunique_ptr&lt;T,D&gt; &amp;rhs)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ::swap(*<span class="keyword">this</span>, rhs);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span>     </span>&#123; deleter(p); p = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T *t)</span><span class="keyword">noexcept</span>  </span>&#123; deleter(p); p = t; &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function">T* <span class="title">release</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">        ~Myunique_ptr()</span><br><span class="line">        &#123; deleter(p); &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *p;</span><br><span class="line">        D deleter = D();</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">swap(Myunique_ptr&lt;T,D&gt;&amp;lhs, Myunique_ptr&lt;T,D&gt;&amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(lhs.p, rhs.p);</span><br><span class="line">    swap(lhs.deleter, rhs.deleter);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">inline</span> Myunique_ptr&lt;T,D&gt;&amp;</span><br><span class="line">Myunique_ptr&lt;T,D&gt;::<span class="keyword">operator</span>=(Myunique_ptr &amp;&amp;mp)<span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;p != mp.p)</span><br><span class="line">    &#123;</span><br><span class="line">        deleter(p);</span><br><span class="line">        p = <span class="literal">nullptr</span>;</span><br><span class="line">        ::swap(*<span class="keyword">this</span>, mp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">inline</span> Myunique_ptr&lt;T,D&gt;&amp;</span><br><span class="line">Myunique_ptr&lt;T,D&gt;::<span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span> n)<span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        deleter(p);</span><br><span class="line">        p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">inline</span> T*</span><br><span class="line">Myunique_ptr&lt;T,D&gt;::release()</span><br><span class="line">&#123;</span><br><span class="line">    T* ret = p;</span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *i = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>);</span><br><span class="line">    Myunique_ptr&lt;<span class="keyword">int</span>&gt;p(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、模板实参推荐"><a href="#4、模板实参推荐" class="headerlink" title="4、模板实参推荐"></a>4、模板实参推荐</h3><h4 id="4-1、类型转换与模板实参推荐"><a href="#4-1、类型转换与模板实参推荐" class="headerlink" title="4.1、类型转换与模板实参推荐"></a>4.1、类型转换与模板实参推荐</h4><p>函数模板在传递实参时会根据实参生成对应参数的函数，但是我们需要注意一点就是只有有限的几种类型会应用于这些实参。</p>
<p>编译器通常不对实参进行类型转换，而是像上面说的生成新的对应参数的函数。</p>
<p>在类型转换中，能用于函数模板的有以下两种。</p>
<p>1.<code>const </code>转换：也就是非<code>const</code>类型的参数传递给<code>const</code>类型的形参，注意必须是引用或指针，如果不是引用或指针传递的就是拷贝。</p>
<p>2.数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。</p>
<p>其他如算术转换，派生类向基类的转换，用户定义的转换都不能用于函数模板。</p>
<p>总结：</p>
<p>将实参传递给代模板类型的参数时，能够自动类型转换的只有<code>const</code>转换及数组或函数到指针的转换。</p>
<p>如果想要传递不同的参数，则我们必须自己定义那种不同的模板类型。</p>
<p>如果函数模板的参数不是模板则可以正常进行转换。</p>
<h4 id="4-2、函数模板显式实参"><a href="#4-2、函数模板显式实参" class="headerlink" title="4.2、函数模板显式实参"></a>4.2、函数模板显式实参</h4><p>有些时候我们必须显示的指定一些模板的参数</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数中，我们返回是一个模板参数，在函数中，没有任何类型能推断出T1的类型，所以我们要显式指定 </p>
<p>我们提供显式模板实参的方式与定义类模板实例的方式相同，显式模板实参在尖括号中给出，位于函数名之后，实参列表之前。</p>
<p><code>auto val = sum&lt;long long&gt;(t1, t2);</code></p>
<p>显式模板参数按照从左到右的顺序和对应的模板参数匹配，只有尾部最右参数的显示模板实参才可以忽略，前提是他们可以从函数参数推断出来。</p>
<p>如果我们把上面的改为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">sum</span><span class="params">(T2, T1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>就必须显式的指定三个参数的类型 </p>
<p><code>auto val = sum&lt;long long , long ,int &gt;(t1, t2, t3);</code></p>
<h4 id="4-3、尾置返回类型与类型转换"><a href="#4-3、尾置返回类型与类型转换" class="headerlink" title="4.3、尾置返回类型与类型转换"></a>4.3、尾置返回类型与类型转换</h4><p>一些情况下，要求显式指定模板实参会给用户添加额外负担，且不会带来什么好处。</p>
<p>此时我们可以使用尾置返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">auto func(T Beg, T End)-&gt;decltype(*Beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(Beg+(End-Beg)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;svec = &#123;<span class="string">&quot;111&quot;</span>,<span class="string">&quot;222&quot;</span>,<span class="string">&quot;333&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func(svec.begin(), svec.end()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上述代码有一个限制，传参是迭代器，则我们返回的只能是元素的引用而不是元素。 </p>
<p>为了获取元素类型，可以使用标准库的类型转换</p>
<p>头文件<code>#include &lt;type_traits&gt;</code>  这个头文件常用于模板元程序设计。</p>
<p>但是类型转换模板在普通编程中也很有用</p>
<p>上面问题可以用<code>remove_reference</code>来解决</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">auto func(T Beg, T End)-&gt;</span><br><span class="line">      <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">decltype</span>(*Beg)&gt;::type;          <span class="comment">//因为是类型所以要加typename,前面说过,否则不能区分是类型还是变量</span></span><br></pre></td></tr></table></figure>

<p>模板类型<code>remove_reference</code>的<code>type</code>成员表示被引用的类型。 </p>
<p>还有其他的类型转换模板</p>
<p>标准类型转换模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="number">1.</span>remove_reference</span><br><span class="line">&lt;<span class="number">2.</span>add_const</span><br><span class="line">&lt;<span class="number">3.</span>add_lvalue_reference</span><br><span class="line">&lt;<span class="number">4.</span>add_rvalue_reference</span><br><span class="line">&lt;<span class="number">5.</span>remove_pointer</span><br><span class="line">&lt;<span class="number">6.</span>add_pointer</span><br><span class="line">&lt;<span class="number">7.</span>make_signed</span><br><span class="line">&lt;<span class="number">8.</span>make_unsigned</span><br><span class="line">&lt;<span class="number">9.</span>remove_extent</span><br><span class="line">&lt;<span class="number">10.</span>remove_all_extents</span><br></pre></td></tr></table></figure>

<p>其他的使用都和remove_reference类似。每个模板都有一个<code>type</code>的<code>public</code>成员表示类型。</p>
<p>注意有时<code>type</code>不是元素的类型，比如指针，type就不是指针类型而是指针指向的元素类型。</p>
<h4 id="4-4、函数指针和实参推荐"><a href="#4-4、函数指针和实参推荐" class="headerlink" title="4.4、函数指针和实参推荐"></a>4.4、函数指针和实参推荐</h4><p>我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时。编译器会用指针的类型来推断模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">fun</span><span class="params">(T,T)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>) = fun;</span><br></pre></td></tr></table></figure>

<p>那么p就指向了fun的int实例化版本。</p>
<p>当然也可以显式指定</p>
<p><code>fun&lt;int&gt;</code></p>
<p>注意：当参数是一个函数模板实例的地址时，程序上下文必须满则：对每个模板参数能唯一确定其类型或值。</p>
<h4 id="4-5、模板实参推断和引用"><a href="#4-5、模板实参推断和引用" class="headerlink" title="4.5、模板实参推断和引用"></a>4.5、模板实参推断和引用</h4><h5 id="4-5-1、从左值引用函数参数推断类型"><a href="#4-5-1、从左值引用函数参数推断类型" class="headerlink" title="4.5.1、从左值引用函数参数推断类型"></a>4.5.1、从左值引用函数参数推断类型</h5><p>当一个函数类型参数是普通的左值引用时，规定只能传递给它一个左值（一个变量或一个引用的表达式），实参可以是<code>const</code>类型也可以不是。</p>
<p>如果实参是<code>const</code>类型，T将会被推断是<code>const</code>类型</p>
<p>如果函数类型参数是<code>const&amp;T</code>时，我们可以传递任何类型的实参，一个对象，一个临时对象或者字面值常量。</p>
<h5 id="4-5-2、从右值引用函数参数推断类型"><a href="#4-5-2、从右值引用函数参数推断类型" class="headerlink" title="4.5.2、从右值引用函数参数推断类型"></a>4.5.2、从右值引用函数参数推断类型</h5><p>我们可以传递一个右值，推断规则类似左值引用。</p>
<p>左值不能绑定在右值引用上，但是有两个例外规则。</p>
<p>第一个：当我们将一个左值传递给函数的右值引用参数时，编译器推断模板类型参数为实参的左值引用类型。注意是引用。</p>
<p>比如传递给模板函数参数T &amp;&amp;一个int i,推断出来的类型就是int &amp;.</p>
<p>第二个：如果我们间接创建一个引用的引用就会形成引用折叠，引用折叠在大部分情况下会形成一个普通的左值引用，但是在右值引用的引用情况下</p>
<p>会生成右值引用。</p>
<p><code>X&amp; &amp;, X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成X&amp;</code></p>
<p><code>X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</code></p>
<p>注意：引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。</p>
<p>这两个规则导致了两个重要的结果：</p>
<p>1.如果一个函数参数是一个指向模板类型蚕食的右值引用，则它可以被绑定到一个左值上。</p>
<p>2.如果实参是一个左值，则推断出的模板实参类型是一个左值引用，且函数参数将被实例化一个左值引用参数。</p>
<p>注意：如果一个函数参数是指向模板参数类型的右值引用，则可以传递给它任何类型的实参，如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通</p>
<p>左值引用。</p>
<h5 id="4-5-3、编写接受右值引用参数的模板函数"><a href="#4-5-3、编写接受右值引用参数的模板函数" class="headerlink" title="4.5.3、编写接受右值引用参数的模板函数"></a>4.5.3、编写接受右值引用参数的模板函数</h5><p>使用右值引用的函数模板应该向我们之前所写的一样</p>
<p>定义两种。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可避免一些错误。 </p>
<p>总之：泛型模板编程要细心，时刻注意参数问题。</p>
<p>模板参数是右值引用，传递右值引用，推断出是T</p>
<p>模板参数是右值引用，传递左值，推断出是左值引用。</p>
<h4 id="4-6、理解std-move"><a href="#4-6、理解std-move" class="headerlink" title="4.6、理解std::move"></a>4.6、理解std::move</h4><p>标准库定义<code>std::move</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T &amp;&amp; t)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>std::move</code>的参数是<code>T &amp;&amp;t</code>,是一个指向模板类型的右值引用，通过引用折叠可以和任何类型的参数匹配。 </p>
<p>从一个左值<code>static_cast</code>到一个右值引用是允许的。</p>
<h4 id="4-7、转发"><a href="#4-7、转发" class="headerlink" title="4.7、转发"></a>4.7、转发</h4><p>某些函数需要将一个或多个实参连同类型传递给其他的函数，这种情况下我们需要保证实参的类型。</p>
<p>举个例子来说明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unility&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(F f, T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t1, t2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v1, <span class="keyword">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">20</span>;</span><br><span class="line">    fun(f, i, j);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//改进后</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T1&gt;(t1), <span class="built_in">std</span>::forward&lt;T2&gt;(t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个函数，在<code>fun</code>里面调用<code>f</code>，<code>f</code>第二个参数是一个引用，说明我们希望在<code>f</code> 函数中改变<code>j</code>的值，但是在<code>fun</code>传递参数的时候就发生了拷贝， </p>
<p>所以我们传递给<code>f </code>的参数也是一份拷贝，修改了拷贝实际上没有修改到j 的值。</p>
<p>改进有两个方面：</p>
<ol>
<li>参数变成右值引用</li>
</ol>
<p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。</p>
<p>引用类型中<code>const</code>是底层的，我们可以保证<code>const</code>属性，通过引用折叠我们可以保持翻转实参的左值/右值属性。</p>
<p>结论：如果一个函数参数是指向模板类型参数的右值引用， 它对应的实参的<code>const </code>属性和左值/右值属性得到保持。</p>
<ol start="2">
<li>使用<code>std::forward</code>：如果参数不是一个左值引用，返回右值，如果参数是一个左值引用，返回该返回的类型。</li>
</ol>
<p>头文件<code>#include &lt;utility&gt;</code></p>
<p>当传递一个右值引用时，我们知道右值引用也是一个左值表达式。在调用<code>g</code>时就会出错，不能将左值绑定到右值上。</p>
<p>我们可以使用一个<code>forward</code>的新标准库来传递参数，它能保持原始实参的类型。</p>
<p><code>forward</code>必须通过显式模板参数来调用。<code>forward</code>返回该显式实参类型的右值引用</p>
<p>通常情况下我们使用<code>forward</code>传递那些定义为模板类型参数的右值引用的函数参数，通过其返回类型上的引用折叠，<code>forward</code>可以保持给定实参的左值/右值属性</p>
<p>上面的改进后函数，如果实参是<code>T1</code>一个右值<code>int </code>传递<code>func</code>，那么T1推断出是int 类型，<code>std::forward&lt;T1&gt;</code>将<code>int </code>变为<code>int&amp;&amp;.</code></p>
<p>如果实参是一个左值， 通过引用折叠，T本身就是一个左值<code>int&amp;。</code></p>
<p><img src="https://zhuom-go.github.io/img/Template/3.png" alt="img"> </p>
<p>顺便贴一下cppman手册里的例子，方便理解</p>
<p><img src="https://zhuom-go.github.io/img/Template/4.png" alt="img"></p>
<p>第一个给<code>fn</code>传递<code>a</code>，<code>a</code>是一个左值，<code>fn</code>的形参是右值引用，前面说过给右值引用传递左值，会变成左值引用，<code>overloaded(x)</code>调用的是左值版本。</p>
<p><code>overloaded(std::forward&lt;T&gt;(x))``x</code>是一个左值引用时，返回一个左值引用，也掉用的是左值的<code>overloaded</code>。</p>
<p>第二个给<code>fn</code>传递0，0是一个右值，fn的形参是右值引用，T推断出是<code>int</code>类型，右值引用也是一个左值，所以调用左值版本，但是使用<code>std::forward</code>时，</p>
<p>上面说了<code>rvalue if argument is rvalue</code>，所以调用右值版本。<code>std::forward&lt;T&gt;(x)</code>返回一个右值。</p>
<h3 id="5、重载和函数模板"><a href="#5、重载和函数模板" class="headerlink" title="5、重载和函数模板"></a>5、重载和函数模板</h3><p>函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函数必须具有不同数量或类型的参数。</p>
<p>与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。</p>
<p>当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。我理解特例话指的是小众，比如两个模板都实例化出了适配的实例，第一个模板作用范围大（比如有<code>const</code>修饰，就可以作用<code>const</code>和<code>non-const</code>），第二个模板作用范围小，那么第二个模板产生的实例就是最特例化的版本。</p>
<p>对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。</p>
<p>在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</p>
<h3 id="6、可变参数模板（c-11）"><a href="#6、可变参数模板（c-11）" class="headerlink" title="6、可变参数模板（c++11）"></a>6、可变参数模板（c++11）</h3><p>一个可变参数就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与往常一样，编译器从函数的实参推断模板参数类型。对于一个可变参数模板，编译器还会推断包中参数的数目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp; ... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(rest) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">1.1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">&quot;ss&quot;</span>;</span><br><span class="line">    foo(i, d, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>result: 2 </code></p>
<p>定义就如同例子里面定义一样，sizeof…当我们需要知道包中有多少个元素的时候就可以使用sizeof…</p>
<h5 id="6-1、编写可变参数函数模板"><a href="#6-1、编写可变参数函数模板" class="headerlink" title="6.1、编写可变参数函数模板"></a>6.1、编写可变参数函数模板</h5><p>以前说过initializer_list定义一个可变数目参数的函数，但是类型是指定的。</p>
<p>当我们既不知道参数的数目和参数的类型时，可变参数函数是很有用的。</p>
<p>可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身。</p>
<p>通过例子来理解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> T&amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> T&amp;t)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> T&amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> print(os, rest...);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> T&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">1.1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">&quot;ss&quot;</span>;</span><br><span class="line">    print(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    print(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    print(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    print(<span class="built_in">std</span>::<span class="built_in">cout</span>, i, c, d, s) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zhuom-go.github.io/img/Template/5.png" alt="img"></p>
<p><strong>从打印逗号的情况我们可以看出最后一个调用的是两参版本。其他几次都调用的是三参版本</strong></p>
<p>是一个递归的执行过程，每次打印一个参数，包中就少一个参数，直到打印最后一个参数时，我们必须定义两参版本。</p>
<p>两参版本负责终止递归并打印初始调用中的最后一个实参。</p>
<p>注意：当定义可变参数版本的<code>print</code>时，非可变参数版本的声明必须在作用域中，否则，可变参数版本会无限递归。</p>
<p>​      好的做法是都在最开始声明。</p>
<h5 id="6-2、模板特例化（特化）"><a href="#6-2、模板特例化（特化）" class="headerlink" title="6.2、模板特例化（特化）"></a>6.2、模板特例化（特化）</h5><p>所谓模板特化就是针对模板特殊情况特殊处理。</p>
<p>模板实例化是在第一次使用时，编译器会按确定的类型生成对应的实例模板。</p>
<p>我们可以定义函数模板和类模板的特例化</p>
<p>特例化本质是一个模板，而非重载，所以特例化本质不影响函数匹配。</p>
<p>模板及其特例化应该声明到同一个头文件中，所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。</p>
<p>类模板部分特例化</p>
<p>注意：我们只能部分特例化类模板，而不能部分特例化函数模板。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中Static作用和使用方法</title>
    <url>/2020/11/18/C++%E4%B8%ADStatic%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1、什么是static"><a href="#1、什么是static" class="headerlink" title="1、什么是static?"></a>1、什么是static?</h3><p>​    static 是C++中很常用的修饰符，它被用来控制变量的存储方式和可见性。</p>
<a id="more"></a>

<h3 id="2、为什么要引入static"><a href="#2、为什么要引入static" class="headerlink" title="2、为什么要引入static?"></a>2、为什么要引入static?</h3><p>​     函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，大家知道，函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？  最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。</p>
<h3 id="3、什么时候用static"><a href="#3、什么时候用static" class="headerlink" title="3、什么时候用static?"></a>3、什么时候用static?</h3><p>​    需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。</p>
<h3 id="4、static的内部机制："><a href="#4、static的内部机制：" class="headerlink" title="4、static的内部机制："></a>4、static的内部机制：</h3><p>​    静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。<br>​    这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的main（）函数前的全局数据声明和定义处。<br>​     静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的“尺寸和规格”，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。<br>   static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态<br>数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。</p>
<h3 id="5、static的优势："><a href="#5、static的优势：" class="headerlink" title="5、static的优势："></a>5、static的优势：</h3><p>​     可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。</p>
<h3 id="6、引用静态数据成员时，采用如下格式："><a href="#6、引用静态数据成员时，采用如下格式：" class="headerlink" title="6、引用静态数据成员时，采用如下格式："></a>6、引用静态数据成员时，采用如下格式：</h3><p>​     &lt;类名&gt;::&lt;静态成员名&gt;<br>  如果静态数据成员的访问权限允许的话(即public的成员)，可在程序中，按上述格式来引用静态数据成员。</p>
<h3 id="7、注意事项："><a href="#7、注意事项：" class="headerlink" title="7、注意事项："></a>7、注意事项：</h3><p>   (1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。<br>   (2)不能将静态成员函数定义为虚函数。<br>   (3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。</p>
<p>   (4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X Window系统结合，同时也成功的应用于线程函数身上。<br>   (5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。<br>   (6)静态数据成员在&lt;定义或说明&gt;时前面加关键字static。<br>   (7)静态数据成员是静态存储的，所以必须对它进行初始化。<br>   (8)静态成员初始化与一般数据成员初始化不同:<br>   初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>   初始化时不加该成员的访问权限控制符private，public等；<br>   初始化时使用作用域运算符来标明它所属类；<br>    所以我们得出静态数据成员初始化的格式：<br>     &lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;<br>     (9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。 </p>
<p><strong>静态数据成员</strong></p>
<p>　　在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。</p>
<p>　　使用静态数据成员可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。</p>
<p>　　静态数据成员的使用方法和注意事项如下：</p>
<p>　　1、静态数据成员在定义或说明时前面加关键字static。</p>
<p>　　2、静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下：</p>
<p>　　　　&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</p>
<p>　　这表明：</p>
<p>   　 (1) 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。</p>
<p>　　(2) 初始化时不加该成员的访问权限控制符private，public等。</p>
<p>　　(3) 初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。</p>
<p>　　3、静态数据成员是静态存储的，它是静态生存期，必须对它进行初始化。</p>
<p>　　4、引用静态数据成员时，采用如下格式：</p>
<p>　　　&lt;类名&gt;::&lt;静态成员名&gt;</p>
<p>　　如果静态数据成员的访问权限允许的话(即public的成员)，可在程序中，按上述格式来引用静态数据成员。</p>
<p><strong>静态成员函数</strong></p>
<p>   　静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p>
<p>　　在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。</p>
<blockquote>
<p>下面看一个例子：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Point pt;</span><br><span class="line"> pt.init();</span><br><span class="line"> pt.output(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样编译是不会有任何错误的。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面这样看</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Point::output();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样编译会处错，错误信息：illegal call of non-static member function，为什么？</span></span><br><span class="line"><span class="comment">//因为在没有实例化一个类的具体对象时，类是没有被分配内存空间的。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>好的再看看下面的例子:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Point::init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这时编译就不会有错误，因为在类的定义时，它静态数据和成员函数就有了它的内存区，它不属于类的任何一个具体对象。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>好的再看看下面的例子:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> x = <span class="number">0</span>;</span><br><span class="line"> y = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> x;</span><br><span class="line"> <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Point::init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*编译出错：</span></span><br><span class="line"><span class="comment">illegal reference to data member &#x27;Point::x&#x27; in a static member function</span></span><br><span class="line"><span class="comment">illegal reference to data member &#x27;Point::y&#x27; in a static member function</span></span><br><span class="line"><span class="comment">在一个静态成员函数里错误的引用了数据成员，</span></span><br><span class="line"><span class="comment">还是那个问题，静态成员（函数），不属于任何一个具体的对象，那么在类的具体对象声明之前就已经有了内存区，</span></span><br><span class="line"><span class="comment">而现在非静态数据成员还没有分配内存空间，那么这里调用就错误了，就好像没有声明一个变量却提前使用它一样。</span></span><br><span class="line"><span class="comment">也就是说在静态成员函数中不能引用非静态的成员变量。*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>好的再看看下面的例子:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> x = <span class="number">0</span>;</span><br><span class="line"> y = <span class="number">0</span>;</span><br><span class="line"> init(); </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> x;</span><br><span class="line"> <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Point::init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//好的，这样就不会有任何错误。这最终还是一个内存模型的问题，</span></span><br><span class="line"><span class="comment">//任何变量在内存中有了自己的空间后，在其他地方才能被调用，否则就会出错。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>好的再看看下面的例子:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> x = <span class="number">0</span>;</span><br><span class="line"> y = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Point::init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*编译：</span></span><br><span class="line"><span class="comment">Linking...</span></span><br><span class="line"><span class="comment">test.obj : error LNK2001: unresolved external symbol &quot;private: static int Point::y&quot; </span></span><br><span class="line"><span class="comment">test.obj : error LNK2001: unresolved external symbol &quot;private: static int Point::x&quot; </span></span><br><span class="line"><span class="comment">Debug/Test.exe : fatal error LNK1120: 2 unresolved externals</span></span><br><span class="line"><span class="comment">执行 link.exe 时出错.</span></span><br><span class="line"><span class="comment">可以看到编译没有错误，连接错误，这又是为什么呢？*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是因为静态的成员变量要进行初始化，可以这样：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> x = <span class="number">0</span>;</span><br><span class="line"> y = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Point::x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Point::y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Point::init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在静态成员数据变量初始化之后就不会出现编译错误了。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>再看看下面的代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> x = <span class="number">0</span>;</span><br><span class="line"> y = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译没有错误，为什么？</span></span><br><span class="line"><span class="comment">//即使他们没有初始化，因为我们没有访问x，y，所以编译不会出错。 </span></span><br></pre></td></tr></table></figure>

<p>C++会区分两种类型的成员函数：静态成员函数和非静态成员函数。这两者之间的一个重大区别是，静态成员函数不接受隐含的<em>this</em>自变量。所以，它就无法访问自己类的非静态成员。</p>
<p>在某些条件下，比如说在使用诸如pthread（它不支持类）此类的多线程库时，就必须使用静态的成员函数，因为其地址同C语言函数的地址兼容。这种铜限制就迫使程序员要利用各种解决办法才能够从静态成员函数访问到非静态数据成员。</p>
<p>第一个解决办法是声明类的所有数据成员都是静态的。运用这种方式的话，静态的成员函数就能够直接地访问它们，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> Singleton * <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Singleton * p;</span><br><span class="line"> <span class="keyword">static</span> Lock lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton * <span class="title">Singleton::instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> lock.getlock(); <span class="comment">// fine, lock is static</span></span><br><span class="line"> <span class="keyword">if</span> (!p)</span><br><span class="line"> p=<span class="keyword">new</span> Singleton;</span><br><span class="line"> lock.unlock();</span><br><span class="line"> <span class="keyword">return</span> p;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这种解决方法不适用于需要使用非静态数据成员的类。</p>
<p>访问非静态数据成员</p>
<p>将参照传递给需要考量的对象能够让静态的成员函数访问到对象的非静态数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(A &amp; obj)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getval</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//non-static member function</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>静态成员函数func()会使用参照<em>obj</em>来访问非静态成员<em>val</em>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">voidA::func(A &amp; obj)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> n = obj.getval();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>将一个参照或者指针作为静态成员函数的自变量传递，就是在模仿自动传递非静态成员函数里<em>this</em>自变量这一行为。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>Static</tag>
      </tags>
  </entry>
  <entry>
    <title>initializer_list的含义</title>
    <url>/2020/11/18/initializer_list%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<h3 id="1、统一初始化"><a href="#1、统一初始化" class="headerlink" title="1、统一初始化"></a>1、统一初始化</h3><h4 id="1-1、几种初始化方式"><a href="#1-1、几种初始化方式" class="headerlink" title="1.1、几种初始化方式"></a>1.1、几种初始化方式</h4><p>先来看一下，C++用于的几种初始化的方式，以int为例：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">小括号：<span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;             <span class="comment">//C++98</span></span><br><span class="line">等号：<span class="keyword">int</span> x = <span class="number">0</span>;              <span class="comment">//C++98</span></span><br><span class="line">大括号：<span class="keyword">int</span> x&#123;<span class="number">0</span>&#125;;             <span class="comment">//C++98成功，C++11成功</span></span><br><span class="line">等号和大括号：<span class="keyword">int</span> x = &#123;<span class="number">0</span>&#125;;    <span class="comment">//C++98失败，C++11成功</span></span><br></pre></td></tr></table></figure>

<p>可以看出，C++拥有较多的初始化方式，如此便引申出一种统一初始化的方式。</p>
<h4 id="1-2、统一初始化方式"><a href="#1-2、统一初始化方式" class="headerlink" title="1.2、统一初始化方式"></a>1.2、统一初始化方式</h4><p><code>统一初始化</code>，也叫做<code>大括号初始化</code>。顾名思义，是使用大括号进行初始化的方式。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> values[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; cities&#123;</span><br><span class="line">    <span class="string">&quot;Beijing&quot;</span>, <span class="string">&quot;Nanjing&quot;</span>, <span class="string">&quot;Shanghai&quot;</span>, <span class="string">&quot;Hangzhou&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; c&#123;<span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实是利用一个事实：<strong>编译器看到{t1, t2, …,  tn}便会做出一个initializer_list，它关联到一个array&lt;T,  n&gt;。调用构造函数的时候，该array内的元素会被编译器分解逐一传给函数。但若函数的参数就是initializer_list，则不会逐一分解，而是直接调用该参数的函数</strong>。</p>
<p>例如：vector类型的cities，由于采用{}进行初始化，会形成一个initializer_list，它会关联到一个array&lt;string,  4&gt;。调用vector构造函数时，发现正好有一个接收initializer_list的参数，于是直接调用构造函数。但是complex类型的c，就没有以initializer_list为参数的构造函数，于是在初始化的时候，只能从array中将元素逐一传递给构造函数进行初始化。</p>
<p><strong>所有的标准容器的构造函数都有以initializer_list为参数的构造函数</strong>。</p>
<h3 id="2、initializer-list"><a href="#2、initializer-list" class="headerlink" title="2、initializer_list"></a>2、initializer_list</h3><h4 id="2-1、简单用法"><a href="#2-1、简单用法" class="headerlink" title="2.1、简单用法"></a>2.1、简单用法</h4><p>使用<code>initizlizer_list</code>的最广泛的使用就是：<strong>不定长度同类型参数的情况</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> iter = vals.begin(); iter != vals.end(); ++iter)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  print(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于initizlizer_list，可以利用<code>iterator</code>来对包含的元素进行遍历来完成所需的一些操作。</p>
<h4 id="2-2、构造函数的匹配"><a href="#2-2、构造函数的匹配" class="headerlink" title="2.2、构造函数的匹配"></a>2.2、构造函数的匹配</h4><p>当initizlizer_list做参数与其他参数的函数形成重载关系的时候，如何进行函数的选择呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    P() &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    P(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P(int, int) &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    P(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vars) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P(initializer_list) &quot;</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> a : vars)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">P <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;                     <span class="comment">// P(int, int) 1 2</span></span><br><span class="line">  P p2&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;                     <span class="comment">// P(initializer_list) 1 2</span></span><br><span class="line">  P p3&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;                  <span class="comment">// P(initializer_list) 1 2 3</span></span><br><span class="line">  P p4 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;                  <span class="comment">// P(initializer_list) 1 2</span></span><br><span class="line">  P p5&#123;&#125;;                         <span class="comment">// P</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，p1使用小括号进行初始化，直接调用第一个构造函数，这是没有什么可犹豫的。p2、p3、p4都使用的大括号进行初始化，会形成一个initializer_list，而且<strong>正好存在以该类型为参数的构造函数，直接调用该构造函数直接进行初始化</strong>。p5<strong>尽管使用的是大括号进行初始化，但使用的是空大括号，表示没有参数，会调用无参构造函数</strong>。</p>
<p>如果，P类中仅仅只有第一个构造函数，那么情形又会变成什么呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    P(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;P(int, int) &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">P <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;                     <span class="comment">// P(int, int) 1 2</span></span><br><span class="line">  P p2&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;                     <span class="comment">// P(int, int) 1 2</span></span><br><span class="line">  P p3&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;                  <span class="comment">// Error 出错</span></span><br><span class="line">  P p4 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;                  <span class="comment">// P(int, int) 1 2</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时由于没有以initializer_list类型为参数的构造函数，p2、p4内的元素会将会<strong>被拆解，逐一传递给构造函数进行初始化</strong>。但是，p3由于元素的个数为3个，与构造函数的参数数量不同，不可以调用。</p>
<p>总结下，initializer_list与重载构造函数的关系：</p>
<ol>
<li>当构造函数形参中不带initializer_list时，小括号和大括号的意义没有区别；</li>
<li>如果构造函数中<strong>带有initializer_list形参，采用大括号初始化语法会强烈优先匹配带有initializer_list形参的重载版本，而其他更精确匹配的版本可能没有机会被匹配</strong>；</li>
<li><strong>空大括号构造一个对象时，表示没有参数(而不是空的initializer_list对象)，因此，会匹配默认的无参构造函数</strong>，而不是匹配initializer_list形参的版本的构造函数；</li>
<li>拷贝构造函数和移动构造函数也可能被带有initializer_list形参的构造函数劫持。</li>
</ol>
<h4 id="2-3、源码分析"><a href="#2-3、源码分析" class="headerlink" title="2.3、源码分析"></a>2.3、源码分析</h4><p>下面通过对initizlizer_list的源码，分析来探究其深层次的原理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">initializer_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _E value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _E&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _E&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _E* iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _E* const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  iterator _M_array;</span><br><span class="line">  size_type _M_len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The compiler can call a private constructor.</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">(const_iterator __a, size_type __l)</span></span></span><br><span class="line">  : _M_array(__a), _M_len(__l) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line">  : _M_array(0), _M_len(0) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_len; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_array; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> begin() + size(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到initializer_list内部存储了两个变量：**_M_array(迭代器变量)和_M_len(长度)**。当调用构造函数的时候，就会将这两个变量进行初始化赋值。那这两个变量是怎么来的呢？</p>
<p>其实，<strong>当用{}进行初始化的时候，首先会创建一个array，并将初始化元素存放起来。然后，调用initializer_list的构造函数，用array首元素的迭代器和array的元素个数，进行初始化</strong>。</p>
<p>如果仔细看会发现，initializer_list构造函数是private类型的，按道理来说，是没有办法外部调用的！但是，在源码中也注明了，编译器可以调用该private构造函数。</p>
<p>除此之外，还有如下几个注意点：</p>
<ol>
<li>initializer_list是一个轻量级的容器类型，内部定义了iterator等容器必需的概念。其中有3个成员接口：size()、begin()和end()。遍历时取得的迭代器是只读的，无法修改其中的某一个元素的值；</li>
<li>对于initializer_list而言，它可以接收任意长度的初始化列表，但要求**元素必须是同种类型T(或可转换为T)**；</li>
<li><strong>Initializer_list内部并不负责保存初始化列表中的元素拷贝，仅仅是列表中元素的引用而己</strong>。因此，<strong>通过过拷贝构造对象与原对象共享列表中的元素空间</strong>。也就是说，<strong>initializer_list的内部并没有内含该array的内容，仅仅是拥有指向array的迭代器</strong>。如果拷贝构造或者拷贝赋值的话，array的内容只有一份，但有两份迭代器指向。如果对initializer_list对象copy一个副本，默认是浅拷贝，此时两个对象指向同一个array。这是危险的。</li>
</ol>
<p>也就是说，下面的情形是不允许的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;a, b&#125;;      <span class="comment">//由于initializer_list保存的是对象的引用，但a与b是局部变量在</span></span><br><span class="line">                      <span class="comment">//func返回后会被释放，initializer_list内部会存在空悬指针！危险！</span></span><br><span class="line">                      <span class="comment">//正确的做法可以将返回值改为保存副本的容器，如vector&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意下面s1、 s2、s3和s4均共享元素空间</span></span><br><span class="line"><span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; s1 = &#123; <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; s2 = s1;</span><br><span class="line"><span class="function"><span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">s3</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; s4;</span><br><span class="line">s4 = s1;</span><br></pre></td></tr></table></figure>

<h4 id="2-4、其他"><a href="#2-4、其他" class="headerlink" title="2.4、其他"></a>2.4、其他</h4><p>之前版本的C++，min、max只可以进行两个数之间的比较，但是有了initializer_list之后，现在支持如下的比较：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::max(&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;);</span><br><span class="line"><span class="built_in">std</span>::min(&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>这是因为，源码中增加了如下的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _Tp <span class="title">max</span><span class="params">(<span class="built_in">initializer_list</span>&lt;_Tp&gt; __l)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> *<span class="built_in">std</span>::max_element(__l.begin(), __l.end()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _Tp <span class="title">min</span><span class="params">(<span class="built_in">initializer_list</span>&lt;_Tp&gt; __l)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> *<span class="built_in">std</span>::min_element(__l.begin(), __l.end()); &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>initializer_list</tag>
      </tags>
  </entry>
  <entry>
    <title>set自定义排序</title>
    <url>/2020/11/18/set%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>set <a href="http://www.cplusplus.com/reference/set/set/">c++ reference</a>是c++中的一种容器，set可以用二叉树搜索树实现，set有两个特点：</p>
<ol>
<li><p>set中的元素不允许重复；</p>
</li>
<li><p>set内部会维护一个严格的弱排序关系。<a id="more"></a></p>
</li>
</ol>
<p>上述两个特点实际上都依赖set的compare函数，compare函数判断两个元素相等就是相等，与元素本身没有直接的关系。</p>
<h3 id="1、默认定义了compare函数"><a href="#1、默认定义了compare函数" class="headerlink" title="1、默认定义了compare函数"></a>1、默认定义了compare函数</h3><p>利用set内部默认的compare函数，可以将整数从小到大排序，将字符串按字母序进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[] = &#123;<span class="number">20</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s1</span><span class="params">(a, a + <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s1.cbegin(); it != s1.cend(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">string</span> b[] = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;strawberry&quot;</span>&#125;;</span><br><span class="line">	<span class="function"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">s2</span><span class="params">(b, b + <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s2.cbegin(); it != s2.cend(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span></span><br><span class="line">apple banana orange pear strawberry</span><br></pre></td></tr></table></figure>

<h3 id="2、自定义排序函数"><a href="#2、自定义排序函数" class="headerlink" title="2、自定义排序函数"></a>2、自定义排序函数</h3><p>可以通过定义结构体(或类)，并在其中重载()运算符，来自定义排序函数。然后，在定义set的时候，将结构体加入其中例如如下代码中的set&lt;int, intComp&gt;和set&lt;string, strComp &gt;。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intComp</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; lhs, <span class="keyword">const</span> <span class="keyword">int</span>&amp; rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lhs &gt; rhs;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">strComp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> str1.length() &lt; str2.length();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">	set&lt;int, intComp&gt; s1(a, a + 5);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s1.cbegin(); it != s1.cend(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">string</span> b[] = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;strawberry&quot;</span>&#125;;</span><br><span class="line">	set&lt;string, strComp &gt; s2(b, b + 5);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = s2.cbegin(); it != s2.cend(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">50</span> <span class="number">40</span> <span class="number">30</span> <span class="number">20</span> <span class="number">10</span></span><br><span class="line">pear apple banana strawberry</span><br></pre></td></tr></table></figure>

<p>从上述程序段的输出可见，定义整型的比较函数后，输出数字按从大到小排序。定义字符串的比较函数为比较字符串的长度，输出字符串则按长度从小到大排序，其中并未出现orange了，因为banana的长度是6，而orange的长度也是6，set的构造函数认为orange与banana相同，而orange出现在后，因此不会有orange.</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>类类型转换</title>
    <url>/2020/11/17/C++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%EF%BC%9A%E5%B0%86%E5%BD%93%E5%89%8D%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>转换构造函数能够将其它类型转换为当前类类型（例如将 double 类型转换为 Complex 类型），但是不能反过来将当前类类型转换为其它类型（例如将 Complex 类型转换为 double 类型）。<a id="more"></a></p>
<p><a href="http://c.biancheng.net/cplus/">C++</a> 提供了类型转换函数（Type conversion function）来解决这个问题。类型转换函数的作用就是将当前类类型转换为其它类型，它只能以成员函数的形式出现，也就是只能出现在类中。</p>
<p> 类型转换函数的语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">   <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">   <span class="keyword">return</span> data;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>operator 是 C++ 关键字，type 是要转换的目标类型，data 是要返回的 type 类型的数据。</p>
<p> 因为要转换的目标类型是 type，所以返回值 data 也必须是 type 类型。既然已经知道了要返回 type  类型的数据，所以没有必要再像普通函数一样明确地给出返回值类型。这样做导致的结果是：类型转换函数看起来没有返回值类型，其实是隐式地指明了返回值类型。</p>
<p> 类型转换函数也没有参数，因为要将当前类的对象转换为其它类型，所以参数不言而喻。实际上编译器会把当前对象的地址赋值给 this <a href="http://c.biancheng.net/c/80/">指针</a>，这样在函数体内就可以操作当前对象了。关于 this 的原理请猛击《<a href="http://c.biancheng.net/view/2226.html">C++ this指针详解</a>》。</p>
<p> 【示例】为 Complex 类添加类型转换函数，使得 Complex 类型能够转换为 double 类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">  Complex(): m_real(<span class="number">0.0</span>), m_imag(<span class="number">0.0</span>)&#123; &#125;;   </span><br><span class="line">  Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag): m_real(real), m_imag(imag)&#123; &#125;;</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">  <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c);    </span><br><span class="line">  <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2);    </span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数private:    </span></span><br><span class="line">  <span class="keyword">double</span> m_real;  <span class="comment">//实部    </span></span><br><span class="line">  <span class="keyword">double</span> m_imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line">  <span class="comment">//重载&gt;&gt;运算符</span></span><br><span class="line">  ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, Complex &amp;c)</span><br><span class="line">  &#123;   </span><br><span class="line">    out &lt;&lt; c.m_real &lt;&lt;<span class="string">&quot; + &quot;</span>&lt;&lt; c.m_imag &lt;&lt;<span class="string">&quot;i&quot;</span>;;    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//重载+运算符</span></span><br><span class="line">  Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;c1, <span class="keyword">const</span> Complex &amp;c2)</span><br><span class="line">  &#123;    </span><br><span class="line">    Complex c;   </span><br><span class="line">    c.m_real = c1.m_real + c2.m_real;  </span><br><span class="line">    c.m_imag = c1.m_imag + c2.m_imag;    </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;    </span><br><span class="line">  <span class="keyword">double</span> f = c1;  <span class="comment">//相当于 double f = Complex::operator double(&amp;c1);   </span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;f = &quot;</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  f = <span class="number">12.5</span> + c1 + <span class="number">6</span>;  <span class="comment">//相当于 f = 12.5 + Complex::operator double(&amp;c1) + 6;    </span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;f = &quot;</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="keyword">int</span> n = Complex(<span class="number">43.2</span>, <span class="number">9.3</span>);  <span class="comment">//先转换为 double，再转换为 int    </span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;n = &quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f = <span class="number">24.6</span></span><br><span class="line">f = <span class="number">43.1</span></span><br><span class="line">n = <span class="number">43</span></span><br></pre></td></tr></table></figure>

<p> 本例中，类型转换函数非常简单，就是返回成员变量 m_real 的值，所以建议写成 inline 的形式。</p>
<p> 类型转换函数和运算符的重载非常相似，都使用 operator 关键字，因此也把类型转换函数称为类型转换运算符。</p>
<blockquote>
<p>关于类型转换函数的说明</p>
</blockquote>
<ol>
<li><p><code>type </code>可以是内置类型、类类型以及由 <code>typedef </code>定义的类型别名，任何可作为函数返回类型的类型（void 除外）都能够被支持。一般而言，不允许转换为数组或函数类型，转换为指针类型或引用类型是可以的。</p>
<ol start="2">
<li><p>类型转换函数一般不会更改被转换的对象，所以通常被定义为 const 成员。</p>
</li>
<li><p>类型转换函数可以被继承，可以是虚函数。</p>
</li>
<li><p>一个类虽然可以有多个类型转换函数（类似于函数重载），但是如果多个类型转换函数要转换的目标类型本身又可以相互转换（类型相近），那么有时候就会产生二义性。以 Complex 类为例，假设它有两个类型转换函数：</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//转换为double类型</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">int</span>)m_real; &#125;  <span class="comment">//转换为int类型</span></span><br></pre></td></tr></table></figure>

<p>那么下面的写法就会引发二义性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">24.6</span>, <span class="number">100</span>)</span></span>;<span class="keyword">float</span> f = <span class="number">12.5</span> + c1;</span><br></pre></td></tr></table></figure>

<p>编译器可以调用 operator double() 将 c1 转换为 double 类型，也可以调用 operator int() 将 c1  转换为 int 类型，这两种类型都可以跟 12.5 进行加法运算，并且从 Complex 转换为 double 与从 Complex 转化为  int 是平级的，没有谁的优先级更高，所以这个时候编译器就不知道该调用哪个函数了，干脆抛出一个二义性错误，让用户解决。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>转换</tag>
      </tags>
  </entry>
  <entry>
    <title>左值与右值</title>
    <url>/2020/11/16/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC/</url>
    <content><![CDATA[<p>右值引用应该是<code>C++11</code>引入的一个非常重要的技术，因为它是移动语义（Move semantics）与完美转发（Perfect forwarding）的基石：<a id="more"></a></p>
<ul>
<li><strong>移动语义</strong>：将内存的所有权从一个对象转移到另外一个对象，高效的移动用来替换效率低下的复制，对象的移动语义需要实现移动构造函数（move constructor）和移动赋值运算符（move assignment operator）。</li>
<li><strong>完美转发</strong>：定义一个函数模板，该函数模板可以接收任意类型参数，然后将参数转发给其它目标函数，且保证目标函数接受的参数其类型与传递给模板函数的类型相同。</li>
</ul>
<h3 id="1、左值与右值"><a href="#1、左值与右值" class="headerlink" title="1、左值与右值"></a>1、左值与右值</h3><p>在讲解右值引用之前，你必须首先要区分两个概念：左值与右值。但是精确讲解清楚这两个概念并不容易。首先，你要清楚左值与右值是C++中表达式的属性，在<code>C++11</code>中，每个表达式有两个属性：类型（type，除去引用特性，用于类型检查）和值类型（value category，用于语法检查，比如一个表达式结果是否能被赋值）。值类型包括3个基本类型：<code>lvalue</code>、<code>prvalue</code>与<code>xrvalue</code>。后两者又统称为<code>rvalue</code>。<code>lvalue</code>我们称为左值，你可以将左值看成是一个可以获取地址的量，它可以用来标识一个对象或函数。<code>rvalue</code>称为右值，你可以认为所有不是左值的量就是右值，这是最简单的解释。要准确区分出右值中的<code>prvalue</code>和<code>xrvalue</code>并不容易：大概前者就是纯粹的右值，比如字面量，后者指的是可以被重用的临时对象。如果你感兴趣，你可以访问<a href="https://link.zhihu.com/?target=http://en.cppreference.com/w/cpp/language/value_category">cppreference</a>去细究。但是，你只要能够区分开左值与右值就够了。</p>
<h3 id="2、左值引用"><a href="#2、左值引用" class="headerlink" title="2、左值引用"></a>2、左值引用</h3><p>在<code>C++11</code>之前就已经有了左值引用，有时候我们简称为引用，其语法很简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; rx = x;   <span class="comment">// 定义引用时必须初始化</span></span><br></pre></td></tr></table></figure>

<p>但是引用也分为const引用与non-const引用，对于non-const引用，其只能用non-const左值来初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; rx1 = x;   <span class="comment">// non-const引用可以被non-const左值初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; rx2 = y;  <span class="comment">// 非法：non-const引用不能被const左值初始化</span></span><br><span class="line"><span class="keyword">int</span>&amp; rx3 = <span class="number">10</span>;      <span class="comment">// 非法：non-const引用不能被右值初始化</span></span><br></pre></td></tr></table></figure>

<p>但是const引用限制就少了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx1 = x;   <span class="comment">// const引用可以被non-const左值初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx2 = cx;  <span class="comment">// const引用可以被const左值初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx3 = <span class="number">9</span>;   <span class="comment">// const引用可以被右值初始化</span></span><br></pre></td></tr></table></figure>

<p>理解上面并不难，因为你只要想着这样初始化不会造成矛盾就好了，特别注意的是const左值引用可以接收右值（这点很重要，后面会说）。</p>
<h3 id="3、右值引用"><a href="#3、右值引用" class="headerlink" title="3、右值引用"></a>3、右值引用</h3><p><code>C++11</code>以前，右值被认为是无用的资源，所以在<code>C++11</code>中引入了右值引用，就是为了重用右值。定义右值引用需要使用<code>&amp;&amp;</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; rrx = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>

<p>右值引用一定不能被左值所初始化，只能用右值初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>;    <span class="comment">// 左值</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; rrx1 = x;   <span class="comment">// 非法：右值引用无法被左值初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; rrx2 = x;  <span class="comment">// 非法：右值引用无法被左值初始化</span></span><br></pre></td></tr></table></figure>

<p>那么为什么呢？因为右值引用的目的是为了延长用来初始化对象的生命周期，对于左值，其生命周期与其作用域有关，你没有必要去延长，这是我的理解。既然是延长，那么就出现了下面的情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>;   <span class="comment">// 左值</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; rx = x * <span class="number">2</span>;  <span class="comment">// x*2的结果是一个右值，rx延长其生命周期</span></span><br><span class="line"><span class="keyword">int</span> y = rx + <span class="number">2</span>;   <span class="comment">// 因此你可以重用它：42</span></span><br><span class="line">rx = <span class="number">100</span>;         <span class="comment">// 一旦你初始化一个右值引用变量，该变量就成为了一个左值，可以被赋值</span></span><br></pre></td></tr></table></figure>

<p>这点很重要，初始化之后的右值引用将变成一个左值，如果是non-const还可以被赋值！</p>
<p>右值引用还可以用于函数参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收左值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; lref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;l-value reference\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收右值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp;&amp; rref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;r-value reference\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    fun(x);   <span class="comment">// output: l-value reference</span></span><br><span class="line">    fun(<span class="number">10</span>);  <span class="comment">// output: r-value reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，函数参数要区分开右值引用与左值引用，这是两个不同的重载版本。还有，如果你定义了下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; clref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;l-value const reference\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是其实它不仅可以接收左值，而且可以接收右值（如果你没有提供接收右值引用的重载版本）。</p>
<h3 id="4、移动语义"><a href="#4、移动语义" class="headerlink" title="4、移动语义"></a>4、移动语义</h3><p>有了右值引用的概念，就可以理解移动语义了。前面说过，一个对象的移动语义的实现是通过移动构造函数与移动赋值运算符来实现的。所以，为了理解移动语义，我们从一个对象出发，下面创建一个动态数组类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DynamicArray</span><span class="params">(<span class="keyword">int</span> size)</span> :</span></span><br><span class="line"><span class="function">        m_size</span>&#123; size &#125;, m_array&#123; <span class="keyword">new</span> T[size] &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor: dynamic array is created!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~DynamicArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor: dynamic array is destroyed!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    DynamicArray(<span class="keyword">const</span> DynamicArray&amp; rhs) :</span><br><span class="line">        m_size&#123; rhs.m_size &#125;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        m_array = <span class="keyword">new</span> T[m_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_size; ++i)</span><br><span class="line">            m_array[i] = rhs.m_array[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy constructor: dynamic array is created!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制赋值操作符</span></span><br><span class="line">    DynamicArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DynamicArray&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Copy assignment operator is called\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line"></span><br><span class="line">        m_size = rhs.m_size;</span><br><span class="line">        m_array = <span class="keyword">new</span> T[m_size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_size; ++i)</span><br><span class="line">            m_array[i] = rhs.m_array[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不进行边界检查</span></span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_size; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_array;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们通过在堆上动态分配内存来实现动态数组类，类中实现复制构造函数、复制赋值操作符以及索引操作符。假如我们定义一个生产动态数组的工厂函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产int动态数组的工厂函数</span></span><br><span class="line"><span class="function">DynamicArray&lt;<span class="keyword">int</span>&gt; <span class="title">arrayFactor</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">DynamicArray&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(size)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们用下面的代码进行测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        DynamicArray&lt;<span class="keyword">int</span>&gt; arr = arrayFactor(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Constructor: dynamic <span class="built_in">array</span> is created!</span><br><span class="line">Copy constructor: dynamic <span class="built_in">array</span> is created!</span><br><span class="line">Destructor: dynamic <span class="built_in">array</span> is destroyed!</span><br><span class="line">Destructor: dynamic <span class="built_in">array</span> is destroyed!</span><br></pre></td></tr></table></figure>

<p>此时，我们来解读这个输出。首先，你调用arrayFactor函数，内部创建了一个动态数组，所以普通构造函数被调用。然后将这个动态数组返回，但是这个对象是函数内部的，函数外是无法获得的，所以要生成一个临时对象，然后用这个动态数组初始化，函数最终返回的是临时对象。我们知道这个动态数组即将消亡，所以其是右值，那么在构建临时对象时，会调用复制构造函数（没有右值的版本，但是右值可以传递给const左值引用参数）。但是问题又来了，因为你返回的这个临时对象又拿去初始化另外一个对象<code>arr</code>，当然调用也是复制构造函数。调用两次复制构造函数完全没有必要，编译器也会这么想，所以将其优化：直接拿函数内部创建的动态数组去初始化<code>arr</code>。所以仅有一次复制构造函数被调用，但是一旦完成<code>arr</code>的创建，那个动态数组对象就被析构了。最后<code>arr</code>离开其作用域被析构。我们看到编译器尽管做了优化，但是还是导致对象被创建了两次，函数内部创建的动态数组仅仅是一个中间对象，用完后就被析构了，有没有可能直接将其申请的空间直接转移到<code>arr</code>，那么资源得以重用，实际上只用申请一份内存。但是问题的关键是复制构造函数执行的是复制，不是转移，无法实现这样的功能。此时，你需要移动构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ...其它省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    DynamicArray(DynamicArray&amp;&amp; rhs) :</span><br><span class="line">        m_size&#123; rhs.m_size &#125;, m_array&#123;rhs.m_array&#125;</span><br><span class="line">    &#123;</span><br><span class="line">        rhs.m_size = <span class="number">0</span>;</span><br><span class="line">        rhs.m_array = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move constructor: dynamic array is moved!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值操作符</span></span><br><span class="line">    DynamicArray&amp; <span class="keyword">operator</span>=(DynamicArray&amp;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move assignment operator is called\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_array;</span><br><span class="line">        m_size = rhs.m_size;</span><br><span class="line">        m_array = rhs.m_array;</span><br><span class="line">        rhs.m_size = <span class="number">0</span>;</span><br><span class="line">        rhs.m_array = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面是移动构造函数与移动赋值操作符的实现，相比复制构造函数与复制赋值操作符，前者没有再分配内存，而是实现内存所有权转移。那么测试相同的代码，其结果是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Constructor: dynamic <span class="built_in">array</span> is created!</span><br><span class="line">Move constructor: dynamic <span class="built_in">array</span> is moved!</span><br><span class="line">Destructor: dynamic <span class="built_in">array</span> is destroyed!</span><br><span class="line">Destructor: dynamic <span class="built_in">array</span> is destroyed!</span><br></pre></td></tr></table></figure>

<p>可以看到，调用的是移动构造函数，那么函数内部申请的动态数组直接被转移到<code>arr</code>。从而减少了一份相同内存的申请与释放。注意析构函数被调用两次，这是因为尽管内部进行了内存转移，但是临时对象依然存在，只不过第一次析构函数析构的是一个<code>nullptr</code>，这不会对程序有影响。其实通过这个例子，我们也可以看到，一旦你已经自己创建了复制构造函数与复制赋值运算符后，编译器不会创建默认的移动构造函数和移动赋值运算符，这点要注意。最好的话，这个4个函数一旦自己实现一个，就应该养成实现另外3个的习惯。</p>
<p>这就是移动语义，用移动而不是复制来避免无必要的资源浪费，从而提升程序的运行效率。其实在<code>C++11</code>中，<code>STL</code>的容器都实现了移动构造函数与移动赋值运算符，这将大大优化<code>STL</code>容器。</p>
<h3 id="5、std-move"><a href="#5、std-move" class="headerlink" title="5、std::move"></a>5、std::move</h3><p>移动语义前面已经介绍了，我们知道对象的移动语义的实现是依靠移动构造函数和移动赋值操作符。但是前提是你传入的必须是右值，但是有时候你需要将一个左值也进行移动语义（因为你已经知道这个左值后面不再使用），那么就必须提供一个机制来将左值转化为右值。在<code>C++</code>中，<code>std::move</code>就是专为此而生，看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = v1;             <span class="comment">// 此时调用复制构造函数，v2是v1的副本</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3 = <span class="built_in">std</span>::move(v1);  <span class="comment">// 此时调用移动构造函数，v3与v1交换：v1为空，v3为&#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们通过<code>std::move</code>将<code>v1</code>转化为右值，从激发<code>v3</code>的移动构造函数，实现移动语义。</p>
<p><code>C++</code>中利用<code>std::move</code>实现移动语义的一个典型函数是<code>std::swap</code>：实现两个对象的交换。<code>C++11</code>之前，<code>std::swap</code>的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp&#123;a&#125;;  <span class="comment">// 调用复制构造函数</span></span><br><span class="line">    a = b;     <span class="comment">// 复制赋值运算符</span></span><br><span class="line">    b = tmp;     <span class="comment">// 复制赋值运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的实现可以看到：共进行了3次复制。如果类型<code>T</code>比较占内存，那么交换的代价是非常昂贵的。但是利用移动语义，我们可以更加高效地交换两个对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(<span class="built_in">std</span>::move(a))</span></span>;   <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    a = <span class="built_in">std</span>::move(b);       <span class="comment">// 调用移动赋值运算符</span></span><br><span class="line">    b = <span class="built_in">std</span>::move(tmp);     <span class="comment">// 调用移动赋值运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅通过三次移动，实现两个对象的交换，由于没有复制，效率更高！</p>
<p>你可能会想，<code>std::move</code>函数内部到底是怎么实现的。其实<code>std::move</code>函数并不“移动”，它仅仅进行了类型转换。下面给出一个简化版本的<code>std::move</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很短，但是估计很难懂。首先看一下函数的返回类型，<code>remove_reference</code>在头文件中，<code>remove_reference&lt;T&gt;</code>有一个成员<code>type</code>，是<code>T</code>去除引用后的类型，所以<code>remove_reference&lt;T&gt;::type&amp;&amp;</code>一定是右值引用，对于返回类型为右值的函数其返回值是一个右值（准确地说是<code>xvalue</code>）。所以，知道了<code>std::move</code>函数的返回值是一个右值。然后，我们看一下函数的参数，使用的是通用引用类型（<code>&amp;&amp;</code>），意味者其可以接收左值，也可以接收右值。其推导规则如下：如果实参是左值，推导后的形参是左值引用，如果是右值，推导出来的是右值引用（感兴趣的话可以看看reference collapsing）。但是不管怎么推导，<code>ReturnType</code>的类型一定是右值引用，最后<code>std::move</code>函数只是简单地调用<code>static_cast</code>将参数转化为右值引用。所以，<code>std::move</code>什么也没有做，只是告诉编译器将传入的参数无条件地转化为一个右值。所以，当你使用<code>std::move</code>作用于一个对象时，你只是告诉编译器这个对象要转化为右值，然后就有资格进行移动语义了！</p>
<p>下面举一个由于误用<code>std::move</code>而无效的例子。假如你在设计一个标注类，其构造函数接收一个<code>string</code>类型参数作为标注文本，你不希望它被修改，所以标注为const，然后将其复制给其的一个数据成员，你可能会使用移动语义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text)</span>:</span></span><br><span class="line"><span class="function">        <span class="title">m_text</span> <span class="params">(<span class="built_in">std</span>::move(text))</span></span></span><br><span class="line"><span class="function">    </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">getText</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_text; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后你高高兴兴地去测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">text</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span> </span>;</span><br><span class="line">    <span class="function">Annotation <span class="title">ant</span><span class="params">(text )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ant.getText() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// output: hello</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; text &lt;&lt; <span class="built_in">endl</span>;           <span class="comment">// output: hello 不是空，移动语义没有实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你发现移动语义并没有被实现，这是为什么呢？首先，从直观上看，假如你移动语义成功了，那么<code>text</code>会发生改变，这会违反其const属性。所以，你不大可能成功！其实，<code>std::move</code>函数会在推导形参时会保持形参的const属性，所以其最终返回的是一个const右值引用类型，那么<code>m_text(std::move(text))</code>到底会调用什么构造函数呢？我们知道<code>string</code>的内部有两个构造函数可能会匹配：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span>&amp; rhs);   <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">string</span>(<span class="built_in">string</span>&amp;&amp; rhs);    <span class="comment">// 移动构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么到底会匹配哪个呢？肯定的是移动构造函数不会被匹配，因为不接受const对象，复制构造函数会匹配吗？答案是可以，因为前面我们讲过const左值引用可以接收右值，const右值更可以！所以，你其实调用了复制构造函数，那么移动语义当然无法实现。</p>
<p>所以，如果你想接下来进行移动，那不要把<code>std::move</code>引用在const对象上！</p>
<blockquote>
<p><strong>tips:</strong><br>1、只有当一个类没有定义任何自己的拷贝控制成员时，且他的所有数据成员都能移动构造或者移到赋值时，编译器才会为他合成移动构造函数或移动赋值运算符。<br>2、当定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认被定义为删除。</p>
</blockquote>
<h3 id="6、std-forward与完美转发"><a href="#6、std-forward与完美转发" class="headerlink" title="6、std::forward与完美转发"></a>6、std::forward与完美转发</h3><p>前面已经讲过，完美转发就是创建一个函数，该函数可以接收任意类型的参数，然后将这些参数按原来的类型转发给目标函数，完美转发的实现要依靠<code>std::forward</code>函数。下面就定义了这样一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>;   <span class="comment">// 接收左值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">string</span>&amp;&amp; str)</span></span>;        <span class="comment">// 接收右值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo(<span class="built_in">std</span>::forward&lt;T&gt;(param));  <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先要有一点要明确，不论传入<code>wrapper</code>的参数是左值还是右值，一旦传入之后，<code>param</code>一定是左值，然后我们来具体分析这个函数：</p>
<ul>
<li>当一个类型为<code>string</code>类型的右值传递给<code>wrapper</code>时，<code>T</code>被推导为<code>string</code>，<code>param</code>为右值引用类型，但是一旦传入后，<code>param</code>就变成了左值，所以你直接转发给<code>foo</code>函数，将丢失<code>param</code>的右值属性，那么<code>std::forward</code>就确保传入<code>foo</code>的值还是一个右值；</li>
<li>当类型为<code>const string</code>的左值传递给<code>wrapper</code>时，<code>T</code>被推导为<code>const string&amp;</code>，<code>param</code>为const左值引用类型，传入后，<code>param</code>仍为const左值类型，所以你直接转发给<code>foo</code>函数，没有问题，此时应用<code>std::forward</code>函数可以看成什么也没有做；</li>
<li>当类型为<code>string</code>的左值传递给<code>wrapper</code>时，<code>T</code>被推导为<code>string&amp;</code>，<code>param</code>为左值引用类型，传入后，<code>param</code>仍为左值类型，所以你直接转发给<code>foo</code>函数，没有问题，此时应用<code>std::forward</code>函数可以看成什么也没有做；</li>
</ul>
<p>所以<code>wrapper</code>函数可以实现完美转发，其关键点在于使用了<code>std::forward</code>函数确保传入的右值依然转发为右值，而对左值传入不做处理。</p>
<p>那么，<code>std::forward</code>到底怎么处理，其实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码依然与<code>std::move</code>一样简洁，我们结合<code>wrapper</code>来看，如果传入<code>wrapper</code>函数中的是<code>string</code>左值，那么推导出<code>T</code>是<code>string&amp;</code>，那么将调用<code>std::foward&lt;string&amp;&gt;</code>，根据<code>std::foward</code>的实现，其实例化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;<span class="built_in">string</span>&amp;&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连续出现3个<code>&amp;</code>符号有点奇怪，我们知道<code>C++</code>不允许引用的引用，那么其实编译器这里进行是引用折叠（reference collapsing，大致就是后面的引用消掉），因此，变成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">forward</span><span class="params">(<span class="built_in">string</span>&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就很清晰了，一个左值引用的参数，然后还是返回左值引用，此时的<code>std::foward</code>就是什么也没有做，因为传入与返回完全一样。</p>
<p>那么如果传入<code>wrapper</code>函数中的是<code>string</code>右值，那么推导出<code>T</code>是<code>string</code>，那么将调用<code>std::foward&lt;string&gt;</code>，根据<code>std::foward</code>的实现，其实例化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;<span class="built_in">string</span>&gt;::type&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续简化，变成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp;&amp; <span class="title">forward</span><span class="params">(<span class="built_in">string</span>&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数依然是左值引用（这点是一致的，因为前面说过传入<code>std:;forward</code>中的实参一直是左值），但是返回的是右值引用，此时的<code>std::foward</code>就是将一个左值转化了右值，这样保证传入目标函数的实参是右值！</p>
<p>综上，可以看到<code>std::foward</code>函数是有条件地将传入的参数转化为右值，而<code>std::move</code>无条件地将参数转化为右值，这是两者的区别。但是本质上，两者什么没有做，做多就是进行了一次类型转换。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>右值</tag>
        <tag>move</tag>
      </tags>
  </entry>
  <entry>
    <title>allocator 使用</title>
    <url>/2020/11/16/allocator%20%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="allocator-使用"><a href="#allocator-使用" class="headerlink" title="allocator 使用"></a>allocator 使用</h3><p><strong>作用:只开辟空间，不调用构造函数</strong></p>
<a id="more"></a>

<blockquote>
<p>操作一览表</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>allocator<T> a</td>
<td>定义一个名为a的allocator对象，它可以为类型为T的对象分配内存</td>
</tr>
<tr>
<td>a.allocate(n)</td>
<td>分配一段连续的为构造的内，能容纳n个类型为T的对象</td>
</tr>
<tr>
<td>a.deallocate(p, n)</td>
<td>释放从指针p中地址开始的内存，这块内存保存了n个类型为T的对象。p必须是以个先前有allocate返回的指针，而且n必须是创建p时所要求的大小。在调用deallocate以前，用户必须对每个在这块内存中创建的对象调用destroy</td>
</tr>
<tr>
<td>a.construct(p, args)</td>
<td>p必须是一个类型为T的指针，指向一块原始内存；args被传递给类型为T的构造函数，用来在p指向的内存块中构造一个对象。</td>
</tr>
<tr>
<td>a.destroy(p)</td>
<td>p为类型为T的指针，对p指向的对象执行析构函数。</td>
</tr>
</tbody></table>
<p>小例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> d = <span class="number">0</span>)</span> : <span class="title">data</span><span class="params">(d)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;new&quot;</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">  ~test()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;del&quot;</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  allocator&lt;test&gt; alloc;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(<span class="number">2</span>);</span><br><span class="line">  alloc.construct(p, test(<span class="number">1</span>));</span><br><span class="line">  p-&gt;fun();</span><br><span class="line">  <span class="keyword">auto</span> q = p + <span class="number">1</span>;</span><br><span class="line">  alloc.construct(q, test(<span class="number">2</span>));</span><br><span class="line">  q-&gt;fun();</span><br><span class="line">  alloc.destroy(p);</span><br><span class="line">  alloc.destroy(q);</span><br><span class="line">  alloc.deallocate(p,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针简单使用</title>
    <url>/2020/11/06/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1、智能指针设计思想"><a href="#1、智能指针设计思想" class="headerlink" title="1、智能指针设计思想"></a>1、智能指针设计思想</h4><p>在前面<a href="https://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&mid=2247483684&idx=1&sn=70d0dd0b8fc8a8a39f853fdfe76048a8&chksm=972ad05ea05d5948c89e468026670215df3ea1679eab4b484194c54a5186d0b3b538c3ff1770&mpshare=1&scene=21&srcid=0907xBOKbyLOjxLBPDCheAQC#wechat_redirect">C/C++指针使用常见的坑</a>一文中总结了C/C++中使用指针时可能会遇到的各种坑，其中最常见的是内存泄露，大家还记得下面这个例子吧。<a id="more"></a></p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/1.webp" alt="img"></p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/2.png" alt="img"></p>
<p>在这个例子中，由于抛出异常，delete语句没有机会执行，造成内存泄露。当然对于这个几十行规模的程序来说，你可以在catch语句中再加一句delete t可以避免。</p>
<p>但是如果是一个几十W行的工程项目了？我想你一定会崩溃吧！那么有没有更好的办法呢？答案是肯定的。</p>
<p>我们知道，对于普通的局部变量（非静态局部变量），当离开它的作用域时，操作系统会自动将其释放的；并且我们也知道对于类对象在释放的时候是会自动调用该类的析构函数。</p>
<p>于是我们就想：如果是Test *t不是一个普通的指针变量，而是一个类对象的话，并且在类的析构函数中实现了释放动态内存的步骤；那么只要该指针变量一退出作用域时就会调用析构函数，达到了释放动态内存的目的。这就是智能指针的思想。</p>
<p>根据前面的设想，自己也不难实现一个简易的智能指针，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     Test* ptr;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     SmartPointer(Test* p)         </span><br><span class="line">        &#123;</span><br><span class="line">	        ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">     ~SmartPointer() <span class="comment">//析构函数释放资源       </span></span><br><span class="line">        &#123;</span><br><span class="line">	     <span class="keyword">delete</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么如何使用了，只需要在原来代码的基础上改动一点点即可，如下：</p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/3.jpg" alt="img"></p>
<h4 id="2、C-智能指针简单使用"><a href="#2、C-智能指针简单使用" class="headerlink" title="2、C++智能指针简单使用"></a>2、C++智能指针简单使用</h4><p><img src="https://zhuom-go.github.io/img/share_ptr/12.jpg" alt="img"></p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/13.jpg" alt="img"></p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/14.jpg" alt="img"></p>
<p>当然，前面我们自己实现的智能指针只是为了说明智能指针设计的思想，是非常简陋的。在平时使用中是不会需要自己去定义智能指针的，C++已经给我们提供了现成的智能指针可以使用。</p>
<p>C++ STL为我们提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr和weak_ptr；其中auto_ptr是C++98提供，在C++11中建议摒弃不用，至于原因，后面会讲到；而unique_ptr、shared_ptr和weak_ptr则是随着C++11的到来而加入到STL中。</p>
<p>智能指针的使用其实并不难，如下所示：</p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/4.webp" alt="img"></p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/5.webp" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;Student&gt; s=make_shared&lt;Student&gt;()           <span class="comment">//相当于 Student *s=new Student();</span></span><br></pre></td></tr></table></figure>

<p>为什么不建议使用auto_ptr</p>
<p>先来看看下面的语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">px</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>))</span></span>;</span><br><span class="line"><span class="comment">//shared_ptr&lt;int&gt; p;</span></span><br><span class="line"><span class="comment">//p=make_shared&lt;int&gt;(8)   ; 返回指向8个int的地址</span></span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; py;</span><br><span class="line">py = px;</span><br></pre></td></tr></table></figure>

<p>上述赋值语句将完成什么工作呢？如果px和py是普通指针，则两个指针将指向同一个动态分配的int对象。这是不能接受的，因为程序可能将试图删除同一个对象两次——一次是px过期时，另一次是py过期时，我们知道，同一块内存是不能delete两次的。要避免这种问题，主要有以下两种方法：</p>
<ul>
<li>建立所有权（ownership）概念。对于特定的对象，同一时刻只能有一个智能指针可拥有， 比如说当智能指针A指向对象x，当执行完B=A后，原来的指针A就失去了对x的所有权，这样只有拥有对象的智能指针的构造函数会删除该对象，unique_ptr和auto_ptr就是采用这种策略。</li>
<li>创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。</li>
</ul>
<p>当然，对于复制构造函数也应该采用同样的策略。</p>
<p>下面来看看在C++11中为什么建议摒弃auto_ptr，看下面的例子，</p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/6.jpg" alt="img"></p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/7.webp" alt="img"></p>
<p>从程序的运行结果来看，当执行完赋值语句py = px后，再去访问px时程序崩溃了。原因就是因为赋值语句py = px使得对象的所有权从px转让给py了，px已经变为空指针了，再去访问px当然会出错了。</p>
<p>那么如果使用unique_ptr或者shared_ptr又会怎样了？还是测试下吧，先看unique_ptr情况：</p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/8.webp" alt="img"></p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/9.webp" alt="img"></p>
<p>看看，如果使用unique_ptr，在这种情况下编译会出错，也就是说尽管与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique_ptr时，程序不会等到运行阶段崩溃，在编译时就将可能潜在的错误暴露给你</p>
<p>好了，再看看shared_ptr情况：</p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/10.webp" alt="img"></p>
<p><img src="https://zhuom-go.github.io/img/share_ptr/11.webp" alt="img"></p>
<p>使用shared_ptr时运行正常，因为shared_ptr采用引用计数，当执行完赋值语句py = px后，px和py都指向同一块内存，只不过在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。</p>
<p><strong>weak_ptr</strong><br> weak_ptr 是为了解决 shared_ptr 双向引用的问题。即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line"> <span class="built_in">shared_ptr</span>&lt;B&gt; b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line"> <span class="built_in">shared_ptr</span>&lt;A&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> pa = make_shared&lt;A&gt;();</span><br><span class="line"><span class="keyword">auto</span> pb = make_shared&lt;B&gt;();</span><br><span class="line">pa-&gt;b = pb;</span><br><span class="line">pb-&gt;a = pa;</span><br></pre></td></tr></table></figure>

<p>pa 和 pb 存在着循环引用，根据 shared_ptr 引用计数的原理，pa 和 pb 都无法被正常的释放。对于这种情况, 我们可以使用 weak_ptr：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line"> <span class="built_in">shared_ptr</span>&lt;B&gt; b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line"> weak_ptr&lt;A&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> pa = make_shared&lt;A&gt;();</span><br><span class="line"><span class="keyword">auto</span> pb = make_shared&lt;B&gt;();</span><br><span class="line">pa-&gt;b = pb;</span><br><span class="line">pb-&gt;a = pa;</span><br></pre></td></tr></table></figure>

<p>weak_ptr 不会增加引用计数，因此可以打破 shared_ptr 的循环引用。通常做法是 parent 类持有 child 的 shared_ptr, child 持有指向 parent 的 weak_ptr。这样也更符合语义。</p>
<h4 id="3、如何指针作为函数传参"><a href="#3、如何指针作为函数传参" class="headerlink" title="3、如何指针作为函数传参"></a>3、如何指针作为函数传参</h4><p> 很多时候，函数的参数是个指针。这个时候就会面临选择困难症，这个参数应该怎么传，应该是 shared_ptr，还是 const shared_ptr&amp;，还是直接 raw pointer 更合适。</p>
<ol>
<li>只在函数使用指针，但并不保存。假如我们只需要在函数中，用这个对象处理一些事情，但不打算涉及其生命周期的管理，不打算通过函数传参延长 shared_ptr 的生命周期。对于这种情况，可以使用 raw pointer 或者 const shared_ptr&amp;。即：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Widget*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;Widget&gt;&amp;)</span></span></span><br></pre></td></tr></table></figure>

<p>实际上第一种裸指针的方式可能更好，从语义上更加清楚，函数也不用关心智能指针的类型。</p>
<p>在函数中保存智能指针。假如我们需要在函数中把这个智能指针保存起来，这个时候建议直接传值。<br> void func(std::shared_ptr ptr);<br> 这样的话，外部传过来值的时候，可以选择 move 或者赋值。函数内部直接把这个对象通过 move 的方式保存起来。这样性能更好，而且外部调用也有多种选择。</p>
<h4 id="4、如何选择哪种智能指针"><a href="#4、如何选择哪种智能指针" class="headerlink" title="4、如何选择哪种智能指针"></a>4、如何选择哪种智能指针</h4><p>在了解了这几种智能指针后，大家可能很自然的想到一个问题：在实际项目应用中，应使用哪种智能指针呢？根据这几种智能指针的特点，给出下面几点建议：</p>
<ul>
<li><p>如果程序中要使用多个指向同一个对象的指针，那么应该使用shared_ptr；比如说现在有一个包含指针的STL容器，现在用某个支持复制和赋值操作STL算法去操作该容器的指针元素，那么就应该用shared_ptr。不能用unique_ptr（编译器报错）和auto_ptr（行为不确定）。</p>
</li>
<li><p>如果程序中不需要使用多个指向同一个对象的指针，则可使用unique_ptr；如果函数使用new分配内存，并返回指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。</p>
</li>
<li><p>在满足unique_ptr要求的条件时，也可使用auto_ptr，但unique_ptr是更好的选择。</p>
</li>
<li><p> 对于智能指针的使用，实际上是对所有权和生命周期的思考，一旦想明白了这两点，那对智能指针的使用也就得心应手了。同时理解了每种智能指针背后的性能消耗、使用场景，那智能指针也不再是黑盒子和洪水猛兽。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>再探迭代器</title>
    <url>/2020/11/05/%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。</p>
<ul>
<li>插入迭代器：这些迭代器被绑定到一个容器上，可用来向容器插入元素</li>
<li>流迭代器：这些迭代器被绑定到输入或输出上，可用来遍历所有关联的IO流</li>
<li>反向迭代器：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器</li>
<li>移动迭代器：这些专用的迭代器不是拷贝其中的元素，而是移动它们。</li>
</ul>
<h3 id="1、插入迭代器"><a href="#1、插入迭代器" class="headerlink" title="1、插入迭代器"></a>1、插入迭代器</h3><p>插入迭代器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。<a id="more"></a></p>
<p>插入迭代器有三种类型，差异在于元素插入的位置：</p>
<ul>
<li>back_inserter创建一个使用push_back的迭代器</li>
<li>front_inserter创建一个使用push_front的迭代器</li>
<li>inserter创建一个使用insert的迭代器。此函数接受三个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</li>
</ul>
<p>注意：只有在容器支持push_front的情况下，我们才可以使用front_inserter。类似的，只有在容器支持push_back的情况下，我们才能使用back_inserter<br>理解插入迭代器的工作过程是很重要的：当调用inserter(c,iter)时，我们得到一个迭代器，接下来使用它时，会将元素插入到iter原来所指的位置之前的位置。即，如果it是由inserter生成的迭代器，则下面这样的赋值语句<br><code>*it=val</code><br>其效果与下面代码一样<br><code>it=c.insert(it,val) </code> //<code>it</code>指向新加入的元素<br><code>++it</code>//递增it使它指向原来的元素<br><code>front_inserter</code>生成的迭代器的行为与<code>inserter</code>生成的迭代器完全不一样。当我们使用<code>front_inserter</code>时，元素总是插入到容器第一个元素之前，即使我们传递给inserter的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst2,lst3;  <span class="comment">//空list</span></span><br><span class="line">copy(lst.begin(),lst.end(),front_inserter(lst2));   <span class="comment">//拷贝完成之后，lst2包含4 3 2 1 </span></span><br><span class="line">copy(lst.begin(),lst.end(),inserter(lst3,lst.begin()));<span class="comment">//拷贝完成之后lst3包含1 2 3 4 </span></span><br></pre></td></tr></table></figure>

<p>当调用front_inserter(c)时，我们得到一个插入迭代器，接下来会调用push_front.当每个元素被插入到容器c中时，它变为c的新的首元素。因此，front_inserter生成的迭代器会将插入的元素序列的顺序颠倒过来，而inserter和back_inserter则不会。</p>
<h3 id="2、iostream迭代器"><a href="#2、iostream迭代器" class="headerlink" title="2、iostream迭代器"></a>2、iostream迭代器</h3><p>虽然iostream类型不是容器，但标准库定义了用于这些IO类型对象的迭代器。istream_iterator读取输入流，ostream_iterator向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。</p>
<blockquote>
<p><strong>istream_iterator操作</strong></p>
</blockquote>
<p>当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个istream_iterator使用&gt;&gt;来读取流。因此，istream_iterator要读取的类型必须定义了输入运算符。当创建一个istream_iterator时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">int_it</span><span class="params">(<span class="built_in">cin</span>)</span></span>; <span class="comment">//从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_eof; <span class="comment">//尾后迭代器</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;afile&quot;</span>)</span></span>; </span><br><span class="line"><span class="function">istream_iterator&lt;<span class="built_in">string</span>&gt; <span class="title">str_in</span><span class="params">(in)</span></span>; <span class="comment">//从“afile读取字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是一个用istream_iterator从标准输入流读取数据，存入一个vector的例子：</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">in_iter</span><span class="params">(<span class="built_in">cin</span>)</span></span>; <span class="comment">//从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof;  <span class="comment">//istream尾后迭代器</span></span><br><span class="line"><span class="keyword">while</span>(in_iter!=eof)</span><br><span class="line">　　<span class="comment">//后置递增运算读取流，返回迭代器的旧值</span></span><br><span class="line">　　<span class="comment">//解引用迭代器，获得从流读取的前一个值</span></span><br><span class="line">　　vec.push_back(*in_iter++);</span><br></pre></td></tr></table></figure>

<p>此循环从cin读取int值，保存在vec中。在每个循环步中，循环体代码检查in_iter是否等于eof。eof被定义为空istream_iterator,从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的值就与尾后迭代器相等。<br>我们可以将程序重写为如下形式，这体现了istream_iterator更有用的地方：<br><code>istream_iterator&lt;int&gt; in_iter(cin),eof; //从cin读取int</code><br><code>vector&lt;int&gt; vec(in_iter,eof);  //从迭代器范围构造vec</code></p>
<p>本例中我们使用了一对表示范围的迭代器来构造<code>vec</code>，这两个迭代器是<code>istream_iterator</code>，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从<code>cin</code>读取数据，直至遇到文件尾或者遇到一个不是<code>int</code>的数据为止。从流中读取的数据被用来构造<code>vec</code>。 </p>
<blockquote>
<p><strong>使用算法操作流迭代器</strong></p>
</blockquote>
<p>由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某种迭代器操作，因此我们至少可以用某些算法来操作流迭代器。下面是一个例子，我们可以用一对istream_iterator来调用accumulate:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; in(cin),eof;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;accumulatre(in,eof,<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//此调用会计算出从标准输入读取的值的和。如果输入为：</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">7</span> <span class="number">9</span> <span class="number">9</span> </span><br><span class="line">输出为<span class="number">29</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>istream_iterator允许使用懒惰求值</strong></p>
</blockquote>
<p>当我们将一个<code>istream_iterator</code>绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取并没有什么差别。但是，如果我们创建了一个<code>istream_iterator</code>，没有使用就销毁了，或者我们正在从两个不同的对象同步读同一个流，那么何时读取可能就很重要了。</p>
<blockquote>
<p><strong>ostream_iterator操作</strong></p>
</blockquote>
<p>我们可以对任何输出运算符(&lt;&lt;运算符)的类型定义<code>ostream_iterator</code>。当创建一个<code>ostream_iterator</code>时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符串字面值或者一个指向以空字符结尾的字符数组的指针）。必须将<code>ostream_iterator</code>绑定到一个指定的流。不允许空的或表示尾后位置的ostream_iterator。</p>
<p>我们可以使用<code>ostream_iterator</code>来输出值的序列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>,<span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e:vec)</span><br><span class="line">　　*out_iter++=e;  <span class="comment">//赋值语句实际上将元素写到cout</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此程序将vec中的每个元素写到cout，每个元素加一个空格，每次向out_iter赋值时，写操作就会被提交。</span></span><br><span class="line"><span class="comment">//值得注意的是，当我们向out_iter赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e:vec)</span><br><span class="line">　　out_iter=e;<span class="comment">//赋值语句将元素写道cout</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;end;</span><br></pre></td></tr></table></figure>

<p>运算符*和++实际上对<code>ostream_iterator</code>对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保存一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。<br>可以通过调用copy来打印vec中的元素，这比编写循环更为简单：<br><code>copy(vec.begin(),vec.end(),out_iter);</code><br><code>cout&lt;&lt;endl;</code></p>
<blockquote>
<p><strong>使用流迭代器处理类类型</strong></p>
</blockquote>
<p>我们可以为任何定义了输入运算符(&gt;&gt;)的类型创建<code>istream_iterator</code>对象。类似的，只要类型有输出运算符(&lt;&lt;)，我们就可以为其定义<code>ostream_iterator</code>。由于Sales_item既有输入运算符也有输出运算符，因此可以使用IO迭代器。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">istream_iterator&lt;Sales_item&gt; item_iter(cin),eof;</span><br><span class="line"><span class="function">ostream_iterator&lt;Sales_item&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>,<span class="string">&quot;\n&quot;</span>)</span></span>;</span><br><span class="line">Sales_item sum=*item_iter++;</span><br><span class="line"><span class="keyword">while</span>(item_iter!=eof)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(item_iter-&gt;isbn()==sum.isbn())</span><br><span class="line">        sum+=*item_iter++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        out_iter=sum;</span><br><span class="line">        sum=*item_iter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">out_iter=sum;</span><br></pre></td></tr></table></figure>

<p>此程序使用<code>item_iter</code>从<code>cin</code>读取<code>Sales_item</code>交易记录，并将和写入<code>cout</code>，每个结果后面都跟一个换行符。定义了自己的迭代器后，我们就可以用<code>item_iter</code>读取第一条交易记录，用它的值来初始化sum.</p>
<h3 id="3、-反向迭代器"><a href="#3、-反向迭代器" class="headerlink" title="3、 反向迭代器"></a><strong>3、 反向迭代器</strong></h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一迭代器（–it）会移动到下一个元素。</p>
<p>除了<code>forward_list</code>之外，其他容器都支持反向迭代器。我们可以通过调用<code>rbegin</code>、<code>rcend</code>、<code>crbegin</code>和<code>crend</code>成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有<code>const</code>和非<code>const</code>版本。<br>下面的循环是一个使用反向迭代器的例子，它按逆序打印<code>vec</code>中的元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;    <span class="comment">//从尾元素到首元素的反向迭代器</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> r_iter=vec.crbegin;r_iter!=vec.crend();++r_iter)</span><br><span class="line">　<span class="built_in">cout</span>&lt;&lt;*r_iter&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//打印9，8，7，6，5，4，3，2，1，0</span></span><br></pre></td></tr></table></figure>

<p>虽然颠倒递增和递减运算符的含义可能令人混淆，但这样做是我们可以用算法透明地向前或向后处理容器。例如，可以通过向sort传递一对反向迭代器来将vector整理为递减序：<br><code>sort(vec.begin(),vec.end()); </code><br><code>sort(vec.rbegin(),vec.rend());</code> </p>
<p><strong>反向迭代器需要递减运算符</strong></p>
<p>我们<strong>只能从既支持++也支持–的迭代器来定义反向迭代器</strong>。毕竟反向迭代器的目的是在序列中反向移动。出了<code>forward_list</code>之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个<code>forward_list</code>或一个流迭代器创建反向迭代器。</p>
<p><strong>反向迭代器与其他迭代器间的关系</strong></p>
<p>假定有一个名为<code>line</code>的<code>string</code>，保存着一个逗号分隔的单词列表，我们希望打印line中的第一个单词，使用find可以很容易地完成这一任务：<br><code>auto comma=find(line.cbegin(),line.cend(),&#39;,&#39;);   //在一个逗号分隔的列表中查找一个元素</code><br><code>cout&lt;&lt;string(line.cbegin(),comma)&lt;&lt;endl;</code></p>
<p>如果<code>line</code>中有逗号，那么<code>comma</code>将指向这个逗号；否则，它将等于<code>line.cend()</code>.当我们打印从<code>line.cbegin()</code>到<code>comma</code>之间的内容时，将打印到逗号为止的序列，或者打印整个<code>string</code>（如果其中不含逗号的话）。<br>如果希望打印最后一个单词，可以改用反向迭代器：<br><code>auto rcomma=find(line.crbegin(),line.crend(),&#39;,&#39;);  //在一个逗号分隔的列表中查找最后一个元素</code><br>由于我们将<code>crbegin</code>和<code>crend</code>传递给<code>find</code>，<code>find</code>将从<code>line</code>的最后一个字符开始向前搜索。当<code>find</code>完成后，如果<code>line</code>中有逗号，则<code>rcomma</code>指向最后一个逗号——即，它指向反向搜索中找到的第一个逗号。如果<code>line</code>中没有逗号，则<code>rcomma</code>指向<code>line.crend()</code><br>但我们试图打印找到的单词时，看起来下面的代码是显然的方法。<br><code>cout&lt;&lt;string(line.crbegin(),rcomma)&lt;&lt;endl;   //错误:将逆序输出单词的字符</code><br>但它会生成错误的输出结果。例如，如果我们的输入是<br><code>FIRST,MIDOLE,LAST</code><br><code>则这条语句会打印TSAL！</code><br>问题所在：我们使用的是反向迭代器，会反向出来<code>string</code>。因此，上述输出语句从<code>crbegin</code>开始反向打印<code>line</code>中内容。而我们希望按正常顺序打印从<code>rcomma</code>开始到<code>line</code>末尾间的字符。但是，我们不能直接使用<code>rcomma</code>。因为它是一个反向迭代器，意味着它会反向朝着<code>string</code>的开始位置移动。需要做的是，将<code>rcomma</code>转换回一个普通迭代器，能在<code>line</code>中正向移动。我们通过调用<code>reverse_iterator</code>的**<code>base</code>**成员函数来完成这一转换，此成员函数会返回其对应的普通迭代器：<br><code>cout&lt;&lt;string(rcomma.base(),line.cend())&lt;&lt;endl;  //正确：得到一个正向迭代器，从逗号开始读取字符直到line末尾</code><br><code>rcomma</code>和<code>rcomma.base()</code>向了不同的元素，<code>line.crbegin()</code>和<code>line.cend()</code>也是如此。这些不同保证了元素范围无论是正向处理还是反向出来都是相同的。<br>从技术上讲，普通迭代器与反向迭代器的关系反映了左闭合区间的特征。关键点在于<code>[line.crbegin(),rcomma)和[rcomma.base(),line.cend())</code>指向<code>line</code>中相同的元素范围。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>bind的简单使用</title>
    <url>/2020/11/05/bind%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="bind的简单实用"><a href="#bind的简单实用" class="headerlink" title="bind的简单实用"></a>bind的简单实用</h3><p>函数绑定bind函数用于把某种形式的参数列表与已知的函数进行绑定，形成新的函数，bind就是函数适配器。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun = [](<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> n,<span class="keyword">int</span> num)&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">array</span>[i]&gt;num) &#123;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="built_in">array</span>[i]&lt;&lt;ends;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> func1 = bind(fun, _1,_2,<span class="number">5</span>);</span><br><span class="line">func1(<span class="built_in">array</span>,<span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(*<span class="built_in">array</span>));</span><br></pre></td></tr></table></figure>

<p>bind使用的一般形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> newfun = bind(fun,arg_list);<span class="comment">//其中fun是一个函数，arg_list是逗号隔开的参数列表。调用newfun()，newfun()会调用fun(arg_list)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>bind的常见用法一：减少函数参数的调用，这是最常见的用法。占位符：_1_,_2等，定位于arg_list中，__1是第一个参数,_2是第二个参数，以此类推！<br> bind的常见用法二：更改参数的调用顺序。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> newfound = bind(fun,_2,_1);<span class="comment">//调用newfound(1,2)；相当于调用fun(2,1)</span></span><br></pre></td></tr></table></figure>

<p><strong>但是这里需要注意的一点就是类成员函数的使用。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;void fun1(void)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;int fun2(int i) &quot;</span>&lt;&lt;<span class="string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Myclass my;<span class="comment">//使用类对象绑定</span></span><br><span class="line"><span class="keyword">auto</span> fun1 = bind(&amp;Myclass::fun1, my);</span><br><span class="line">fun1();</span><br><span class="line"></span><br><span class="line">Myclass * p;.</span><br><span class="line"><span class="keyword">auto</span> fun2 = bind(&amp;Myclass::fun2, p,_1);</span><br><span class="line"><span class="keyword">int</span> i = fun2(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//因为类函数调用有一个默认的this参数</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式的使用</title>
    <url>/2020/11/04/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="1、C-lambda表达式"><a href="#1、C-lambda表达式" class="headerlink" title="1、C++ lambda表达式"></a>1、C++ lambda表达式</h3><p>lambda表达式又称<a href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</a>（<a href="https://en.wikipedia.org/wiki/Anonymous_function">Anonymous function</a>），其构造了一个可以在其作用范围内捕获变量的函数对象;</p>
<a id="more"></a>lambda表达式实际为一个仿函数functor，编译器后会生成一个匿名类（注：这个类重载了()运算符）;
<p>与普通函数指针相比，Lambda表达式可以包含数据成员，也就是说它是可以有状态的。下面举一个简单的例子说明一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arry = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">std</span>::for_each(begin(arry), end(arry), [&amp;sum](<span class="keyword">int</span> x)&#123;sum += x;&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码被编译器展开后，会变成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lambda_b53d8cae67476f0e5f04d9defa3a2e2b</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_pSum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    lambda_b53d8cae67476f0e5f04d9defa3a2e2b(<span class="keyword">int</span>* pSum)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pSum = pSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        *m_pSum += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arry = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">lambda_b53d8cae67476f0e5f04d9defa3a2e2b <span class="title">obj</span><span class="params">(&amp;sum)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::for_each(begin(arry), end(arry), obj);</span><br></pre></td></tr></table></figure>

<h3 id="2、lambda表示式的结构"><a href="#2、lambda表示式的结构" class="headerlink" title="2、lambda表示式的结构"></a>2、lambda表示式的结构</h3><p>从C++11起，开始提供了匿名函数的支持，一个lambda表达式形如：</p>
<p>​                            <em>[capture] (parameters) specifiers -&gt; return_type { body }</em></p>
<p><strong>capture</strong></p>
<p>捕获的外部变量列表，通过逗号分隔，可进行传值捕获或者引用捕获，lambda表达式与这些捕获的外部变量会构成一个<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">闭包</a>（<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">Closure</a>），外部变量为闭包的成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g_Value = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLambda</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span> InValue)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> a1 = [](<span class="keyword">int</span> x) &#123;<span class="comment">/*仅能访问全局外部变量*/</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> a2 = [Value](<span class="keyword">int</span> x) &#123;<span class="comment">/*值传递局部变量Value*/</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> a3 = [<span class="keyword">this</span>](<span class="keyword">int</span> x) &#123;<span class="comment">/*值传递this指针*/</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> a4 = [&amp;Value](<span class="keyword">int</span> x) &#123;<span class="comment">/*引用传递局部变量Value*/</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> a5 = [=](<span class="keyword">int</span> x) &#123;<span class="comment">/*值传递所有可访问的外部变量*/</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> a6 = [&amp;](<span class="keyword">int</span> x) &#123;<span class="comment">/*引用传递所有可访问的外部变量*/</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> a7 = [=, &amp;Value](<span class="keyword">int</span> x) &#123;<span class="comment">/*引用传递局部变量Value，值传递所有其他可访问的外部变量*/</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> a8 = [&amp;, Value](<span class="keyword">int</span> x) &#123;<span class="comment">/*值传递局部变量Value，引用传递所有其他可访问的外部变量*/</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>① 全局变量、静态变量不用显示写在外部变量列表中，可直接在lambda表达式中读写<br>② 传值捕获的外部变量是一个副本，默认情况下在lambda表达式中是只读的，若想修改该副本，需要在lambda表达式上添加mutable关键字 如：auto a2 = [Value](int x) mutable {Value++;};-————————————————————————–</p>
<p>在C++中，mutable是为了突破const的限制而设置的，用来修饰类的非静态、非常量的数据成员，让被修饰的变量永远处于可变的状态</p>
<p>mutable的作用有两点：<br>a. 保持常量对象中大部分数据成员仍然是“只读”的情况下，实现对个别数据成员的修改；<br>b. 使类的const函数可以修改其mutable数据成员。</p>
<p>-————————————————————————–<br>③ 在类的非静态成员函数中定义的lambda表达式可以通过捕捉this指针，来访问对象的成员变量和成员函数<br>④ c++14中增加广义捕获（Generalized capture）：即在捕获子句中增加并初始化新的变量，该变量不需要在lambda表达式所处的闭包域中存在；即使在闭包域中存在也会被新变量覆盖。新变量类型由它的初始化表达式推导得到。一个用途是可以从闭包域中捕获只供移动的变量并使用它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> a1 = [Value = <span class="number">100</span>] &#123; <span class="keyword">return</span> Value; &#125;;<span class="comment">// 捕获子句中定义的Value变量会覆盖同名的外部局部变量</span></span><br><span class="line"><span class="keyword">int</span> result = a1(); <span class="comment">// result=100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Vout = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> a2 = [Vin = <span class="built_in">std</span>::move(Vout)]&#123; <span class="comment">// 将外部局部变量Vout移动到Vin变量，避免发生拷贝耗时操作</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : Vin)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result2 = a2(); <span class="comment">// result2=150</span></span><br></pre></td></tr></table></figure>

<p><strong>parameters</strong></p>
<p>lambda表达式自己的参数列表;<br>\1. 若lambda函数没有形参且没有被mutable等修饰，则参数的空圆括号可以省略;<br>如：<code>auto a = []&#123; ++g_Value; &#125;;</code><br>\2. c++14支持auto类型的形参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;<span class="keyword">return</span> x + y;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于定义了模板类型()运算符的函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unnamed_lambda</span>                            </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  template&lt;typename T, typename U&gt;   auto operator()(T x, U y) const &#123;return x + y;&#125;</span><br><span class="line">&#125; a;</span><br></pre></td></tr></table></figure>

<p>\3. c++14支持可变参数模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flag ? n1 : n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = [](<span class="keyword">auto</span>&amp;&amp;... params) <span class="comment">//可变参数的模板</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (foo(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> result = a(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">true</span>); <span class="comment">//result=1</span></span><br></pre></td></tr></table></figure>

<p>\4. 与普通函数相比，lambda表达式的参数有如下限制<br>① 参数不能有缺省值  如：<code>int Add1(int a, int b=10) </code><br>② 不能有可变长参数列表 如：<code>int Add2(int count, ...)</code><br>③ 不能有无名参数 如：<code>int Add3(int a, int b, int)</code> // 第三个参数为无名参数，用于以后扩展</p>
<p><strong>specifiers</strong><br>说明符，可选。如上文中的<code>mutable</code>，因为本身<code>lambda</code>表达式是不可以改变<code>const</code>修饰的捕获值的，要想改变捕获的值，则需要添加<code>mutable</code>。</p>
<p><strong>return_type</strong></p>
<p>返回类型<br>在以下情况下，可省略return_type:<br>① 返回值为void类型 如：<code>auto a = [](int x) &#123;x = 100;&#125;;</code> //返回值类型为void<br>② 所有返回语句用decltype都能检测到同一类型 如：<br><code>auto a = [](int x, float y) &#123; if (x &gt; 0) return x + y; return y; &#125;</code>;//返回值类型推导为float</p>
<blockquote>
<p><strong>使用lambda表达式</strong></p>
</blockquote>
<p>lambda表达式实际为一个函数对象，在使用时要注意lambda表达式以及被其捕获的外部变量的生命周期,<br><strong>把匿名函数存储在变量，当做有名函数来使用</strong><br>lambda表达式的数据类型是函数对象，可用auto类型、std::function模板类型（需#include <functional>）进行保存和调用<br>当捕获外部变量列表为空时，也可用普通函数指针进行保存和调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a1 = [&amp;Value](<span class="keyword">int</span> x) &#123;Value = x;&#125;;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">float</span>(<span class="keyword">int</span>,<span class="keyword">float</span>)&gt; a2 = [Value](<span class="keyword">int</span> x, <span class="keyword">float</span> y) &#123; <span class="keyword">return</span> x + y; &#125;; <span class="comment">//需要#include &lt;functional&gt;</span></span><br><span class="line">a1(<span class="number">100</span>);</span><br><span class="line">a2(<span class="number">100</span>, <span class="number">200.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda函数的捕获外部变量列表为空时，可使用普通函数指针来保存</span></span><br><span class="line"><span class="keyword">int</span>(*func1_ptr)(<span class="keyword">int</span>) = [](<span class="keyword">int</span> x) &#123;<span class="keyword">return</span> x; &#125;;</span><br><span class="line"><span class="keyword">bool</span>(*func2_ptr)(<span class="keyword">int</span>, <span class="keyword">int</span>) = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x &gt; y; &#125;;</span><br><span class="line"><span class="keyword">int</span> n = func1_ptr(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">bool</span> b = func2_ptr(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><strong>悬挂引用问题</strong>lambda表达式的闭包含有局部变量的引用（悬挂引用 Dangling references），在超出创建它的作用域之外的地方被使用的话，将引发内存越界访问.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>()&gt; a;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> Value = <span class="number">0</span>;</span><br><span class="line">    a = [&amp;Value] &#123;<span class="keyword">return</span> Value; &#125;;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">a(); <span class="comment">// 局部变量Value超过作用域，已被回收，调用lambda表达式将产生内存越界访问</span></span><br></pre></td></tr></table></figure>

<p>对于使用lambda表达式写的回调函数（如：窗口处理函数、线程执行函数、控件消息处理函数等），尤其要注意这个问题</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型算法</title>
    <url>/2020/11/04/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1、查找算法-13个-：判断容器中是否包含某个值"><a href="#1、查找算法-13个-：判断容器中是否包含某个值" class="headerlink" title="1、查找算法(13个)：判断容器中是否包含某个值"></a>1、查找算法(13个)：判断容器中是否包含某个值</h3><a id="more"></a>

<table>
<thead>
<tr>
<th>函数名</th>
<th>头文件</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>adjacent_find</code></td>
<td><algorithm></td>
<td>在iterator对标识元素范围内,查找一对相邻重复元素,找到则返回指向这对元素的第一个元素的ForwardIterator .否则返回last.重载版本使用输入的二元操作符代替相等的判断</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt&gt;</code> <br /><code>FwdIt adjacent_find(FwdIt first, FwdIt last);</code>  <br />   <code> template&lt;class FwdIt, class Pred&gt;</code> <br /><code>FwdIt adjacent_find(FwdIt first, FwdIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>binary_search</code></td>
<td><algorithm></td>
<td>在有序序列中查找value,找到返回true.重载的版本实用指定的比较函数对象或函数指针来判断相等</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class T&gt;</code> <br /><code>bool binary_search(FwdIt first, FwdIt last, const T&amp; val);</code><br />   <code>template&lt;class FwdIt, class T, class Pred&gt;</code><br /><code>bool binary_search(FwdIt first, FwdIt last, const T&amp; val,Pred pr);</code></td>
</tr>
<tr>
<td><code>count</code></td>
<td><algorithm></td>
<td>利用等于操作符,把标志范围内的元素与输入值比较,返回相等元素个数</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code> template&lt;class InIt, class Dist&gt;</code>  <br /><code>size_t count(InIt first, InIt last,const T&amp; val, Dist&amp; n);  </code></td>
</tr>
<tr>
<td><code>count_if</code></td>
<td><algorithm></td>
<td>利用输入的操作符,对标志范围内的元素进行操作,返回结果为true的个数</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code> template&lt;class InIt, class Pred, class Dist&gt;</code>  <br /><code>size_t count_if(InIt first, InIt last, Pred pr);  </code></td>
</tr>
<tr>
<td><code>equal_range</code></td>
<td><algorithm></td>
<td>功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class T&gt;</code> <br /><code>pair&lt;FwdIt, FwdIt&gt; equal_range(FwdIt first, FwdIt last,const T&amp; val); </code> <br />     <code>template&lt;class FwdIt, class T, class Pred&gt;</code> <br /><code>pair&lt;FwdIt, FwdIt&gt; equal_range(FwdIt first, FwdIt last,const T&amp; val, Pred pr);</code></td>
</tr>
<tr>
<td><code>find</code></td>
<td><algorithm></td>
<td>利用底层元素的等于操作符,对指定范围内的元素与输入值进行比较.当匹配时,结束搜索,返回该元素的一个InputIterator</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt, class T&gt; </code><br /><code>InIt find(InIt first, InIt last, const T&amp; val);  </code></td>
</tr>
<tr>
<td><code>find_end  </code></td>
<td><algorithm></td>
<td>find_end() 会在一个序列中查找最后一个和另一个元素段匹配的匹配项，也可以看作在一个元素序列中查找子序列的最后一个匹配项。这个算法会返回一个指向子序列的最后一个匹配项的第一个元素的迭代器，或是一个指向这个序列的结束迭代器。</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt1, class FwdIt2&gt;</code> <br /><code>FwdIt1 find_end(FwdIt1 first1, FwdIt1 last1,FwdIt2 first2, FwdIt2 last2);</code>  <br />    <code>template&lt;class FwdIt1, class FwdIt2, class Pred&gt;</code>  <br /><code>FwdIt1 find_end(FwdIt1 first1, FwdIt1 last1,FwdIt2 first2, FwdIt2 last2, Pred pr);</code></td>
</tr>
<tr>
<td><code>find_first_of</code></td>
<td><algorithm></td>
<td>在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt1, class FwdIt2&gt;</code> <br /><code>FwdIt1 find_first_of(FwdIt1 first1, FwdIt1 last1,FwdIt2 first2, FwdIt2 last2); </code><br />    <code>template&lt;class FwdIt1, class FwdIt2, class Pred&gt;</code> <br /><code>FwdIt1 find_first_of(FwdIt1 first1, FwdIt1 last1,FwdIt2 first2, FwdIt2 last2, Pred pr); </code></td>
</tr>
<tr>
<td><code>find_if</code></td>
<td><algorithm></td>
<td>使用输入的函数代替等于操作符执行find</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt, class Pred&gt;</code><br /><code>InIt find_if(InIt first, InIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>lower_bound</code></td>
<td><algorithm></td>
<td>返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置.重载函数使用自定义比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class T&gt;</code> <br /><code>FwdIt lower_bound(FwdIt first, FwdIt last, const T&amp; val);</code>  <br />    <code>template&lt;class FwdIt, class T, class Pred&gt;</code> <br /><code>FwdIt lower_bound(FwdIt first, FwdIt last, const T&amp; val, Pred pr);</code></td>
</tr>
<tr>
<td><code>upper_bound</code></td>
<td><algorithm></td>
<td>返回一个ForwardIterator,指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值.重载函数使用自定义比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class T&gt;</code>  <br /><code>FwdIt upper_bound(FwdIt first, FwdIt last, const T&amp; val); </code> <br />     <code>template&lt;class FwdIt, class T, class Pred&gt;</code>  <br /><code>FwdIt upper_bound(FwdIt first, FwdIt last, const T&amp; val, Pred pr);</code></td>
</tr>
<tr>
<td><code>search</code></td>
<td><algorithm></td>
<td>给出两个范围，返回一个ForwardIterator,查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1,重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt1, class FwdIt2&gt;</code> <br /><code>FwdIt1 search(FwdIt1 first1, FwdIt1 last1,FwdIt2 first2, FwdIt2 last2); </code> <br />    <code>template&lt;class FwdIt1, class FwdIt2, class Pred&gt;</code> <br /><code>FwdIt1 search(FwdIt1 first1, FwdIt1 last1, FwdIt2 first2, FwdIt2 last2, Pred pr);</code></td>
</tr>
<tr>
<td>search_n</td>
<td><algorithm></td>
<td>在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class Dist, class T&gt;</code>  <br /><code>FwdIt search_n(FwdIt first, FwdIt last,Dist n, const T&amp; val);</code>  <br />    <code>template&lt;class FwdIt, class Dist, class T, class Pred&gt;</code> <br /><code>FwdIt search_n(FwdIt first, FwdIt last,Dist n, const T&amp; val, Pred pr);</code></td>
</tr>
</tbody></table>
<h3 id="2、堆算法-4个"><a href="#2、堆算法-4个" class="headerlink" title="2、堆算法(4个)"></a>2、堆算法(4个)</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>头文件</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>make_heap  </code></td>
<td><algorithm></td>
<td>把指定范围内的元素生成一个堆。重载版本使用自定义比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code> template&lt;class RanIt&gt;</code>  <br /><code>void make_heap(RanIt first, RanIt last);</code>  <br />    <code>template&lt;class RanIt, class Pred&gt;</code>  <br /><code>void make_heap(RanIt first, RanIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>pop_heap</code></td>
<td><algorithm></td>
<td>并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class RanIt&gt;</code>  <br /><code>void pop_heap(RanIt first, RanIt last);</code>  <br />    <code>template&lt;class RanIt, class Pred&gt;</code> <br /><code>void pop_heap(RanIt first, RanIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>push_heap  </code></td>
<td><algorithm></td>
<td>假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class RanIt&gt;</code><br /><code>void push_heap(RanIt first, RanIt last);</code>  <br />     <code>template&lt;class RanIt, class Pred&gt;</code>  <br /><code>void push_heap(RanIt first, RanIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>sort_heap </code></td>
<td><algorithm></td>
<td>对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class RanIt&gt; </code> <br /><code>void sort_heap(RanIt first, RanIt last);  </code><br />     <code> template&lt;class RanIt, class Pred&gt;</code>  <br /><code>void sort_heap(RanIt first, RanIt last, Pred pr);</code></td>
</tr>
</tbody></table>
<h3 id="3、关系算法-8个"><a href="#3、关系算法-8个" class="headerlink" title="3、关系算法(8个)"></a>3、关系算法(8个)</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>头文件</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>equal  </code></td>
<td><algorithm></td>
<td>如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt1, class InIt2&gt;</code>  <br /><code>bool equal(InIt1 first, InIt1 last, InIt2 x);</code>  <br />     <code>template&lt;class InIt1, class InIt2, class Pred&gt;</code>  <br /><code>bool equal(InIt1 first, InIt1 last, InIt2 x, Pred pr);</code></td>
</tr>
<tr>
<td><code>includes  </code></td>
<td><algorithm></td>
<td>判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt1, class InIt2&gt;</code> <br /><code>bool includes(InIt1 first1, InIt1 last1,InIt2 first2, InIt2 last2);</code>  <br />     <code>template&lt;class InIt1, class InIt2, class Pred&gt;</code> <br /><code>bool includes(InIt1 first1, InIt1 last1,InIt2 first2, InIt2 last2, Pred pr);</code></td>
</tr>
<tr>
<td><code>lexicographical_compare  </code></td>
<td><algorithm></td>
<td>比较两个序列。重载版本使用用户自定义比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt1, class InIt2&gt;</code> <br /><code>bool lexicographical_compare(InIt1 first1, InIt1 last1,InIt2 first2, InIt2 last2);</code><br />        <code>template&lt;class InIt1, class InIt2, class Pred&gt;</code> <br /><code>bool lexicographical_compare(InIt1 first1, InIt1 last1,InIt2 first2, InIt2 last2, Pred pr);</code></td>
</tr>
<tr>
<td><code>max  </code></td>
<td><algorithm></td>
<td>返回两个元素中较大一个。重载版本使用自定义比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class T&gt;</code>  <br /><code>const T&amp; max(const T&amp; x, const T&amp; y);</code>  <br />     <code>template&lt;class T, class Pred&gt; </code> <br /><code>const T&amp; max(const T&amp; x, const T&amp; y, Pred pr);</code></td>
</tr>
<tr>
<td><code>max_element  </code></td>
<td><algorithm></td>
<td>返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt&gt; </code><br /><code>FwdIt max_element(FwdIt first, FwdIt last);</code>  <br />     <code>template&lt;class FwdIt, class Pred&gt;</code> <br /><code>FwdIt max_element(FwdIt first, FwdIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>min  </code></td>
<td><algorithm></td>
<td>返回两个元素中较小一个。重载版本使用自定义比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class T&gt;</code> <br /><code>const T&amp; min(const T&amp; x, const T&amp; y);</code>  <br />     <code>template&lt;class T, class Pred&gt;</code>  <br /><code>const T&amp; min(const T&amp; x, const T&amp; y, Pred pr);</code></td>
</tr>
<tr>
<td><code>min_element  </code></td>
<td><algorithm></td>
<td>返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt&gt; </code><br /><code>FwdIt min_element(FwdIt first, FwdIt last); </code> <br />     <code>template&lt;class FwdIt, class Pred&gt;</code> <br /><code>FwdIt min_element(FwdIt first, FwdIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>mismatch  </code></td>
<td><algorithm></td>
<td>并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt1, class InIt2&gt;</code>  <br /><code>pair&lt;InIt1, InIt2&gt; mismatch(InIt1 first, InIt1 last, InIt2 x);</code>  <br />      <code> template&lt;class InIt1, class InIt2, class Pred&gt;</code> <br /><code>pair&lt;InIt1, InIt2&gt; mismatch(InIt1 first, InIt1 last, InIt2 x, Pred pr);</code></td>
</tr>
<tr>
<td><code>minmax</code></td>
<td><algorithm></td>
<td>返回一个<code>pair</code>，<code>first</code>为最小值，<code>second</code>为最大值</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>minmax(beg,end),minmax(beg,end,Pre),minmax_element(beg,end,Pre)</code></td>
</tr>
</tbody></table>
<h3 id="4、集合算法-4个"><a href="#4、集合算法-4个" class="headerlink" title="4、集合算法(4个)"></a>4、集合算法(4个)</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>头文件</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>set_union  </code></td>
<td><algorithm></td>
<td>构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt1, class InIt2, class OutIt&gt;</code>  <br /><code>OutIt set_union(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, OutIt x);</code>  <br />     <code>template&lt;class InIt1, class InIt2, class OutIt, class Pred&gt;</code> <br /><code>OutIt set_union(InIt1 first1, InIt1 last1,InIt2 first2, InIt2 last2,OutIt x, Pred pr);</code></td>
</tr>
<tr>
<td><code>set_intersection</code></td>
<td><algorithm></td>
<td>构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt1, class InIt2, class OutIt&gt;</code>  <br /><code>OutIt set_intersection(InIt1 first1, InIt1 last1,InIt2 first2, InIt2 last2, OutIt x); </code> <br />         <code>template&lt;class InIt1, class InIt2, class OutIt, class Pred&gt;</code>  <br /><code>OutIt set_intersection(InIt1 first1, InIt1 last1,InIt2 first2,InIt2 last2, OutIt x, Pred pr);</code></td>
</tr>
<tr>
<td><code>set_difference  </code></td>
<td><algorithm></td>
<td>构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt1, class InIt2, class OutIt</code>&gt;  <br /><code>OutIt set_difference(InIt1 first1, InIt1 last1,InIt2 first2, InIt2 last2, OutIt x);</code>  <br />        <code>template&lt;class InIt1, class InIt2, class OutIt, class Pred&gt;</code> <br /><code>OutIt set_difference(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, OutIt x, Pred pr);</code></td>
</tr>
<tr>
<td>set_symmetric_difference</td>
<td><algorithm></td>
<td>构造一个有序序列，该序列取两个序列的对称差集(并集-交集)</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt1, class InIt2, class OutIt&gt;</code>  <br /><code>OutIt set_symmetric_difference(InIt1 first1, InIt1 last1,  InIt2 first2, InIt2 last2, OutIt x); </code> <br />        <code>template&lt;class InIt1, class InIt2, class OutIt, class Pred&gt; </code><br /><code>OutIt set_symmetric_difference(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2, OutIt x, Pred pr);</code></td>
</tr>
</tbody></table>
<h3 id="5、列组合算法-2个"><a href="#5、列组合算法-2个" class="headerlink" title="5、列组合算法(2个)"></a>5、列组合算法(2个)</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>头文件</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>next_permutation  </code></td>
<td><algorithm></td>
<td>全排列，从小到大排。由于返回值是<code>bool</code>，所以可以使用<code>while</code>遍历每次的排序结果。重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class BidIt&gt;</code>  <br /><code>bool next_permutation(BidIt first, BidIt last);</code>  <br />      <code>template&lt;class BidIt, class Pred&gt;</code>  <br /><code>bool next_permutation(BidIt first, BidIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>prev_permutation</code></td>
<td><algorithm></td>
<td>全排列，从大到小排。由于返回值是<code>bool</code>，所以可以使用<code>while</code>遍历每次的排序结果。重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class BidIt&gt;</code>  <br /><code>bool prev_permutation(BidIt first, BidIt last); </code> <br />       <code>template&lt;class BidIt, class Pred&gt;</code> <br /><code>bool prev_permutation(BidIt first, BidIt last, Pred pr);</code></td>
</tr>
</tbody></table>
<h3 id="6、排序和通用算法-14个-：提供元素排序策略"><a href="#6、排序和通用算法-14个-：提供元素排序策略" class="headerlink" title="6、排序和通用算法(14个)：提供元素排序策略"></a>6、排序和通用算法(14个)：提供元素排序策略</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>头文件</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>inplace_merge  </code></td>
<td><algorithm></td>
<td>当 2 个有序序列存储在同一个数组或容器中时，如果想将它们合并为 1 个有序序列，可以采用该算法。重载版本使用输入的操作进行排序</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code> template&lt;class BidIt&gt;</code>  <br /><code>void inplace_merge(BidIt first, BidIt middle, BidIt last);</code>  <br />       <code>template&lt;class BidIt, class Pred&gt;</code> <br /><code>void inplace_merge(BidIt first, BidIt middle, BidIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>merge  </code></td>
<td><algorithm></td>
<td>合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt1, class InIt2, class OutIt&gt;</code>  <br /><code>OutIt merge(InIt1 first1, InIt1 last1,InIt2 first2, InIt2 last2, OutIt x);</code>  <br />      <code>template&lt;class InIt1, class InIt2, class OutIt, class Pred&gt;</code>  <br /><code>OutIt merge(InIt1 first1, InIt1 last1,InIt2 first2, InIt2 last2, OutIt x, Pred pr);</code></td>
</tr>
<tr>
<td><code>nth_element  </code></td>
<td><algorithm></td>
<td>将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class RanIt&gt; </code> <br /><code>void nth_element(RanIt first, RanIt nth, RanIt last);  </code><br />      <code>template&lt;class RanIt, class Pred&gt; </code> <br /><code>void nth_element(RanIt first, RanIt nth, RanIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>partial_sort  </code></td>
<td><algorithm></td>
<td>对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class RanIt&gt;</code>  <br /><code>void partial_sort(RanIt first, RanIt middle, RanIt last); </code> <br />      <code>template&lt;class RanIt, class Pred&gt;</code> <br /><code>void partial_sort(RanIt first, RanIt middle, RanIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>partial_sort_copy  </code></td>
<td><algorithm></td>
<td>与partial_sort类似，不过将经过排序的序列复制到另一个容器</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt, class RanIt&gt;</code>  <br /><code>RanIt partial_sort_copy(InIt first1, InIt last1,RanIt first2, RanIt last2);</code>  <br />      <code>template&lt;class InIt, class RanIt, class Pred&gt;</code> <br /><code>RanIt partial_sort_copy(InIt first1, InIt last1,RanIt first2, RanIt last2, Pred pr);</code></td>
</tr>
<tr>
<td><code>partition  </code></td>
<td><algorithm></td>
<td>对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class BidIt, class Pred&gt;  BidIt partition(BidIt first, BidIt last, Pred pr); </code></td>
</tr>
<tr>
<td><code>partition_copy</code></td>
<td><algorithm></td>
<td>满足条件的放到<code>dst1</code>,不满足条件的放到<code>dst2</code>，返回一个<code>pair</code>，<code>first</code>表示<code>dst1.end()</code>，<code>second</code>表示<code>dst2.end()</code></td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>partition_copy(beg,end,dest1,dest2,Prf)</code></td>
</tr>
<tr>
<td><code>random_shuffle  </code></td>
<td><algorithm></td>
<td>对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code> template&lt;class RanIt&gt;</code>  <br /><code>void random_shuffle(RanIt first, RanIt last); </code> <br />      <code>template&lt;class RanIt, class Fun&gt;</code>  <br /><code>void random_shuffle(RanIt first, RanIt last, Fun&amp; f);</code></td>
</tr>
<tr>
<td><code>reverse  </code></td>
<td><algorithm></td>
<td>将指定范围内元素重新反序排序</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class BidIt&gt;</code>  <br /><code>void reverse(BidIt first, BidIt last);  </code></td>
</tr>
<tr>
<td><code>reverse_copy  </code></td>
<td><algorithm></td>
<td>与reverse类似，不过将结果写入另一个容器</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class BidIt, class OutIt&gt; </code><br /><code>OutIt reverse_copy(BidIt first, BidIt last, OutIt x);</code></td>
</tr>
<tr>
<td><code>rotate  </code></td>
<td><algorithm></td>
<td>将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt&gt;</code>  <br /><code>void rotate(FwdIt first, FwdIt middle, FwdIt last);  </code></td>
</tr>
<tr>
<td><code>rotate_copy  </code></td>
<td><algorithm></td>
<td>与rotate类似，不过将结果写入另一个容器</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class OutIt&gt;</code>  <br /><code>OutIt rotate_copy(FwdIt first, FwdIt middle, FwdIt last, OutIt x);  </code></td>
</tr>
<tr>
<td><code>sort  </code></td>
<td><algorithm></td>
<td>以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class RanIt&gt;</code>  <br /><code>void sort(RanIt first, RanIt last);</code>  <br />     <code>template&lt;class RanIt, class Pred&gt;</code><br /><code>void sort(RanIt first, RanIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>stable_sort  </code></td>
<td><algorithm></td>
<td>与sort类似，不过保留相等元素之间的顺序关系</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class BidIt&gt;</code>  <br /><code>void stable_sort(BidIt first, BidIt last);</code>  <br />    <code>template&lt;class BidIt, class Pred&gt;</code>  <br /><code>void stable_sort(BidIt first, BidIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>stable_partition  </code></td>
<td><algorithm></td>
<td>与partition类似，不过不保证保留容器中的相对顺序</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class Pred&gt;</code>  <br /><code>FwdIt stable_partition(FwdIt first, FwdIt last, Pred pr);  </code></td>
</tr>
</tbody></table>
<h3 id="7、删除和替换算法-15个"><a href="#7、删除和替换算法-15个" class="headerlink" title="7、删除和替换算法(15个)"></a>7、删除和替换算法(15个)</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>头文件</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>copy  </code></td>
<td><algorithm></td>
<td>复制序列</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt, class OutIt&gt;</code>  <br /><code>OutIt copy(InIt first, InIt last, OutIt x);  </code></td>
</tr>
<tr>
<td><code>copy_if</code></td>
<td><algorithm></td>
<td>拷贝满足调节的序列</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>copy_if(beg,end,Pre)</code></td>
</tr>
<tr>
<td><code>copy_n</code></td>
<td><algorithm></td>
<td>拷贝前n个序列，输入序列必须大于n</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>copy_n(beg,n,dst)</code></td>
</tr>
<tr>
<td><code>move</code></td>
<td><algorithm></td>
<td>对调用输入序列调用move输入目标序列</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>move(beg,end,dst)</code></td>
</tr>
<tr>
<td><code>move_backward</code></td>
<td><algorithm></td>
<td>对调用输入序列调用move输入目标序列,只不过dst是目标序列的尾部迭代器，他从尾部开始move，结果与输入相同</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>move(beg,end,dst)</code></td>
</tr>
<tr>
<td><code>copy_backward  </code></td>
<td><algorithm></td>
<td>与copy相同，不过元素是以相反顺序被拷贝</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class BidIt1, class BidIt2&gt;</code>  <br /><code>BidIt2 copy_backward(BidIt1 first, BidIt1 last, BidIt2 x);  </code></td>
</tr>
<tr>
<td><code>iter_swap  </code></td>
<td><algorithm></td>
<td>交换两个ForwardIterator的值</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt1, class FwdIt2&gt;</code>  <br /><code>void iter_swap(FwdIt1 x, FwdIt2 y);  </code></td>
</tr>
<tr>
<td><code>remove  </code></td>
<td><algorithm></td>
<td>删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class T&gt;</code>  <br /><code>FwdIt remove(FwdIt first, FwdIt last, const T&amp; val); </code></td>
</tr>
<tr>
<td><code>remove_copy  </code></td>
<td><algorithm></td>
<td>将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt, class OutIt, class T&gt;</code>  <br /><code>OutIt remove_copy(InIt first, InIt last, OutIt x, const T&amp; val);  </code></td>
</tr>
<tr>
<td><code>remove_if  </code></td>
<td><algorithm></td>
<td>删除指定范围内输入操作结果为true的所有元素</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class Pred&gt;</code>  <br /><code>FwdIt remove_if(FwdIt first, FwdIt last, Pred pr); </code></td>
</tr>
<tr>
<td><code>remove_copy_if  </code></td>
<td><algorithm></td>
<td>将所有不匹配元素拷贝到一个指定容器</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt, class OutIt, class Pred&gt;</code>  <br /><code>OutIt remove_copy_if(InIt first, InIt last, OutIt x, Pred pr);  </code></td>
</tr>
<tr>
<td>replace</td>
<td><algorithm></td>
<td>将指定范围内所有等于vold的元素都用vnew代替</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class T&gt;</code>  <br /><code>void replace(FwdIt first, FwdIt last,const T&amp; vold, const T&amp; vnew);  </code></td>
</tr>
<tr>
<td><code>replace_copy  </code></td>
<td><algorithm></td>
<td>与replace类似，不过将结果写入另一个容器</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt, class OutIt, class T&gt;</code>  <br /><code>OutIt replace_copy(InIt first, InIt last, OutIt x,const T&amp; vold, const T&amp; vnew); </code></td>
</tr>
<tr>
<td><code>replace_if  </code></td>
<td><algorithm></td>
<td>将指定范围内所有操作结果为true的元素用新值代替</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code> template&lt;class FwdIt, class Pred, class T&gt;</code>  <br /><code>void replace_if(FwdIt first, FwdIt last,Pred pr, const T&amp; val);  </code></td>
</tr>
<tr>
<td><code>replace_copy_if  </code></td>
<td><algorithm></td>
<td>与replace_if，不过将结果写入另一个容器</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt, class OutIt, class Pred, class T&gt;</code>  <br /><code>OutIt replace_copy_if(InIt first, InIt last, OutIt x, Pred pr, const T&amp; val); </code></td>
</tr>
<tr>
<td><code>swap  </code></td>
<td><algorithm></td>
<td>交换存储在两个对象中的值</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class T&gt;</code>  <br /><code>void swap(T&amp; x, T&amp; y);  </code></td>
</tr>
<tr>
<td><code>swap_range  </code></td>
<td><algorithm></td>
<td>将指定范围内的元素与另一个序列元素值进行交换</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt1, class FwdIt2&gt;</code>  <br /><code>FwdIt2 swap_ranges(FwdIt1 first, FwdIt1 last, FwdIt2 x); </code></td>
</tr>
<tr>
<td><code>unique  </code></td>
<td><algorithm></td>
<td>清除有序序列中重复元素，和remove类似，它也不能真正删除元素而是排在后面。重载版本使用自定义比较操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt&gt;</code>  <br /><code>FwdIt unique(FwdIt first, FwdIt last);</code>  <br />    <code> template&lt;class FwdIt, class Pred&gt;</code> <br /><code>FwdIt unique(FwdIt first, FwdIt last, Pred pr);</code></td>
</tr>
<tr>
<td><code>unique_copy  /unique_copy_if </code></td>
<td><algorithm></td>
<td>与unique类似，不过把结果输出到另一个容器</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt, class OutIt&gt;</code>  <br /><code>OutIt unique_copy(InIt first, InIt last, OutIt x)</code>;  <br />      <code>template&lt;class InIt, class OutIt, class Pred&gt;</code>  <br /><code>OutIt unique_copy(InIt first, InIt last, OutIt x, Pred pr);</code></td>
</tr>
</tbody></table>
<h3 id="8、生成和变异算法-6个"><a href="#8、生成和变异算法-6个" class="headerlink" title="8、生成和变异算法(6个)"></a>8、生成和变异算法(6个)</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>头文件</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>fill  </code></td>
<td><algorithm></td>
<td>将输入值赋给标志范围内的所有元素</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class T&gt;</code>  <br /><code>void fill(FwdIt first, FwdIt last, const T&amp; x);  </code></td>
</tr>
<tr>
<td><code>fill_n  </code></td>
<td><algorithm></td>
<td>将输入值赋给first到first+n范围内的所有元素</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class OutIt, class Size, class T&gt;</code>  <br /><code>void fill_n(OutIt first, Size n, const T&amp; x);  </code></td>
</tr>
<tr>
<td><code>for_each  </code></td>
<td><algorithm></td>
<td>用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt, class Fun&gt;</code>  <br /><code>Fun for_each(InIt first, InIt last, Fun f);  </code></td>
</tr>
<tr>
<td><code>generate  </code></td>
<td><algorithm></td>
<td>连续调用输入的函数来填充指定的范围</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class FwdIt, class Gen&gt;</code>  <br /><code>void generate(FwdIt first, FwdIt last, Gen g); </code></td>
</tr>
<tr>
<td><code>generate_n</code></td>
<td><algorithm></td>
<td>与generate函数类似，填充从指定iterator开始的n个元素</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code> template&lt;class OutIt, class Pred, class Gen&gt;</code>  <br /><code>void generate_n(OutIt first, Dist n, Gen g);  </code></td>
</tr>
<tr>
<td><code>transform  </code></td>
<td><algorithm></td>
<td>将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code> template&lt;class InIt, class OutIt, class Unop&gt;</code>  <br /><code>OutIt transform(InIt first, InIt last, OutIt x, Unop uop);</code>  <br />     <code>template&lt;class InIt1, class InIt2, class OutIt, class Binop&gt;</code> <br /><code>OutIt transform(InIt1 first1, InIt1 last1, InIt2 first2,OutIt x, Binop bop);</code></td>
</tr>
</tbody></table>
<h3 id="9、算数算法-4个"><a href="#9、算数算法-4个" class="headerlink" title="9、算数算法(4个)"></a>9、算数算法(4个)</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>头文件</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>accumulate</code></td>
<td><numeric></td>
<td>iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code> template&lt;class InIt, class T&gt;</code>  <br /><code>T accumulate(InIt first, InIt last, T val);</code>  <br />     <code>template&lt;class InIt, class T, class Pred&gt;</code>  <br /><code>T accumulate(InIt first, InIt last, T val, Pred pr);</code></td>
</tr>
<tr>
<td><code>partial_sum  </code></td>
<td><numeric></td>
<td>创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code> template&lt;class InIt, class OutIt&gt;</code>  <br /><code>OutIt partial_sum(InIt first, InIt last,OutIt result); </code> <br />    <code> template&lt;class InIt, class OutIt, class Pred&gt;</code>  <br /><code>OutIt partial_sum(InIt first, InIt last,OutIt result, Pred pr);</code></td>
</tr>
<tr>
<td><code>inner_product  </code></td>
<td><numeric></td>
<td>对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt1, class InIt2, class T&gt;</code>  <br /><code>T product(InIt1 first1, InIt1 last1,Init2 first2, T val);</code>  <br />     <code>template&lt;class InIt1, class InIt2, class T,class Pred1, class Pred2&gt;</code> <br /><code>T product(InIt1 first1, InIt1 last1,Init2 first2, T val, Pred1 pr1, Pred2 pr2);</code></td>
</tr>
<tr>
<td><code>adjacent_difference  </code></td>
<td><numeric></td>
<td>创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>template&lt;class InIt, class OutIt&gt;</code>  <br /><code>OutIt adjacent_difference(InIt first, InIt last,OutIt result);</code>  <br />     <code>template&lt;class InIt, class OutIt, class Pred&gt;</code> <br /><code>OutIt adjacent_difference(InIt first, InIt last,OutIt result, Pred pr);</code></td>
</tr>
<tr>
<td><code>iota</code></td>
<td><numeric></td>
<td>将<code>val</code>的值赋值给首序列，并不断递增val，不断赋值给下一个</td>
</tr>
<tr>
<td></td>
<td>函数原形</td>
<td><code>iota(beg,end,val)</code></td>
</tr>
</tbody></table>
<h3 id="10、常用算法"><a href="#10、常用算法" class="headerlink" title="10、常用算法"></a>10、常用算法</h3><h4 id="10-1、遍历算法"><a href="#10-1、遍历算法" class="headerlink" title="10.1、遍历算法"></a>10.1、遍历算法</h4><h5 id="10-1-1、for-each"><a href="#10-1-1、for-each" class="headerlink" title="10.1.1、for_each"></a>10.1.1、for_each</h5><p>用于遍历整个容器，例如<br><code>for_each(v.begin(),v.end(),[](const string&amp; s)&#123;cout&lt;&lt;ss&lt;&lt;endl;&#125;)</code>,遍历整个容器，并进行输出，可以通过<code>lambda</code>表达式实现。         </p>
<h5 id="10-1-2、transform"><a href="#10-1-2、transform" class="headerlink" title="10.1.2、transform"></a>10.1.2、transform</h5><p>用于遍历整个容器，并改变容器的值，例如<br><code>transform(vi.begin(),vi.end(),[](int i)&#123; return i&lt;0?-i :i&#125;)</code>;遍历整个容器，并对所有的值进行取绝对值。</p>
<h4 id="10-2、查找算法"><a href="#10-2、查找算法" class="headerlink" title="10.2、查找算法"></a>10.2、查找算法</h4><h5 id="10-2-1、find与find-if"><a href="#10-2-1、find与find-if" class="headerlink" title="10.2.1、find与find_if"></a>10.2.1、find与find_if</h5><ol>
<li>用于寻找在迭代器中符合条件的位置，通过<code>auto it=find(list.begin(),list.end,&quot;A&quot;)</code>,来寻找在<code>list</code>中包含’A’的位置，并返回list中的首位置。</li>
<li>也是用于寻找在迭代器中符合条件的位置，只不过他是通过调用一元谓词来判断，例如<code>auto wc=find_if(w.begin(),w.end(),[sz](const string &amp;a)-&gt;bool &#123;return sz&gt;a.size()&#125;)</code>,返回值将返回w中的<code>size</code>大于<code>sz</code>的第一个位置。</li>
</ol>
<h5 id="10-2-2、adjacent-find"><a href="#10-2-2、adjacent-find" class="headerlink" title="10.2.2、adjacent_find()"></a>10.2.2、adjacent_find()</h5><p>在<code>iterator</code>对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。<code>vector&lt;int&gt;::iterator it = adjacent_find(vecInt.begin(), vecInt.end());  </code></p>
<h5 id="10-2-3、binary-search"><a href="#10-2-3、binary-search" class="headerlink" title="10.2.3、binary_search"></a>10.2.3、binary_search</h5><p>在有序序列中查找<code>value</code>,找到则返回<code>true</code>。注意：在无序序列中，不可使用。<code>bool bFind = binary_search(setInt.begin(),setInt.end(),5);</code></p>
<h5 id="10-2-4、count和count-if"><a href="#10-2-4、count和count-if" class="headerlink" title="10.2.4、count和count_if"></a>10.2.4、count和count_if</h5><p><code>count</code>：利用等于操作符，把标志范围内的元素与输入值比较，返回相等的个数。<code>int iCount = count(vecInt.begin(),vecInt.end(),2);</code><br><code>count_if:</code>利用谓词进行就算满足谓词条件的个数，<code>int iCount = count_if(vecIntA.begin(), vecIntA.end(), [=](int i)&#123;return i&gt;3 ? true:false&#125;);</code></p>
<h4 id="10-3、排序算法"><a href="#10-3、排序算法" class="headerlink" title="10.3、排序算法"></a>10.3、排序算法</h4><h5 id="10-3-1、sort"><a href="#10-3-1、sort" class="headerlink" title="10.3.1、sort"></a>10.3.1、sort</h5><p>对容器进行排序，例如<code>sort(word.begin(),word.end())</code>,默认从小到大排，也可以用<code>greater&lt;int&gt;()</code>进行从大到小排，或者自己重写谓词:<br><code>bool Compare(const int &amp;v1,const int &amp;v2)</code></p>
<h5 id="10-3-2、reverse"><a href="#10-3-2、reverse" class="headerlink" title="10.3.2、reverse"></a>10.3.2、reverse</h5><p>用于对容器的顺序进行反转，例如<code>reverse(v.begin(),v.end())    </code>，对输入的元素进行反转</p>
<h5 id="10-3-3、merge"><a href="#10-3-3、merge" class="headerlink" title="10.3.3、merge()"></a>10.3.3、merge()</h5><p><strong>合并两个有序序列</strong>，存放到另一个序列。<code>merge(vecIntA.begin(),vecIntA.end(),vecIntB.begin(),vecIntB.end(),vecIntC.begin());</code></p>
<h5 id="10-3-4、random-shuffle"><a href="#10-3-4、random-shuffle" class="headerlink" title="10.3.4、random_shuffle()"></a>10.3.4、random_shuffle()</h5><p>对指定范围内的元素随机调整次序。<code>需要设置设置随机种子：srand(time(0));random_shuffle(vecInt.begin(), vecInt.end()); </code></p>
<h4 id="10-4、拷贝和替换算法"><a href="#10-4、拷贝和替换算法" class="headerlink" title="10.4、拷贝和替换算法"></a>10.4、拷贝和替换算法</h4><h5 id="10-4-1、copy"><a href="#10-4-1、copy" class="headerlink" title="10.4.1、copy"></a>10.4.1、copy</h5><p>用于对容器<code>v2</code>的拷贝,<code>v2</code>本身必须就有值，例如<code>auto ret=copy(v1.begin(),v1.end(),v2.begin())</code>,把<code>v1</code>的值拷贝到<code>v2</code>中，然后将返回一个指向拷贝后v2的尾元素之后位置。</p>
<h5 id="10-4-2、replace、replace-copy和replace-if"><a href="#10-4-2、replace、replace-copy和replace-if" class="headerlink" title="10.4.2、replace、replace_copy和replace_if"></a>10.4.2、replace、replace_copy和replace_if</h5><p>一个是用来替换，一个是用来拷贝然后再替换，例如<br><code>replace(list.begin(),list.end(),0,42)</code>、<code>replace_copy(list.begin(),list.end(),back_insert(ivec),0,42)</code>和<code>replace_if(vecIntA.begin(), vecIntA.end(), [=](int i)&#123;return i&gt;8;&#125;, 8);</code>，第一个是把<code>list</code>里面的0替换成42，然后第二个把<code>ivec</code>里面为0的值替换成42,并拷贝给<code>ivec</code>，<code>list</code>本身不变。第三个是把符合谓词的替换成8.</p>
<h5 id="10-4-3-swap"><a href="#10-4-3-swap" class="headerlink" title="10.4.3 swap()"></a>10.4.3 swap()</h5><p> 交换两个容器的元素。<code>swap(vecIntA, vecIntB); //交换</code></p>
<h5 id="10-4-4、remove-if"><a href="#10-4-4、remove-if" class="headerlink" title="10.4.4、remove_if"></a>10.4.4、remove_if</h5><p>使用算法删除容器的里的值，例如<code>remove(v1.begin(),v1.end(),[]int(i)&#123;return i%2&#125;)</code>；删除容器中的奇数</p>
<h5 id="10-4-5、unique"><a href="#10-4-5、unique" class="headerlink" title="10.4.5、unique"></a>10.4.5、unique</h5><p>”消除“重复的数据，让每个数据只出现一次，例如<br><code>auto end_unique=unique(word.begin(),word.end())</code>,这样就可以把其安装单个排序，需要注意的是<strong>unique操作的是迭代器，所以它并不是真正的删除容器的数值，只是把顺序重新排列，然后把重复的排在了最后面，而返回来的则是排序后的最后一个不重复元素之后的位置</strong>,然后需要调用<code>word.erase(end_unique,word.end())</code>进行删除。</p>
<h4 id="10-5、算术和生成方法"><a href="#10-5、算术和生成方法" class="headerlink" title="10.5、算术和生成方法"></a>10.5、算术和生成方法</h4><h5 id="10-5-1、accumulate"><a href="#10-5-1、accumulate" class="headerlink" title="10.5.1、accumulate"></a>10.5.1、accumulate</h5><p>用于计算容器的累计总和，例如<code>int sum=accumlate(itList.cbegin(),itList.cend(),0)</code>,把<code>list</code>的值进行求和，并且初始值为0，结果返回给sum。同时他也可以对<code>string</code>类型的<code>vector</code>进行求和,结果是所有<code>string</code>的合并。</p>
<h5 id="10-5-2-fill与fill-n"><a href="#10-5-2-fill与fill-n" class="headerlink" title="10.5.2 fill与fill_n"></a>10.5.2 fill与fill_n</h5><p>用于对容器进行同一化，<strong>需要注意的是进行该操作的容器必需本身就存在值</strong>，例如<code>fill(vec.begin(),vec.end(),0)</code>或<code>fill_n(vec.begin(),10,0)</code>;将<code>vec</code>里面的值全都置为0，或者把<code>vec</code>的前十个置为。   </p>
<h5 id="10-5-3、equal"><a href="#10-5-3、equal" class="headerlink" title="10.5.3、equal"></a>10.5.3、equal</h5><p>用于比较两个容器是否相等，例如<br><code>bool result=equal(roster1.cbegin(),roster1.end(),roster2.cbegin())</code>;要求<code>roster2</code>的数目至少和<code>roster1</code>一样多，相等就返回<code>true</code>给<code>result</code>。</p>
<h4 id="10-6、集合算法"><a href="#10-6、集合算法" class="headerlink" title="10.6、集合算法"></a>10.6、集合算法</h4><h5 id="10-6-1-set-union"><a href="#10-6-1-set-union" class="headerlink" title="10.6.1 set_union"></a>10.6.1 set_union</h5><p>构造一个<strong>有序序列</strong>，包含两个有序序列的并集。<code>set_union(vecIntA.begin(), vecIntA.end(), vecIntB.begin(), vecIntB.end(), vecIntC.begin());</code></p>
<h5 id="10-6-2、set-intersection"><a href="#10-6-2、set-intersection" class="headerlink" title="10.6.2、set_intersection"></a>10.6.2、set_intersection</h5><p>构造一个<strong>有序序列</strong>，包含两个有序序列的交集。<code>set_intersection(vecIntA.begin(), vecIntA.end(), vecIntB.begin(), vecIntB.end(), vecIntC.begin());</code></p>
<h5 id="10-6-3、set-difference"><a href="#10-6-3、set-difference" class="headerlink" title="10.6.3、set_difference"></a>10.6.3、set_difference</h5><p>构造一个有序序列，该序列保留第一个有序序列中存在而第二个有序序列中不存在的元素。<code>set_difference(vecIntA.begin(), vecIntA.end(), vecIntB.begin(), vecIntB.end(), vecIntC.begin());</code></p>
<p>​     </p>
<p>​     </p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>容器算法</tag>
      </tags>
  </entry>
  <entry>
    <title>extern、typedef的常规使用</title>
    <url>/2020/11/03/extern%E3%80%81typedef%E7%9A%84%E5%B8%B8%E8%A7%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1、全局变量的定义extern"><a href="#1、全局变量的定义extern" class="headerlink" title="1、全局变量的定义extern"></a>1、全局变量的定义extern</h3><p>在有些情况中，我们通常会定义多个文件进行编程，而有些变量有时是需要我们在多个文件同时使用的，此时可以按如下方法定义：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.c文件</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> value=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>​         </p>
<p>​        </p>
<h3 id="2、typedef与const结合时的注意事项"><a href="#2、typedef与const结合时的注意事项" class="headerlink" title="2、typedef与const结合时的注意事项"></a>2、typedef与const结合时的注意事项</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* Pint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> Pint p1=&amp;value;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p2=&amp;value;</span><br><span class="line">*p1=<span class="number">30</span>;</span><br><span class="line">*p2=<span class="number">40</span>;</span><br></pre></td></tr></table></figure>
<p>此时在<code>*p2=40</code>处会报错，而<code>*p1=30</code>则不会。因为当使用typedef定义了<code>int*</code>后，<code>int*</code>变成了一个整体，所以<code>const</code>的修饰变成了p1，类似于<br><code>int *const p1=&amp;value</code>，此时<code>cosnt</code>修饰的是<code>p1</code>这个地址，而<code>const int* p2=&amp;value</code>修饰的是<code>*p2</code>这个值，所以值不能修改，报错。  </p>
<p>​    </p>
<p>​     </p>
]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>extern</tag>
        <tag>typedef</tag>
      </tags>
  </entry>
  <entry>
    <title>指针函数、指针函数与Function</title>
    <url>/2020/11/03/%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E3%80%81%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E4%B8%8EFunction/</url>
    <content><![CDATA[<h3 id="1、指针函数"><a href="#1、指针函数" class="headerlink" title="1、指针函数"></a>1、指针函数</h3><p>指针函数与普通的函数差不多，只不过他的函数返回值是指针类型的而已。格式：<code>int *fun(int x,int y)</code>;<a id="more"></a><br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*指针函数*/</span></span><br><span class="line"><span class="function">Data* <span class="title">f</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    Data * data = <span class="keyword">new</span> Data();</span><br><span class="line">    data-&gt;a = a;</span><br><span class="line">    data-&gt;b = b;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//调用指针函数</span></span><br><span class="line">    Data * myData = f(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;f(4,5) = &quot;</span> &lt;&lt; myData-&gt;a &lt;&lt; myData-&gt;b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">f(<span class="number">4</span>,<span class="number">5</span>) =  <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>​         </p>
<p>​         </p>
<h3 id="2、函数指针"><a href="#2、函数指针" class="headerlink" title="2、函数指针"></a>2、函数指针</h3><p>函数指针的本质其实是一个指针，只不过他是指向一个<strong>特定函数类型的指针</strong>，感觉就是为了方便调用,因为他与普通的函数的区别是可以套用相同格式的多个函数。格式<code>int (*fun)(int x,int y);</code><br><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">int</span> (*fun)(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">等价申明:</span></span><br><span class="line"><span class="comment">typedef decltype(sub) *fun;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//第一种写法</span></span><br><span class="line">    fun = add;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;(*fun)(1,2) = &quot;</span> &lt;&lt; (*fun)(<span class="number">1</span>,<span class="number">2</span>) ;</span><br><span class="line">	<span class="comment">//第二种写法</span></span><br><span class="line">    fun = &amp;sub;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;(*fun)(5,3) = &quot;</span> &lt;&lt; (*fun)(<span class="number">5</span>,<span class="number">3</span>)  &lt;&lt; fun(<span class="number">5</span>,<span class="number">3</span>)；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">(*fun)(<span class="number">1</span>,<span class="number">2</span>) =  <span class="number">3</span></span><br><span class="line">(*fun)(<span class="number">5</span>,<span class="number">2</span>) =  <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="3、function类模板"><a href="#3、function类模板" class="headerlink" title="3、function类模板"></a>3、function类模板</h3><h4 id="3-1、-std-function-简介"><a href="#3-1、-std-function-简介" class="headerlink" title="3.1、 std::function 简介"></a>3.1、 std::function 简介</h4><p> 类模板std :: function是一个通用的多态函数包装器。 std :: function的实例可以存储，复制和调用任何可调用的目标 ：包括函数，lambda表达式，绑定表达式或其他函数对象，以及指向成员函数和指向数据成员的指针。当std::function对象未包裹任何实际的可调用元素，调用该std::function对象将抛出std::bad_function_call异常。</p>
<h4 id="3-2、function类模板"><a href="#3-2、function类模板" class="headerlink" title="3.2、function类模板"></a>3.2、function类模板</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;</span>R(Args...)&gt;;</span><br></pre></td></tr></table></figure>

<p>模板参数说明：</p>
<ul>
<li>R: 被调用函数的返回类型</li>
<li>Args…：被调用函数的形参</li>
</ul>
<p>例如：<code>function&lt;int(int,int)&gt; func;</code><br> 则 <code>function</code>类的实例<code>func</code>可以指向 返回值为int型，有两个形参都为int型的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;func = f;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f(<span class="number">1</span>, <span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;      <span class="comment">// 3</span></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来先来看看以前C和C++98的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c type global function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function object</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Func)</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">   Func func = c_func;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt; func(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//3</span></span><br><span class="line">   </span><br><span class="line">   functor ft;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;ft(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//3</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面我们可以看出，使用C++11的function类调用函数方便多了。</p>
<p>虽然是function是类模板，但其只有成员函数，无数据成员。</p>
<h4 id="3-3、function的成员函数"><a href="#3-3、function的成员函数" class="headerlink" title="3.3、function的成员函数"></a>3.3、function的成员函数</h4><table>
<thead>
<tr>
<th>成员函数声明</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>constructor</td>
<td>构造函数：constructs a new std::function instance</td>
</tr>
<tr>
<td>destructor</td>
<td>析构函数： destroys a std::function instance</td>
</tr>
<tr>
<td>operator=</td>
<td>给定义的function对象赋值</td>
</tr>
<tr>
<td>operator bool</td>
<td>检查定义的function对象是否包含一个有效的对象</td>
</tr>
<tr>
<td>operator()</td>
<td>调用一个对象</td>
</tr>
</tbody></table>
<h4 id="3-4、std-function用法详解"><a href="#3-4、std-function用法详解" class="headerlink" title="3.4、std::function用法详解"></a>3.4、std::function用法详解</h4><h5 id="3-4-1、调用普通函数"><a href="#3-4-1、调用普通函数" class="headerlink" title="3.4.1、调用普通函数"></a>3.4.1、调用普通函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a+b;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;func = f;</span><br><span class="line">   	<span class="built_in">cout</span>&lt;&lt;func(<span class="number">1</span>, <span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;      <span class="comment">// 3</span></span><br><span class="line">   	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-2、调用函数对象"><a href="#3-4-2、调用函数对象" class="headerlink" title="3.4.2、调用函数对象"></a>3.4.2、调用函数对象</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function object</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   functor ft;</span><br><span class="line">   function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; func = ft;</span><br><span class="line">   <span class="comment">//function&lt;int(int, int)&gt; func = functor();  Yes</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;func(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//3</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-3、调用模板函数对象"><a href="#3-4-3、调用模板函数对象" class="headerlink" title="3.4.3、调用模板函数对象"></a>3.4.3、调用模板函数对象</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function object</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   functor&lt;<span class="keyword">int</span>&gt; ft;</span><br><span class="line">	 function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; func = ft;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;func(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//3</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-4、调用lambda表达式"><a href="#3-4-4、调用lambda表达式" class="headerlink" title="3.4.4、调用lambda表达式"></a>3.4.4、调用lambda表达式</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> f = [](<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">	<span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;func = f;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; func(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">// 3</span></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-5、调用类静态成员函数"><a href="#3-4-5、调用类静态成员函数" class="headerlink" title="3.4.5、调用类静态成员函数"></a>3.4.5、调用类静态成员函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f = &amp;Plus::plus;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//3</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);                                       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-6、调用类成员函数"><a href="#3-4-6、调用类成员函数" class="headerlink" title="3.4.6、调用类成员函数"></a>3.4.6、调用类成员函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Plus p;</span><br><span class="line">    function&lt;<span class="keyword">int</span>(Plus&amp;,<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f = &amp;Plus::plus;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(p,<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//3</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);                                       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-7、调用类公有数据成员"><a href="#3-4-7、调用类公有数据成员" class="headerlink" title="3.4.7、调用类公有数据成员"></a>3.4.7、调用类公有数据成员</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Plus(<span class="keyword">int</span> num_):num(num_)&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	    <span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	    </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> a + b;</span><br><span class="line">	    &#125;</span><br><span class="line">	   <span class="keyword">int</span>  num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Plus <span class="title">p</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    function&lt;<span class="keyword">int</span>(<span class="keyword">const</span> Plus&amp;)&gt; f = &amp;Plus::num;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(p) &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//2</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);                                       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-8、通过bind函数调用类成员函数"><a href="#3-4-8、通过bind函数调用类成员函数" class="headerlink" title="3.4.8、通过bind函数调用类成员函数"></a>3.4.8、通过bind函数调用类成员函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Plus p;</span><br><span class="line">   <span class="comment">// 指针形式调用成员函数</span></span><br><span class="line">   function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f = bind(&amp;Plus::plus, &amp;p, placeholders::_1, placeholders::_2);<span class="comment">// placeholders::_1是占位符</span></span><br><span class="line">   <span class="comment">// 对象形式调用成员函数</span></span><br><span class="line">   function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = bind(&amp;Plus::plus, p, placeholders::_1, placeholders::_2);<span class="comment">// placeholders::_1是占位符</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; f(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//3</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; f1(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">//3</span></span><br><span class="line">   system(<span class="string">&quot;pause&quot;</span>);                                       </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-9、Map与function"><a href="#3-4-9、Map与function" class="headerlink" title="3.4.9、Map与function"></a>3.4.9、Map与function</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i % j; &#125;;</span><br><span class="line"><span class="comment">// 函数对象类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divide</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> denominator / divisor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">///SubMain//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops = </span><br><span class="line">	&#123;</span><br><span class="line">		&#123; <span class="string">&#x27;+&#x27;</span>, add &#125;,</span><br><span class="line">		&#123; <span class="string">&#x27;-&#x27;</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i - j; &#125; &#125;,</span><br><span class="line">		&#123; <span class="string">&#x27;/&#x27;</span>, divide() &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; binops[<span class="string">&#x27;+&#x27;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; binops[<span class="string">&#x27;-&#x27;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; binops[<span class="string">&#x27;/&#x27;</span>](<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>函数指针</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>C++四种强制转换</title>
    <url>/2020/11/03/C++%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="1、static-cast"><a href="#1、static-cast" class="headerlink" title="1、static_cast"></a>1、static_cast</h3><p>在C++语言中static_cast用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型,例如将整型数据转换为浮点型数据。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d=<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="number">5</span>/<span class="number">4</span>);   <span class="comment">//将会把5/4强转成double类型，如果直接求的话等于1</span></span><br></pre></td></tr></table></figure>
<h3 id="2、const-cast"><a href="#2、const-cast" class="headerlink" title="2、const_cast"></a>2、const_cast</h3><p>​    在C语言中，const限定符通常被用来限定变量，用于表示该变量的值不能被修改。而const_cast则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是<code>const_cast</code><strong>不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">*p = <span class="number">20</span>;                  <span class="comment">//compile error</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(a);  <span class="comment">//compile error</span></span><br></pre></td></tr></table></figure>

<p>第一个编译错误是<code>*p</code>因为具有常量性，其值是不能被修改的；另一处错误是<code>const_cast</code>强制转换对象必须为指针或引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const_cast关键字的使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line">    <span class="keyword">int</span> *q;</span><br><span class="line">    q = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line">    *q = <span class="number">20</span>;    <span class="comment">//fine</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将变量a声明为常量变量，同时声明了一个const指针指向该变量（此时如果声明一个普通指针指向该常量变量的话是不允许的），之后定义了一个普通的指针*q。将p指针通过const_cast去掉其常量性，并赋给q指针。之后再修改q指针所指地址的值时，这是不会有问题的。<br>最后将结果打印出来，运行结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">20</span></span><br><span class="line"><span class="number">002</span>CFAF4 <span class="number">002</span>CFAF4 <span class="number">002</span>CFAF4</span><br></pre></td></tr></table></figure>

<p>​     </p>
<p>​      </p>
<h3 id="3、reinterpret-cast"><a href="#3、reinterpret-cast" class="headerlink" title="3、reinterpret_cast"></a>3、reinterpret_cast</h3><p>在C++语言中，reinterpret_cast主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">double</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span> *&gt;(a);</span><br></pre></td></tr></table></figure>

<p>​      </p>
<p>​       </p>
<h3 id="4、dynamic-cast"><a href="#4、dynamic-cast" class="headerlink" title="4、dynamic_cast"></a>4、dynamic_cast</h3><ol>
<li>其他三种都是编译时完成的，<code>dynamic_cast</code>是运行时处理的，运行时要进行类型检查。</li>
<li>不能用于内置的基本数据类型的强制转换。</li>
<li><code>dynamic_cast</code>转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。</li>
<li>使用<code>dynamic_cast</code>进行转换的，基类中一定要有虚函数，否则编译不通过。<br> 需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。<br> 这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于<a href="http://baike.baidu.com/view/3750123.htm">虚函数表</a>的概念，详细可见&lt;Inside c++ object model&gt;）中，<br> 只有定义了虚函数的类才有虚函数表。</li>
<li>在类的转换时，在类层次间进行上行转换时，<code>dynamic_cast</code>和<code>static_cast</code>的效果是一样的。在进行下行转换时，<code>dynamic_cast</code>具有类型检查的功能，比<code>static_cast</code>更安全。</li>
</ol>
<blockquote>
<ul>
<li>向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。</li>
<li>向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。</li>
<li>在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am your father&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Real_print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am the Single man&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am your son&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Real_print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am the independent man&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son *f = <span class="keyword">new</span> Son();</span><br><span class="line">	f-&gt;print();                                   <span class="comment">//多态，执行子类的函数</span></span><br><span class="line">	Father * f2 = <span class="keyword">dynamic_cast</span>&lt;Father *&gt;(f);      <span class="comment">//转换成父类</span></span><br><span class="line">	f2-&gt;Real_print();             <span class="comment">//调用父类的函数，如果是调用虚函数，则最终还是执行子类的函数</span></span><br><span class="line">	Father *f1 = <span class="keyword">new</span> Son();       </span><br><span class="line">	Son *s = <span class="keyword">dynamic_cast</span>&lt;Son *&gt;(f1);</span><br><span class="line">	s-&gt;Real_print();         <span class="comment">//可以进行强转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<em>从子类到基类的指针转换</em> ,<code>dynamic_cast </code>成功转换,没有什么运行异常,且达到预期结果；<br>而<em>从基类到子类的转换</em> , <code>dynamic_cast </code>在转换时也没有报错,但是输出给 <code>*base2sub* </code>是一个 <em>nullptr</em> ,说明<code>dynami_cast </code>在程序运行时对类型转换对<em>“运行期类型信息”（Runtime type information，RTTI）</em>进行了检查。<br>这个检查主要来自<em>虚函数(virtual function)</em> 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function  siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。</p>
<h4 id="4-1、typeid"><a href="#4-1、typeid" class="headerlink" title="4.1、typeid"></a>4.1、typeid</h4><p>1、<code>typeid</code>是C++的关键字之一，等同于<code>sizeof</code>这类的操作符。<code>typeid</code>操作符的返回结果是名为<code>type_info</code>的标准库类型的对象的引用。 </p>
<p>2、如果表达式的类型是类类型且至少包含有一个虚函数，则<code>typeid</code>操作符返回表达式的动态类型，需要在运行时计算；否则，<code>typeid</code>操作符返回表达式的静态类型，在编译时就可以计算。</p>
<p>3、由于<code>typeid</code>在实现多态的过程中可以判别父类是指向子类还是指向自身，所有可以用于判断父类对象，然后进行相应的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typeid.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT(F) std::cout&lt;&lt;typeid(F).name()&lt;&lt;std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeriveA</span> :</span> <span class="keyword">public</span> BaseA &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeriveB</span> :</span> <span class="keyword">public</span> BaseB &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-------直接处理类名-------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	OUTPUT(BaseA);</span><br><span class="line">	OUTPUT(DeriveA);</span><br><span class="line">	OUTPUT(BaseB);</span><br><span class="line">	OUTPUT(DeriveB);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;-------基类不含虚函数-------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	BaseA baseA;</span><br><span class="line">	DeriveA deriveA;</span><br><span class="line">	OUTPUT(baseA);</span><br><span class="line">	OUTPUT(deriveA);</span><br><span class="line"></span><br><span class="line">	BaseA* pa;</span><br><span class="line">	pa = &amp;baseA;</span><br><span class="line">	OUTPUT(*pa);</span><br><span class="line">	OUTPUT(pa);</span><br><span class="line">	pa = &amp;deriveA;</span><br><span class="line">	OUTPUT(*pa);</span><br><span class="line">	OUTPUT(pa);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;-------基类含有虚函数-------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	BaseB baseB;</span><br><span class="line">	DeriveB deriveB;</span><br><span class="line">	OUTPUT(baseB);</span><br><span class="line">	OUTPUT(deriveB);</span><br><span class="line"></span><br><span class="line">	BaseB* pb;</span><br><span class="line">	pb = &amp;baseB;</span><br><span class="line">	OUTPUT(*pb);</span><br><span class="line">	OUTPUT(pb);</span><br><span class="line">	pb = &amp;deriveB;</span><br><span class="line">	OUTPUT(*pb);</span><br><span class="line">	OUTPUT(pb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">-------直接处理类名-------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeriveA</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeriveB</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-------基类不含虚函数-------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeriveA</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span> *</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span> *</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-------基类含有虚函数-------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeriveB</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span> *</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeriveB</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span> *</span></span><br></pre></td></tr></table></figure>

<p><strong>1.当typeid操作符的操作数是不带有虚函数的类类型时，typeid操作符会<em>指出操作数的类型，而不是底层对象的类型</em>。</strong></p>
<p><strong>2.如果typeid操作符的操作数是至少包含一个虚拟函数的类类型时，并且该表达式是一个基类的引用，则typeid操作符指出底层对象的派生类类型，如果是基类的的指针，则指出的仍然是基类的本身的指针。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>static_cast</tag>
        <tag>typeid</tag>
      </tags>
  </entry>
  <entry>
    <title>count、next_permutation、fill、inner_product、iota的简单应用</title>
    <url>/2020/11/03/count%E3%80%81next_permutation%E3%80%81fill%E3%80%81inner_product%E3%80%81iota%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1、count与count-if函数的使用"><a href="#1、count与count-if函数的使用" class="headerlink" title="1、count与count_if函数的使用"></a>1、count与count_if函数的使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; algorithm &gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; vector &gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> target_value;</span><br><span class="line"><span class="keyword">int</span> count_num=count(v.begin(),v.end(),target_value);</span><br></pre></td></tr></table></figure>

<p>通过调用count函数<a id="more"></a>，可以自动计算出在v中符合目标值的个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; algorithm &gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; vector &gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value%<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; v;</span><br><span class="line"><span class="keyword">int</span> count_num=count(v.begin(),v.end(),compare);</span><br></pre></td></tr></table></figure>
<p>通过调用coun_if函数，可以自动计算出在v中符合谓词条件的个数，上述的是返回奇数的个数  </p>
<h3 id="2、next-permutation-全排列算法"><a href="#2、next-permutation-全排列算法" class="headerlink" title="2、next_permutation(全排列算法)"></a>2、next_permutation(全排列算法)</h3><p><strong>算法思想：</strong><br>1.首先从最尾端开始往前寻找两个相邻元素，令第一元素为<em>i,第二元素为</em>ii,且满足<em>i&lt;<em>ii。<br>2.找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个大于</em>i的元素，令为</em>j，将i,j元素对调(swap)。<br>3.再将ii之后的所有元素颠倒(reverse)排序。<br>举个实例，假设有序列{0,1,2,3,4}，下图便是套用上述演算法则，一步一步获得“下一个”排列组合。图中只框出那符合“一元素为<em>i,第二元素为</em>ii,且满足*i&lt;*ii ”的相邻两元素，至于寻找适当的j、对调、逆转等操作并未显示出。<br><img src="https://zhuom-go.github.io/img/next_permutation%E7%AE%97%E6%B3%95%E5%9B%BE%E7%89%87.jpg" alt="next_permutation算法图片"></p>
<p><strong>源码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">BidrectionalIterator</span> &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">next_permutation</span><span class="params">(BidrectionalIterator first,BidrectionalIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(first == lase) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* 空区间 */</span></span><br><span class="line">	BidrectionalIterator i = first;</span><br><span class="line">	++i;</span><br><span class="line">	<span class="keyword">if</span>(i == last) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">/* 只有一个元素 */</span></span><br><span class="line">	i = last;                    <span class="comment">/* i指向尾端 */</span>  </span><br><span class="line">	--i;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		BidrectionalIterator ii = i;</span><br><span class="line">		--i;</span><br><span class="line">		<span class="comment">/* 以上锁定一组(两个)相邻元素 */</span></span><br><span class="line">		<span class="keyword">if</span>(*i &lt; *ii)           <span class="comment">/* 如果前一个元素小于后一个元素 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			BidrectionalIterator j = last; <span class="comment">/* 令j指向尾端 */</span></span><br><span class="line">			<span class="keyword">while</span>(!(*i &lt; *--j));     <span class="comment">/* 由尾端往前找，直到遇到比*i大的元素 */</span></span><br><span class="line">			iter_swap(i,j);          <span class="comment">/* 交换i,j */</span></span><br><span class="line">			reverse(ii,last);        <span class="comment">/* 将ii之后的元素全部逆序重排 */</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i == first)       <span class="comment">/* 进行至最前面了 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			reverse(first,last);    <span class="comment">/* 全部逆序重排 */</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简单使用：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; iostream &gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; algorithm &gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	sort(ans,ans+<span class="number">4</span>);    <span class="comment">/* 这个sort可以不用，因为&#123;1，2，3，4&#125;已经排好序*/</span></span><br><span class="line">	<span class="keyword">do</span>                             <span class="comment">//注意这步，如果是while循环，则需要提前输出</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt; ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;<span class="keyword">while</span>(next_permutation(ans,ans+<span class="number">4</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数在没有排列完成前，会不断的循环调用，直至把最大的排列显示出来，需要注意的是，<strong>调用该函数的时候，需要数组或者容器先进行从小到大的排序</strong>。<br>还有一个prev_permutation，原理与其类似，不过他是把排列从大到小排，<strong>调用该函数的时候，需要把数组或者容器先进行从大到小的排序</strong>。<br>上述的简单从小到大或者从大到小可以调用<code>sort</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">sort(ans,ans+<span class="number">4</span>); <span class="comment">//默认是从小到大排序</span></span><br><span class="line">sort(ans,ans+<span class="number">4</span>,greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//变成从大到小排</span></span><br></pre></td></tr></table></figure>

<p>​     </p>
<p>​        </p>
<h3 id="3、fill与fill-n函数的使用"><a href="#3、fill与fill-n函数的使用" class="headerlink" title="3、fill与fill_n函数的使用"></a>3、fill与fill_n函数的使用</h3><p><strong>注意：</strong>这两个函数只能对输入范围内已存在的元素进行操作，如果试图对空容器进行fill_n操作，会导致严重的运行错误，所以在对元素进行写入操作时要检查目标的大小是否足以存储要写入的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line">fill(vec.begin(), vec.end(), val); <span class="comment">//原来容器中每个元素被重置为val</span></span><br></pre></td></tr></table></figure>

<p><strong>fill函数的作用是</strong>：将一个区间的元素都赋予val值。函数参数：fill(vec.begin(), vec.end(), val); val为将要替换的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; </span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//定义一个空容器  </span></span><br><span class="line">fill_n(vec.begin(), <span class="number">10</span>, val);  </span><br></pre></td></tr></table></figure>
<p><strong>fill_n函数的作用是</strong> ：参数包括 : 一个迭代器，一个计数器以及一个值。该函数从迭代器指向的元素开始，将指定数量的元素设置为给定的值。<br>上述如果一定要使用空容器的话，可以用以下方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt; </span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//定义一个空容器  </span></span><br><span class="line">fill_n (back_inserter(vec), <span class="number">10</span> val);  </span><br></pre></td></tr></table></figure>
<p>这样当每生成一个值，就可以通过迭代器自动插入进去，其需要添加**iterator头文件 **<br>​       </p>
<p>​        </p>
<h3 id="4、inner-product函数的使用"><a href="#4、inner-product函数的使用" class="headerlink" title="4、inner_product函数的使用"></a>4、inner_product函数的使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//for_each中打印容器中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> ele)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ele&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op1</span><span class="params">(<span class="keyword">int</span> initV,<span class="keyword">int</span> ele3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> initV+ele3;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op2</span><span class="params">(<span class="keyword">int</span> ele1,<span class="keyword">int</span> ele2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ele1*<span class="number">2</span>+ele2*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dim[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dim2[]=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l1,l2;</span><br><span class="line">    <span class="comment">//copy函数中利用back_inserter初始化list容器l1</span></span><br><span class="line">    copy(dim,dim+<span class="number">10</span>,back_inserter(l1));</span><br><span class="line">    for_each(l1.begin(),l1.end(),print);  <span class="comment">//显示l1</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    copy(dim2,dim2+<span class="number">10</span>,back_inserter(l2));</span><br><span class="line">    for_each(l2.begin(),l2.end(),print);  <span class="comment">//显示l2</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//求l1和l2的内积并加初值0</span></span><br><span class="line">    <span class="keyword">int</span> prod=inner_product(l1.begin(),l1.end(),l2.begin(),<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;inner_product(l1.begin(),l1.end(),l2.begin(),0): &quot;</span>&lt;&lt;prod&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//执行op1(initV,op2(l1,l2));</span></span><br><span class="line">    prod=inner_product(l1.begin(),l1.end(),l2.begin(),<span class="number">1</span>,op1,op2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;inner_product(l1.begin(),l1.end(),l2.begin(),1,op1,op2): &quot;</span>&lt;&lt;prod&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//求l1与l2的内积并加上初值1</span></span><br><span class="line">    prod=inner_product(l1.begin(),l1.end(),l2.begin(),<span class="number">1</span>,plus&lt;<span class="keyword">int</span>&gt;(),multiplies&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;inner_product(l1.begin(),l1.end(),l2.begin(),1,plus&lt;int&gt;(),multiplies: &quot;</span>&lt;&lt;prod&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<p><img src="https://zhuom-go.github.io/img/inner_product%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="inner_product运行结果">  </p>
<p>​<br>​<br>​        </p>
<h3 id="5、iota的使用"><a href="#5、iota的使用" class="headerlink" title="5、iota的使用"></a>5、iota的使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">iota(data.begin(),data.end(),<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong>data里面的值将会从1开始填充，每次加1，直至把容器填满。例如上述data的值为：1，2，3，4，5，6，7，8，9  </p>
]]></content>
      <categories>
        <category>C++</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>QSting与string</title>
    <url>/2020/11/03/string%E4%B8%AD%E6%A3%80%E6%9F%A5%E5%AD%97%E7%AC%A6%E7%9A%84%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[<h3 id="1、string中检查字符的常用API"><a href="#1、string中检查字符的常用API" class="headerlink" title="1、string中检查字符的常用API"></a>1、string中检查字符的常用API</h3><p><strong>他们包含在<code>cctype</code>头文件中</strong></p>
<a id="more"></a>   

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>isalnum(c)</code></strong></td>
<td><strong>当c是字母或数字时为真</strong></td>
</tr>
<tr>
<td><strong><code>isalpha(c)</code></strong></td>
<td><strong>当c是字母时为真</strong></td>
</tr>
<tr>
<td><strong><code>iscntrl(c)</code></strong></td>
<td><strong>当c是控制字符时为真</strong></td>
</tr>
<tr>
<td><strong><code>isdigit(c)</code></strong></td>
<td><strong>当c是数字时为真</strong></td>
</tr>
<tr>
<td><strong><code>isgraph(c)</code></strong></td>
<td><strong>当c不是空格但可打印时为真</strong></td>
</tr>
<tr>
<td><strong><code>islower(c)</code></strong></td>
<td><strong>当c是小写字母时为真</strong></td>
</tr>
<tr>
<td><strong><code>isprint(c)</code></strong></td>
<td><strong>当c是可打印字符时为真</strong></td>
</tr>
<tr>
<td><strong><code>isspace(c)</code></strong></td>
<td><strong>当c是空白时为真</strong></td>
</tr>
<tr>
<td><strong><code>isupper(c)</code></strong></td>
<td><strong>当c是大写字母时为真</strong></td>
</tr>
<tr>
<td><strong><code>isxdigit(c)</code></strong></td>
<td><strong>当c是十六进制数字时为真</strong></td>
</tr>
<tr>
<td><strong><code>tolower(c)</code></strong></td>
<td><strong>当c是大写字母时，输出对应的小写字母</strong></td>
</tr>
<tr>
<td><strong><code>toupper(c)</code></strong></td>
<td><strong>当c是小写字母时，输出对应的大写字母</strong></td>
</tr>
<tr>
<td><strong><code>ispunct(c)</code></strong></td>
<td><strong>当c是标点符号时为真</strong></td>
</tr>
</tbody></table>
<p>当进行字符串的遍历时可以用以下方法：     </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:str)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;        <span class="comment">/*输出每个字符*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2、QString常用功能"><a href="#2、QString常用功能" class="headerlink" title="2、QString常用功能"></a>2、QString常用功能</h3><h4 id="2-1、setnum与Qstring-number"><a href="#2-1、setnum与Qstring-number" class="headerlink" title="2.1、setnum与Qstring::number"></a>2.1、setnum与Qstring::number</h4><p>用来把数字转换成字符，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QSring str;</span><br><span class="line">str=QString::number(<span class="number">3.151</span>,<span class="string">&#x27;f&#x27;</span>,<span class="number">2</span>)   <span class="comment">//保留两位小数</span></span><br><span class="line">str=QString::number(<span class="number">5</span>,<span class="number">2</span>)         <span class="comment">//把5转换成二进制</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">str=str.setNum(<span class="number">3.145</span>,<span class="string">&#x27;f&#x27;</span>,<span class="number">2</span>);      <span class="comment">//保留两位小数</span></span><br><span class="line">str=str.setNum(<span class="number">5</span>,<span class="number">2</span>);          <span class="comment">//把5转换成二进制</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2、append和prepend"><a href="#2-2、append和prepend" class="headerlink" title="2.2、append和prepend"></a>2.2、append和prepend</h4><p><code>append</code>是把是把字符串加在后面，<code>prepend</code>是把字符串加在前面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString str1=<span class="string">&quot;5&quot;</span>,str2=<span class="string">&quot;2&quot;</span>,str=str1;</span><br><span class="line">str1.append(str2); <span class="comment">//str1=52</span></span><br><span class="line">str.append(str2);  <span class="comment">//str=25</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3、trimmed和simplified"><a href="#2-3、trimmed和simplified" class="headerlink" title="2.3、trimmed和simplified"></a>2.3、trimmed和simplified</h4><p><code>trimmed</code>是去掉首尾的空格,<code>simplified</code>是除了去掉首尾的空格，还把中间连续的空格用一个代替</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString str1=<span class="string">&quot;  A U    OK?   &quot;</span>,str2;</span><br><span class="line">str2=str1.trimmed();      <span class="comment">//A U    OK?</span></span><br><span class="line">str2=str1.simplified();   <span class="comment">//A U OK?</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4、indexOf和lastIndexOf"><a href="#2-4、indexOf和lastIndexOf" class="headerlink" title="2.4、indexOf和lastIndexOf"></a>2.4、indexOf和lastIndexOf</h4><p><code>indexOf</code>是符合当前字符串的第一个位置，<code>lastIndexOf</code>是符合当前字符串的最后一个位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString str=<span class="string">&quot;123456789123456789&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n=str.indexof(<span class="number">5</span>); <span class="comment">//n=5</span></span><br><span class="line"><span class="keyword">int</span> n=str.lastindexof(<span class="number">5</span>);  <span class="comment">//14</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5、contains"><a href="#2-5、contains" class="headerlink" title="2.5、contains"></a>2.5、contains</h4><p>判断某个字符串是否包含另一个字符串，可指定区分大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString str=<span class="string">&quot;123456asdfghjkl789&quot;</span>;</span><br><span class="line"><span class="keyword">bool</span> b=str.contains(<span class="string">&quot;asd&quot;</span>,Qt::CaseInsensitive); <span class="comment">//true 不区分大小写</span></span><br><span class="line"> b=str.contains(<span class="string">&quot;ASD&quot;</span>,Qt::Casesensitive); <span class="comment">//fasle 区分大小写</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6、endsWith和startsWith"><a href="#2-6、endsWith和startsWith" class="headerlink" title="2.6、endsWith和startsWith"></a>2.6、endsWith和startsWith</h4><p>判断是否以某个单词开始或者以某个单词结束，也可指定大小写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString str=<span class="string">&quot;C:/User/solftware&quot;</span>;</span><br><span class="line"><span class="keyword">bool</span> b=str.endsWith(<span class="string">&quot;solftWare&quot;</span>,Qt::CaseInsensitive);   <span class="comment">//true 不区分大小写</span></span><br><span class="line">b=str.startsWith(<span class="string">&quot;c:&quot;</span>);  <span class="comment">//false  区分大小写</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7、left和right"><a href="#2-7、left和right" class="headerlink" title="2.7、left和right"></a>2.7、left和right</h4><p><code>QString s=str.left(N)</code>,从左边取多少个字符串或者从右边取多少个字符串</p>
<h4 id="2-8、section"><a href="#2-8、section" class="headerlink" title="2.8、section"></a>2.8、section</h4><p>以某个字符串进行分割，然后选取从开始到结束的字符段。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString str2,str1=<span class="string">&quot;学生姓名，男，1984-3-4，汉族，山东&quot;</span>;</span><br><span class="line">str2=str1.section(<span class="string">&quot;,&quot;</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//str2=&quot;学生姓名&quot;</span></span><br><span class="line">str2=str1.section(<span class="string">&quot;,&quot;</span>,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//str2=&quot;学生姓名，男&quot;</span></span><br><span class="line">str2=str1.section(<span class="string">&quot;,&quot;</span>,<span class="number">1</span>,<span class="number">1</span>); <span class="comment">//str2=&quot;男&quot;</span></span><br><span class="line">str2=str1.section(<span class="string">&quot;,&quot;</span>,<span class="number">4</span>,<span class="number">4</span>); <span class="comment">//str2=&quot;山东&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>QString</tag>
      </tags>
  </entry>
  <entry>
    <title>友元函数与友元类</title>
    <url>/2020/11/03/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%8B%E5%85%83%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="1、友元函数"><a href="#1、友元函数" class="headerlink" title="1、友元函数"></a>1、友元函数</h3><p>在定义一个类的时候，可以把一些函数（包括全局函数和其他类的成员函数）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就可以访问该类对象的私有成员了。<a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>;</span>  <span class="comment">//提前声明CCar类，以便后面的CDriver类使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">/*改装汽车*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span>;  <span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>;  <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="keyword">int</span> total)</span>  <span class="comment">//求最贵气车的价格</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;total; ++i)</span><br><span class="line">         <span class="keyword">if</span> (cars[i].price &gt; tmpMax)</span><br><span class="line">             tmpMax = cars[i].price;</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 3 行声明了 CCar 类，CCar 类的定义在后面。之所以要提前声明，是因为 CDriver 类的定义中用到了 CCar 类型（第7行），而此时 CCar 类还没有定义，编译会报错。不要第 3 行，而把 CCar 类的定义写在 CDriver 类的前面，是解决不了这个问题的，因为 CCar 类中也用到了 CDriver 类型（第14行），把 CCar 类的定义写在前面会导致第 14 行的 CDriver 因没有定义而报错。<br>C++ 为此提供的解决办法是：可以简单地将一个类的名字提前声明，写法如下：<code>class 类名</code><br>第 13 行将全局函数 MostExpensiveCar 声明为 CCar 类的友元，因此在第 24 行可以访问 cars[i] 的私有成员 price。同理，第 14 行将 CDriver 类的 ModifyCar 成员函数声明为友元，因此在第18 行可以访问 pCar 指针所指向的对象的私有成员变量 price。</p>
<p>  <em>尽管可以提前声明，但是在一个类的定义出现之前，仍然不能有任何会导致该类对象被生成的语句。但使用该类的指针或引用是没有问题的。</em> </p>
<p>​       </p>
<p>​           </p>
<h3 id="2、友元类"><a href="#2、友元类" class="headerlink" title="2、友元类"></a>2、友元类</h3><p>一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员。在类定义中声明友元类的写法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span>  <span class="comment">//声明 CDriver 为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CCar myCar;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">()</span>  <span class="comment">//改装汽车</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        myCar.price += <span class="number">1000</span>;  <span class="comment">//因CDriver是CCar的友元类，故此处可以访问其私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第 5 行将 CDriver 声明为 CCar 的友元类。这条语句本来就是在声明 CDriver 是一个类，所以 CCar 类定义前面就不用声明 CDriver 类了。第 5 行使得 CDriver 类的所有成员函数都能访问 CCar 对象的私有成员。如果没有第 5 行，第 13 行对 myCar 私有成员 price 的访问就会导致编译错误。</p>
<p><strong>友元关系在类之间不能传递，即类 A 是类 B 的友元，类 B 是类 C 的友元，并不能导出类 A 是类 C 的友元。“咱俩是朋友，所以你的朋友就是我的朋友”这句话在 C++ 的友元关系上 不成立。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>友元函数</tag>
      </tags>
  </entry>
  <entry>
    <title>const与constexpr的区别</title>
    <url>/2020/11/03/const%E4%B8%8Econstexpr%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="1、const与constexpr的区别"><a href="#1、const与constexpr的区别" class="headerlink" title="1、const与constexpr的区别"></a>1、const与constexpr的区别</h3><p>const指的是编译期常量和运行时常量，两者并没有区分<br>constexpr特指编译期常量</p>
<a id="more"></a>

<h4 id="1-1、const的使用"><a href="#1-1、const的使用" class="headerlink" title="1.1、const的使用"></a>1.1、const的使用</h4><p><code>const</code>可以修饰类的成员函数，被修饰的函数在执行期间不会改变对象的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">mutable</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Person::getName</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能执行</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Person::getName</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//可以执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::setAge</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设此函数未<code>public</code>限定，且<code>name</code>数据成员没有使用<code>mutable</code>修饰，那么此函数在调用期间不会改变<code>this</code>所指的对象，也就是说，如果某个被修饰成<code>const</code>的成员函数在执行期间改变了<code>this</code>中的数据成员，那么这个函数会报错。</p>
<h3 id="2、constexpr的使用"><a href="#2、constexpr的使用" class="headerlink" title="2、constexpr的使用"></a>2、constexpr的使用</h3><p><strong>修饰函数</strong></p>
<p>1、修饰的函数只能包括return 语句；<br>2、修饰的函数只能引用全局不变常量；<br>3、修饰的函数只能调用其他constexpr修饰的函数；<br>4、函数不能为void 类型和，并且prefix operation（v++）不允许出现。<br><strong>使用例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过对斐波拉契函数的递归实现，来看看constexpr具体怎么修饰函数，同时比较这样使用的好处</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="comment">//在这个函数里面，由于constexpr稀释的是fib1这个函数，因此每一次计算的结果都会作为一个常量保存下来</span></span><br><span class="line"><span class="comment">//这个实现的复杂度等同于迭代的方法，基本上为O(n)。</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fib1</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">return</span> (n &lt;= <span class="number">1</span>)? n : fib1(n<span class="number">-1</span>) + fib1(n<span class="number">-2</span>); <span class="comment">//只能包含一个retrun语句</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//熟悉递归函数就不难证明下面这个函数的时间复杂度为O(2^n)</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fib2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n &lt;= <span class="number">1</span>)? n : fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">// value of res is computed at compile time. </span></span><br><span class="line">  	<span class="keyword">clock_t</span> start, end;</span><br><span class="line">  	start = clock();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">int</span> res = fib1(<span class="number">30</span>); </span><br><span class="line">  	end = clock();</span><br><span class="line">  	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Totle Time fib1 : &quot;</span> &lt;&lt;(<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  	start = clock();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">int</span> res = fib2(<span class="number">30</span>); </span><br><span class="line">  	end = clock();</span><br><span class="line">  	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Totle Time fib2 : &quot;</span> &lt;&lt;(<span class="keyword">double</span>)(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>修饰结构体</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ program to demonstrate uses of constexpr in constructor </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="comment">// A class with constexpr constructor and function </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">int</span> _h, _w; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">        <span class="comment">// 修饰一个结构体</span></span><br><span class="line">	constexpr Rectangle (int h, int w) : _h(h), _w(w) &#123;&#125; </span><br><span class="line">	<span class="comment">// 修饰一个函数，_h, _w为全局，并且在实例化时就已经是初始化后的常量了</span></span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getArea</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> _h * _w; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">// 对象在编译时就已经初始化了</span></span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> Rectangle <span class="title">obj</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; obj.getArea(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​     </p>
<p>​            </p>
<h3 id="3、const、constexpr与static、extern联合使用"><a href="#3、const、constexpr与static、extern联合使用" class="headerlink" title="3、const、constexpr与static、extern联合使用"></a>3、const、constexpr与static、extern联合使用</h3><p><strong>static与const联合使用</strong></p>
<ul>
<li><p>static与const作用:声明一个只读的静态变量</p>
</li>
<li><p>开发使用场景:在<code>一个文件中</code>经常使用的字符串常量，可以使用static与const组合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">20</span>;    <span class="comment">//声明一个静态全局只读变量</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3-1、extern与const联合使用"><a href="#3-1、extern与const联合使用" class="headerlink" title="3.1、extern与const联合使用"></a>3.1、extern与const联合使用</h4><ul>
<li>开发中使用场景:在<code>多个文件中</code>经常使用的同一个字符串常量，可以使用extern与const组合。</li>
<li>原因:<ul>
<li>static与const组合：在每个文件都需要定义一份静态全局变量。</li>
<li>extern与const组合:只需要定义一份全局变量，多个文件共享。</li>
</ul>
</li>
<li>全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Global.h全局文件</span></span><br><span class="line"><span class="keyword">extern</span> String *<span class="keyword">const</span> nameKey=<span class="string">&quot;name&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Global.cpp文件</span></span><br><span class="line">String *<span class="keyword">const</span> nameKey=<span class="string">&quot;name&quot;</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>const</tag>
        <tag>constexpr</tag>
      </tags>
  </entry>
  <entry>
    <title>explicit的使用</title>
    <url>/2020/11/03/explicit%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1、C-11-之前explicit的作用"><a href="#1、C-11-之前explicit的作用" class="headerlink" title="1、C++11 之前explicit的作用"></a>1、C++11 之前explicit的作用</h3><p> explicit关键字的作用： 禁止隐式调用类内的单参数构造函数， 这主要包括如下三层意思：</p>
<a id="more"></a>

<ol>
<li>该关键字只能用来修饰类内部的构造函数</li>
<li>禁止隐式调用拷贝构造函数</li>
<li>禁止类对象之间的隐式转换</li>
</ol>
<p><strong>例子</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cxstring</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> _str;</span><br><span class="line">	<span class="keyword">int</span> _size;</span><br><span class="line">	Cxstring(<span class="keyword">int</span> size) &#123;</span><br><span class="line">		_size = size;</span><br><span class="line">	&#125;</span><br><span class="line">	Cxstring(<span class="built_in">string</span> str) &#123;</span><br><span class="line">		_str = str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cxstring s1 = <span class="number">1</span>;</span><br><span class="line">	<span class="function">Cxstring <span class="title">s2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	Cxstring s6 = <span class="string">&#x27;c&#x27;</span>;<span class="comment">// 这样是OK的, 其实调用的是CxString(int size), 且size等于&#x27;c&#x27;的ascii码 </span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> a = <span class="string">&quot;aaaa&quot;</span>;</span><br><span class="line">	<span class="function">Cxstring <span class="title">s3</span><span class="params">(a)</span></span>;</span><br><span class="line">	<span class="function">Cxstring <span class="title">s4</span><span class="params">(<span class="string">&quot;aae&quot;</span>)</span></span>;</span><br><span class="line">	Cxstring s5 = a;</span><br><span class="line">	s1 = s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面的例子都能编译通过。但是如果我们将第一个构造函数添加了explicit：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cxstring</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span> _str;</span><br><span class="line">	<span class="keyword">int</span> _size;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Cxstring</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		_size = size;</span><br><span class="line">	&#125;</span><br><span class="line">	Cxstring(<span class="built_in">string</span> str) &#123;</span><br><span class="line">		_str = str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cxstring s1 = <span class="number">1</span>; <span class="comment">// 这样是不OK的，explicit取消了隐式转换</span></span><br><span class="line">	<span class="function">Cxstring <span class="title">s2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	Cxstring s6 = <span class="string">&#x27;c&#x27;</span>;<span class="comment">// 这样是不OK的, explicit取消了隐式转换</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> a = <span class="string">&quot;aaaa&quot;</span>;</span><br><span class="line">	<span class="function">Cxstring <span class="title">s3</span><span class="params">(a)</span></span>;</span><br><span class="line">	<span class="function">Cxstring <span class="title">s4</span><span class="params">(<span class="string">&quot;aae&quot;</span>)</span></span>;</span><br><span class="line">	Cxstring s5 = a;</span><br><span class="line">	s1 = s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>隐式转换到底是什么呢？以上面的一段代码来做例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Cxstring s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="function">Cxstring <span class="title">temp</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">Cxstring s1 = temp;</span><br></pre></td></tr></table></figure>

<p><strong>explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了</strong>。</p>
<p>​      </p>
<p>​      </p>
<h3 id="2、C-11之后的explict的新作用"><a href="#2、C-11之后的explict的新作用" class="headerlink" title="2、C++11之后的explict的新作用"></a>2、C++11之后的explict的新作用</h3><p>C++11 之后explicit增加了新的作用：<br><strong>允许explict用来修饰类型转换操作符()上</strong><br> 当然，C++ 之前的作用还保留着。</p>
<p><strong>例子：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"><span class="function">explict <span class="keyword">operator</span> <span class="title">B</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> B();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(B b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="function">B <span class="title">b1</span><span class="params">(a)</span></span>; <span class="comment">//直接构造初始化</span></span><br><span class="line">B b2 = <span class="keyword">static_cast</span>&lt;B&gt;(a); <span class="comment">//强制类型转换</span></span><br><span class="line"><span class="comment">//其它都不行，拷贝构造</span></span><br><span class="line">B b3 = a; </span><br><span class="line">Func(a); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以防止（）运算符中的隐式转换。<br><strong>总的来说，explicit关键字的作用主要是禁止隐式转换。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>常规语法</category>
      </categories>
      <tags>
        <tag>explicit</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序容器的选择</title>
    <url>/2020/11/03/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h3 id="1、顺序容器的选择"><a href="#1、顺序容器的选择" class="headerlink" title="1、顺序容器的选择"></a>1、顺序容器的选择</h3><ol>
<li><p><code>vector</code>：可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢；</p>
<a id="more"></a>
</li>
<li><p><code>deque</code>：双端队列。支持快速随机访问。在头尾位置插入/删除很快；</p>
</li>
<li><p><code>list</code>：双向链表。只支持双向随机访问。在<code>list</code>中任何位置进行插入/删除操作很快；</p>
</li>
<li><p><code>forward_list</code>：单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作很快；</p>
</li>
<li><p><code>array</code>：固定大小数组。支持快速随机访问。不能添加或删除元素；</p>
</li>
<li><p><code>string</code>：与vector相似的容器，但专门用于保存字符。</p>
</li>
</ol>
<p>​     </p>
<h3 id="2、容器的拷贝"><a href="#2、容器的拷贝" class="headerlink" title="2、容器的拷贝"></a>2、容器的拷贝</h3><p>​    为了创建一个容器为另外一个容器的拷贝，两个容器的类型必须相同。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器的类型相同了。而且，新容器和原容器的元素类型也可以不同，只需可以转换即可。</p>
<p><strong>例如</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; authors=&#123;<span class="string">&quot;Milton&quot;</span>,<span class="string">&quot;Shakespeare&quot;</span>,<span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; articles=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;an&quot;</span>,<span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">list2</span><span class="params">(authors)</span></span>;   <span class="comment">//正确，类型匹配</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; <span class="title">autholist</span><span class="params">(authors)</span></span>;  <span class="comment">//错误，容器类型不匹配</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">words</span><span class="params">(articles)</span></span>;   <span class="comment">//错误,容器的元素类型不匹配。</span></span><br><span class="line"><span class="function">forward_list&lt;<span class="built_in">string</span>&gt; <span class="title">words</span><span class="params">(articles.begin(),articles.end())</span></span>;  <span class="comment">//正确：可以将const char*元素转换为string</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于初始化后，想进行替换的方法</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; oldstyle;</span><br><span class="line">names=oldstyle;   <span class="comment">///错误：容器类型不匹配</span></span><br><span class="line"></span><br><span class="line">names.assign(oldstyle.cbegin(),oldstyle.cend());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//assign的其它操作</span></span><br><span class="line">names.assign(<span class="string">&quot;zhuoM&quot;</span>)    <span class="comment">//将names中的元素初始化为zhuoM</span></span><br><span class="line">names.assign(<span class="number">10</span>,<span class="string">&quot;zhuoM&quot;</span>)  <span class="comment">//将names中的元素初始化为10个zhuoM</span></span><br></pre></td></tr></table></figure>

<p>​     </p>
<h3 id="3、array的好处"><a href="#3、array的好处" class="headerlink" title="3、array的好处"></a>3、array的好处</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int myArray1[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;</span></span><br><span class="line"><span class="comment">int myArray2[10]=myArray1;  //错误，内置数组不支持拷贝或复值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myArray1=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myArray2=myArray1； <span class="comment">//正确，数组类型匹配既可</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>assign</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>容器的操作</title>
    <url>/2020/11/03/%E5%AE%B9%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="1、顺序容器的操作"><a href="#1、顺序容器的操作" class="headerlink" title="1、顺序容器的操作"></a>1、顺序容器的操作</h3><h4 id="1-1、添加元素"><a href="#1-1、添加元素" class="headerlink" title="1.1、添加元素"></a>1.1、添加元素</h4><blockquote>
<p><strong><code>1. push_bak</code>与<code>emplace_back</code></strong></p>
</blockquote>
<p>两者都是用来向尾部插入元素的，该操作除了<code>array</code>与<a id="more"></a><code>forward_list</code>没有，其它的顺序容器都有。<br>两者区别是，前者使用拷贝元素的方法进行插入，后者采用构造函数的方法插入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Sales_data&gt; c;</span><br><span class="line">c.emplace_back(<span class="string">&quot;152&quot;</span>,<span class="number">25</span>,<span class="number">19.6</span>);  <span class="comment">//使用三个参数的Sales_data构造函数</span></span><br><span class="line">c.push_back(<span class="string">&quot;152&quot;</span>,<span class="number">25</span>,<span class="number">19.6</span>);  <span class="comment">//错误，没有该参数</span></span><br><span class="line">c.push_back(Sales_data(<span class="string">&quot;152&quot;</span>,<span class="number">25</span>,<span class="number">19.6</span>));  <span class="comment">//正确，创建一个临时变量传入vector中</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<blockquote>
<p><strong>2. <code>push_front</code>与<code>emplace_front</code></strong></p>
</blockquote>
<p>两者都是用来向头部插入元素的，该操作除了<code>vector</code>与<code>string</code>没有，其它的顺序容器都有。<br>两者区别是，前者使用拷贝元素的方法进行插入，后者采用构造函数的方法插入。<br><strong>使用方法参考上面</strong></p>
<p>​       </p>
<blockquote>
<p><strong>3.  <code>insert</code>与<code>emplace</code></strong></p>
</blockquote>
<p>两者都是用来向头部插入元素的，该操作所有的顺序结构都有，只不过<code>forward_list</code>采用特殊的<code>insert</code>.<br>两者区别是，前者使用拷贝元素的方法进行插入，后者采用构造函数的方法插入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"></span><br><span class="line">c.insert(c.begin(),<span class="string">&quot;HELLO&quot;</span>);       <span class="comment">//在头部插入&quot;HELLO&quot;,返回新添加的元素的迭代器</span></span><br><span class="line">c.insert(c.end(),<span class="number">10</span>,<span class="string">&quot;HELLO&quot;</span>);      <span class="comment">//在尾部插入插入10个&quot;HELLO”，返回新添加的第一个元素的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v=&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">c.insert(c.begin(),v.begin(),v.begin()+<span class="number">1</span>) ; <span class="comment">//把v的第一、二个插入c的头部，返回新添加的第一个元素的迭代器</span></span><br><span class="line">c.insert(c.end(),&#123;<span class="string">&quot;44&quot;</span>,<span class="string">&quot;55&quot;</span>,<span class="string">&quot;66&quot;</span>&#125;);  <span class="comment">//在尾部插入插入花括号的值，返回新添加的第一个元素的迭代器</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="1-2、访问元素"><a href="#1-2、访问元素" class="headerlink" title="1.2、访问元素"></a>1.2、访问元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;c1=c.back();   <span class="comment">//返回c中尾元素的引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;c2=c.front();  <span class="comment">//返回c中第一个元素的引用</span></span><br><span class="line"><span class="keyword">auto</span>  c3=c[n];      <span class="comment">//返回下标为n的元素引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;c4=c.at(n);   <span class="comment">//返回下标为n的元素引用</span></span><br></pre></td></tr></table></figure>

<p>​       </p>
<h4 id="1-3、删除元素"><a href="#1-3、删除元素" class="headerlink" title="1.3、删除元素"></a>1.3、删除元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.pop_back();     <span class="comment">//删除c中的尾元素</span></span><br><span class="line">c.pop_front();    <span class="comment">//删除c中的头元素</span></span><br><span class="line">c.erase(p);       <span class="comment">//删除迭代器p所指定的元素，返回被删除元素之后的迭代器</span></span><br><span class="line">c.erase(b,e);     <span class="comment">//删除迭代器b,e所指定的元素，返回被删除元素最后一个的..之后的迭代器</span></span><br></pre></td></tr></table></figure>

<p>​      </p>
<h4 id="1-4、string的操作"><a href="#1-4、string的操作" class="headerlink" title="1.4、string的操作"></a>1.4、<code>string</code>的操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">&quot;HOLLO WORLD&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp=<span class="string">&quot;HOLLO WORLD&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(cp,<span class="number">2</span>)</span></span>; <span class="comment">//把cp的 HO 拷贝到s2中</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(s,<span class="number">2</span>)</span></span>;   <span class="comment">//把s的 LLO WORLD 考到s1中</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s,<span class="number">2</span>,<span class="number">5</span>)</span></span>; <span class="comment">//把s的 LLO W 拷贝到s3中</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">string</span> s4=s.substr(<span class="number">2</span>,<span class="number">5</span>);   <span class="comment">//把s的LO WO拷贝到s4中</span></span><br><span class="line">s.insert(s.size(),<span class="number">5</span>,<span class="string">&#x27;!&#x27;</span>);  <span class="comment">//在s的尾部插入5个元素 </span></span><br><span class="line"><span class="comment">/*  s.insert(0,s2,0,s2.size())   //s在0的位置插入s2从0到s2.size（）的元素*/</span></span><br><span class="line">s.erase(s.size()<span class="number">-5</span>,<span class="number">5</span>);    <span class="comment">//删除尾部5个元素</span></span><br><span class="line">s.replance(<span class="number">4</span>,<span class="number">4</span>,<span class="string">&quot;PP&quot;</span>);     <span class="comment">//s从第四个的位置开始删除4个元素，并插入PP   HOLLPPRLD</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str=<span class="string">&quot;ABCDEFGHOW&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> index=s.find_first_of(str,<span class="number">4</span>);<span class="comment">//index=6,从s[4]开始搜索符合str中的某一字符的第一个位置</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//对于C语言风格的兼容</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *op=<span class="string">&quot;HOLLO WORLD&quot;</span>;</span><br><span class="line">s.assign(op,<span class="number">5</span>);  <span class="comment">//s变成HOLLO</span></span><br><span class="line">s.insert(s.size(),op+<span class="number">5</span>)  <span class="comment">//在s变成HOLLO的基础上，从size()的位置把op+5到尾部进行拷贝</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://zhuom-go.github.io/img/string%E7%9A%84%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C.png" alt="string的搜索操作"></p>
<p>​    </p>
<h4 id="1-5、list与forward-list的特定算法"><a href="#1-5、list与forward-list的特定算法" class="headerlink" title="1.5、list与forward_list的特定算法"></a>1.5、list与forward_list的特定算法</h4><table>
<thead>
<tr>
<th>这些操作都返回void</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>lst.merge(lst2)</code></td>
<td>将来自<code>lst2</code>的元素合并到<code>lst</code>中。<code>lst</code>和<code>lst2</code>都必须是有序的</td>
</tr>
<tr>
<td><code>lst.merge(lst2.cmp)</code></td>
<td>元素将从<code>lst2</code>中删除。在合并之后<code>lst2</code>变为空。第一个版本使用<code>&lt;</code>，第二个版本使用给定的比较运算符</td>
</tr>
<tr>
<td><code>lst.remove(vel)</code></td>
<td>条用<code>remove</code>删除与给定值相等的元素</td>
</tr>
<tr>
<td><code>lst.remove_if(pred)</code></td>
<td>删除令一元谓词为真的元素</td>
</tr>
<tr>
<td><code>lst.reverse()</code></td>
<td>反转<code>lst</code>的元素</td>
</tr>
<tr>
<td><code>lst.sort()</code></td>
<td>从小到大排序</td>
</tr>
<tr>
<td><code>lst.sort(cmp)</code></td>
<td>给定比较操作符进行排序</td>
</tr>
<tr>
<td><code>lst.unique</code></td>
<td>调用<code>erase</code>删除同一个值的连续拷贝，<strong>其它类型的并不是直接删除，需要自己手动删除</strong></td>
</tr>
<tr>
<td><code>list.unique(pred)</code></td>
<td>调用<code>erase</code>删除符合谓词的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>lst.splice(args)或flst.splice_after(args)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>(p,lst2)</code></td>
<td><code>p</code>是一个指向<code>lst</code>中元素的迭代器,或一个指向<code>flst</code>首前位置的迭代器。函数将<code>lst2</code>的所有元素移动到<code>lst</code>中p之前的位置或是<code>flst</code>中<code>p</code>之后的位置。将元素从<code>lst2</code>中删除。<code>lst2</code>的类型必须与<code>lst</code>或<code>flst</code>相同,且不能是同一个链表</td>
</tr>
<tr>
<td><code>(p,lst2,p2)</code></td>
<td><code>p2</code>是一个指向<code>lst2</code>中位置的有效的迭代器。将<code>p2</code>指向的元素移动到<code>lst</code>中,或将<code>p2</code>之后的元素移动到<code>flst</code>中.<code> lst2</code>可以是与<code>lst</code>或<code>flst</code>相同的链表</td>
</tr>
<tr>
<td><code>(p,lst2,b,e)</code></td>
<td><code>b</code>和<code>e</code>必须表示<code>lst2</code>中的合法范围。将给定范围中的元素从<code>lst2</code>移动到<code>lst</code>或<code>flst</code>. <code>lst2</code>与<code>lst </code>(或<code>flst</code>)可以是相同的链表,但<code>p</code>不能指向给定范围中元素</td>
</tr>
</tbody></table>
<p>​           </p>
<p>​           </p>
<h3 id="2、关联容器的操作"><a href="#2、关联容器的操作" class="headerlink" title="2、关联容器的操作"></a>2、关联容器的操作</h3><p>关联容器与序列容器有着根本性的不同，序列容器的元素是按照在容器中的位置来顺序保存和访问的，而关联容器的元素是按关键元素来保存和访问的。关联容器支持高效的关键字查找与访问。两个主要的关联容器类型是map与set。</p>
<h4 id="2-1、set"><a href="#2-1、set" class="headerlink" title="2.1、set"></a>2.1、set</h4><p>** 简介：**set里面每个元素只存有一个key，它支持高效的关键字查询操作。set对应数学中的“集合”。</p>
<p><strong>特点：</strong></p>
<ul>
<li>储存同一类型的数据元素（这点和vector、queue等其他容器相同）</li>
<li>每个元素的值都唯一（没有重复的元素）</li>
<li>根据元素的值自动排列大小（有序性）</li>
<li>无法直接修改元素</li>
<li>高效的插入删除操作</li>
</ul>
<p><strong>声明：</strong>set<T> a</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; a;</span><br></pre></td></tr></table></figure>

<p><strong>常用函数</strong></p>
<p>以下设 set<T> a,其中a是T类型的set容器。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>a.begin()</td>
<td></td>
<td>返回指向第一个元素的迭代器</td>
</tr>
<tr>
<td>a.end()</td>
<td></td>
<td>返回指向超尾的迭代器</td>
</tr>
<tr>
<td>a.clear()</td>
<td></td>
<td>清空容器a</td>
</tr>
<tr>
<td>a.empty()</td>
<td></td>
<td>判断容器是否为空</td>
</tr>
<tr>
<td>a.size()</td>
<td></td>
<td>返回当前容器元素个数</td>
</tr>
<tr>
<td>a.count(x)</td>
<td></td>
<td>返回容器a中元素x的个数</td>
</tr>
</tbody></table>
<p><strong>1.6 插入元素：</strong></p>
<ul>
<li><code>a.insert(x)</code> :其中a为set<T>型容器，x为T型变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; a=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>&#125;;</span><br><span class="line">a.insert(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = a.begin();it != a.end();it++)	<span class="built_in">cout</span> &lt;&lt; *it;<span class="comment">//输出01269</span></span><br></pre></td></tr></table></figure>

<ul>
<li>a.insert(first,second):其中first为指向区间左侧的迭代器，second为指向右侧的迭代器。作用是将first到second区间内元素插入到a（左闭右开）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; b = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> first = b.begin();</span><br><span class="line"><span class="keyword">auto</span> second = b.end();</span><br><span class="line">a.insert(first,second);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = a.begin();it != a.end();it++)	<span class="built_in">cout</span> &lt;&lt; *it;</span><br></pre></td></tr></table></figure>

<p><strong>插入元素会自动插入到合适的位置，使整个集合有序</strong></p>
<p><strong>1.7 删除元素：</strong></p>
<ul>
<li>a.erase(x)：删除建值为x的元素</li>
<li>a.erase(first,second)：删除first到second区间内的元素（左闭右开）</li>
<li>a.erase(iterator):删除迭代器指向的元素</li>
<li>set中的删除操作是不进行任何的错误检查的，比如定位器的是否合法等等，所以用的时候自己一定要注意。</li>
</ul>
<p><strong>1.8 lower_bound 和 upper_bound 迭代器：</strong></p>
<ul>
<li>lower_bound（x1）:返回第一个不小于键参数x1的元素的迭代器</li>
<li>upper_bound（x2）:返回最后一个大于键参数x2的元素的迭代器</li>
<li>由以上俩个函数，可以得到一个目标区间，即包含集合中从’x1’到’x2’的所有元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> it2 = a.lower_bound(<span class="number">2</span>);<span class="comment">//返回指向第一个大于等于x的元素的迭代器</span></span><br><span class="line">	<span class="keyword">auto</span> it = a.upper_bound(<span class="number">2</span>);<span class="comment">//返回指向第一个大于x的元素的迭代器</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *it2 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出为2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出为5</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>1.9 set_union() 与 set_intersection()</strong></p>
<blockquote>
<p>set_union():对集合取并集</p>
</blockquote>
<p>set_union()函数接受5个迭代器参数。前两个迭代器定义了第一个集合的区间，接下来的俩个迭代器定义了第二个集合的区间，最后一个迭代器是输出迭代器，指出将结果集合复制到什么位置。例如：要将A与B的集合复制到C中，可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; A = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, B= &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,C;</span><br><span class="line">	set_union(A.begin(),A.end(),B.begin(),B.end(),insert(C,C.begin()));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = C.begin();it != C.end();it++)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>set_intersection():对集合取交集，它的接口与set_union()相同。</p>
</blockquote>
<p>附：使用set_union()和set_intersection()还有另一种技巧。由于需要五个迭代器，看起来会很累赘和麻烦，如果多次使用会增加出错的几率，所以我们可以试试用宏定义的方法来简化代码。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALL(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INS(x) inserter(x,x.begin())</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; A = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, B= &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,C;</span><br><span class="line">	set_union(ALL(A),ALL(B),INS(C));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = C.begin();it != C.end();it++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其中使用到了宏定义。</p>
<p><strong>1.10 set的几个问题：</strong></p>
<blockquote>
<p>（1）为何map和set的插入删除效率比用其他序列容器高？</p>
</blockquote>
<p>因为对于关联容器来说，不需要做内存拷贝和内存移动。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p>
<blockquote>
<p>（2）为何每次insert之后，以前保存的iterator不会失效？</p>
</blockquote>
<p>iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator。</p>
<blockquote>
<p>（3）当数据元素增多时，set的插入和搜索速度变化如何？</p>
</blockquote>
<p>如果你知道log2的关系你应该就彻底了解这个答案。在set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。看见了吧，当数据量增大一倍的时候，搜索次数只不过多了1次，多了1/14的搜索时间而已。你明白这个道理后，就可以安心往里面放入元素了。</p>
<h4 id="2-2、map"><a href="#2-2、map" class="headerlink" title="2.2、map"></a>2.2、map</h4><p><strong>简介：</strong>如果说set对应数学中的“集合”，那么map对应的就是“映射”。map是一种key-value型容器，其中key是关键字，起到索引作用，而value就是其对应的值。与set不同的是它支持下标访问。头文件是<map></p>
<p><strong>特点：</strong></p>
<ul>
<li>增加和删除节点对迭代器的影响很小(高效的插入与删除)</li>
<li>快速的查找（同set）</li>
<li>自动建立key-value的对应，key和value可以是任何你需要的类型</li>
<li>可以根据key修改value的记录</li>
<li>支持下标[]操作</li>
</ul>
<p><strong>2.3 声明：</strong>map&lt;T1,T2&gt; m</p>
<p>其中T1是key类型，T2是value类型，m就是一个T1-T2的key-value。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;<span class="comment">//声明一个key为string，value为int的map型容器</span></span><br></pre></td></tr></table></figure>

<p>下述代码更清楚的解释了map容器的特点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">	m[<span class="string">&quot;abc&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">	m[<span class="string">&quot;cdf&quot;</span>] = <span class="number">6</span>;</span><br><span class="line">	m[<span class="string">&quot;b&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = m.begin();it != m.end();it++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在上述代码中，m容器被按照key的字典序升序排列了，而且我们可以通过将key当作索引来获取value的值。（同时这也是一种插入方法）</p>
<p><strong>2.4 插入元素：</strong></p>
<ul>
<li>使用insert()函数插入pair类型的元素</li>
<li>使用下标操作向map容器中插入元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="string">&quot;b&quot;</span>,<span class="number">6</span>));<span class="comment">//insert插入</span></span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="number">5</span>;<span class="comment">//使用下标插入</span></span><br></pre></td></tr></table></figure>

<p><strong>2.5 删除元素：</strong></p>
<ul>
<li>erase(key):删除键为key的元素</li>
<li>erase(it):删除迭代器it所指向的元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">	m.insert(<span class="built_in">make_pair</span>(<span class="string">&quot;b&quot;</span>,<span class="number">6</span>));</span><br><span class="line">	m[<span class="string">&quot;a&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">	m[<span class="string">&quot;c&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">	m[<span class="string">&quot;d&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">	m[<span class="string">&quot;e&quot;</span>] = <span class="number">5</span>;</span><br><span class="line">	m.erase(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">	<span class="keyword">auto</span> pr = m.begin();</span><br><span class="line">	m.erase(pr);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = m.begin();it != m.end();it++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>2.6 map容器的遍历：</strong></p>
<ul>
<li>使用迭代器遍历（代码如上）</li>
</ul>
<p>注：使用迭代器遍历map容器，其中每一个元素可以看成是pair类型的，访问第一个位置的key值可以用it-&gt;first访问，第二个位置value的值可以用it-&gt;second访问，其中it是指向该元素的迭代器。</p>
<p><strong>2.7 常用函数：</strong></p>
<p>下表中m为map类型的容器，it为和m同类型的迭代器，key表示该类型的一个键。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>m.Count(key)</td>
<td></td>
<td>返回map中key出现的次数（0或1）</td>
</tr>
<tr>
<td>m.find(key)</td>
<td>迭代器</td>
<td>返回指向key位置的迭代器.若无则返回m.end()</td>
</tr>
<tr>
<td>m.insert(make_pair( ) )</td>
<td></td>
<td>插入一个元素(必须以pair形式插入)</td>
</tr>
<tr>
<td>m.erase(it)</td>
<td>下一个元素的迭代器</td>
<td>删除迭代器it所指向的元素</td>
</tr>
<tr>
<td>m.erase(key)</td>
<td></td>
<td>删除键值为key的元素</td>
</tr>
<tr>
<td>m.size()</td>
<td></td>
<td>返回m中元素的个数</td>
</tr>
<tr>
<td>m.clear()</td>
<td></td>
<td>清空m容器</td>
</tr>
<tr>
<td>m.empty()</td>
<td>bool</td>
<td>判断容器是否为空。空则返回true</td>
</tr>
<tr>
<td>m.lower_bound(key)</td>
<td>迭代器</td>
<td>返回指向第一个键值不小于key的元素的迭代器</td>
</tr>
<tr>
<td>m.upper_bound(key)</td>
<td>迭代器</td>
<td>返回指向第一个键值大于key的元素的迭代器</td>
</tr>
<tr>
<td>m.equal_range(key)</td>
<td>迭代器pair</td>
<td>返回关键字等于k的元素范围，不存在时返回pair的值都为m.end()</td>
</tr>
</tbody></table>
<p>​    </p>
<h4 id="2-3、关联容器与算法"><a href="#2-3、关联容器与算法" class="headerlink" title="2.3、关联容器与算法"></a>2.3、关联容器与算法</h4><blockquote>
<p>我们通常不对关联容器使用泛型算法(参见第10章)。关键字是<code>cosnt</code>这特性意味着不能将关联容器传递给修改或重排容器元素的算法,因为这类算法需要向元素写入值,而 set类型中的元素是<code>const</code>的,<code>map</code>中的元素是<code>pair</code>,其第一个成员是<code>const</code>.<br>关联容器可用于只读取元素的算法。但是,很多这类算法都要搜索序列。由于关联容器中的元素不能通过它们的关键字进行(快速)查找,因此对其使用泛型搜索算法几乎总是个坏主意。例如,我们将在11.3.5节(第388页)中看到,关联容器定义了一个名为find的成员,它通过一个给定的关键字直接获取元素。我们可以用泛型<code>find</code>算法来查找一个元素,但此算法会进行顺序搜索。使用关联容器定义的专用的find成员会比调用泛型find快得多。<br>在实际编程中,如果我们真要对一个关联容器使用算法,要么是将它当作一个源序列,要么当作一个目的位置。例如,可以用泛型<code>copy</code>算法将元素从一个关联容器拷则到另一个序列。类似的,可以调用<code>inserter</code>将一个插入器绑定(参见10.41节、第358页)到一个关联容器。通过使用<code>inserter</code>,我们可以将关联容器当作一个目的位置来调用另一个算法。  </p>
<p>[^]: C++ primer 第五版 P383</p>
</blockquote>
<p>如以下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		p.insert(<span class="built_in">make_pair</span>(i, i));</span><br><span class="line">	copy(p.begin(), p.end(), inserter(v, v.begin()));</span><br><span class="line">	<span class="comment">//v.assign(p.begin(), p.end());  也可以</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> c : v)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; c.first &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; c.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	sort(v.begin(), v.end(), [](<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p1, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p2) &#123;<span class="keyword">return</span> p1.first &gt; p2.first;&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> c : v)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; c.first &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; c.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​             </p>
<h3 id="3、无序容器"><a href="#3、无序容器" class="headerlink" title="3、无序容器"></a>3、无序容器</h3><p>继 map、multimap、set、multiset 关联式容器之后，从本节开始，再讲解一类“特殊”的关联式容器，它们常被称为“无序容器”、“哈希容器”或者“无序关联容器”。</p>
<blockquote>
<p>注意，无序容器是 <a href="http://c.biancheng.net/cplus/">C++</a> 11 标准才正式引入到 <a href="http://c.biancheng.net/stl/">STL</a> 标准库中的，这意味着如果要使用该类容器，则必须选择支持 C++ 11 标准的编译器。</p>
</blockquote>
<p>和关联式容器一样，无序容器也使用键值对（pair 类型）的方式存储数据。不过，本教程将二者分开进行讲解，因为它们有本质上的不同：</p>
<ul>
<li>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；</li>
<li>无序容器的底层实现采用的是哈希表的存储结构。</li>
</ul>
<blockquote>
<p>C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。有关哈希表存储结构，读者可阅读《<a href="http://c.biancheng.net/view/3437.html">哈希表(散列表)详解</a>》一文做详细了解。</p>
</blockquote>
<p>基于底层实现采用了不同的<a href="http://c.biancheng.net/data_structure/">数据结构</a>，因此和关联式容器相比，无序容器具有以下 2 个特点：</p>
<ol>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li>
<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li>
</ol>
<blockquote>
<p><strong>C++ STL无序容器种类</strong></p>
</blockquote>
<p>和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。</p>
<p> 表 1 对这 4 种无序容器的功能做了详细的介绍。</p>
<table>
<thead>
<tr>
<th>无序容器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>unordered_map</td>
<td>存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td>
</tr>
<tr>
<td>unordered_set</td>
<td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td>
</tr>
</tbody></table>
<p> 可能读者已经发现，以上 4 种无序容器的名称，仅是在前面所学的 4 种关联式容器名称的基础上，添加了  “unordered_”。如果读者已经学完了 map、multimap、set 和 multiset 容器不难发现，以 map 和  unordered_map 为例，其实它们仅有一个区别，<strong>即 map 容器内存会对存储的键值对进行排序，而 unordered_map 不会</strong>。</p>
<blockquote>
<p>也就是说，C++ 11 标准的 STL 中，在已提供有 4 种关联式容器的基础上，又新增了各自的“unordered”版本（无序版本、哈希版本），提高了查找指定元素的效率。</p>
</blockquote>
<p><strong>有读者可能会问，既然无序容器和之前所学的关联式容器类似，那么在实际使用中应该选哪种容器呢？总的来说，实际场景中如果涉及大量遍历容器的操作，建议首选关联式容器；反之，如果更多的操作是通过键获取对应的值，则应首选无序容器。</strong></p>
<p> 为了加深读者对无序容器的认识，这里以 unordered_map 容器为例，举个例子（不必深究该容器的具体用法）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化一个 unordered_map 容器，其存储的 &lt;string,string&gt; 类型的键值对</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; my_uMap&#123;</span><br><span class="line">       &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;Java教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//查找指定键对应的值，效率比关联式容器高</span></span><br><span class="line">     <span class="built_in">string</span> str = my_uMap.at(<span class="string">&quot;C语言教程&quot;</span>);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str = &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">//使用迭代器遍历哈希容器，效率不如关联式容器</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">auto</span> iter = my_uMap.begin(); iter != my_uMap.end(); ++iter)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//pair 类型键值对分为 2 部分</span></span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str = http:<span class="comment">//c.biancheng.net/c/</span></span><br><span class="line">C语言教程 http:<span class="comment">//c.biancheng.net/c/</span></span><br><span class="line">Python教程 http:<span class="comment">//c.biancheng.net/python/</span></span><br><span class="line">Java教程 http:<span class="comment">//c.biancheng.net/java/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>push_bak</tag>
        <tag>string</tag>
      </tags>
  </entry>
</search>
